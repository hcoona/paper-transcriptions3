\PassOptionsToPackage{dvipsnames}{xcolor}
\PassOptionsToPackage{unicode=true,colorlinks=true,urlcolor=blue}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\documentclass[a4paper,12pt,notitlepage,twoside,openright]{article}

\usepackage{ifxetex}
\ifxetex{}
\else
\errmessage{Must be built with XeLaTeX}
\fi

\input{../common/fonts.tex}
\input{../common/packages.tex}
\usepackage{endnotes}
\input{../common/setup.tex}

\title{A Unified Executors Proposal for C++}
\author{}
\date{}

\begin{document}
\maketitle

\hypertarget{design-document}{%
\section{Design Document}\label{design-document}}

\hypertarget{motivation}{%
\subsection{Motivation}\label{motivation}}

When we imagine the future of C++ programs, we envision elegant
compositions of networked, asynchronous parallel computations
accelerated by diverse hardware, ranging from tiny mobile devices to
giant supercomputers. In the present, hardware diversity is greater than
ever, but C++ programmers lack satisfying parallel programming tools for
them. Industrial-strength concurrency primitives like
\mintinline[]{text}{std::thread} and \mintinline[]{text}{std::atomic}
are powerful but hazardous. \mintinline[]{text}{std::async} and
\mintinline[]{text}{std::future} suffer from well-known problems. And
the standard algorithms library, though parallelized, remains inflexible
and non-composable.

To address these temporary challenges and build toward the future, C++
must lay a foundation for controlling program execution. First,
\textbf{C++ must provide flexible facilities to control where and when
work happens.} This paper proposes a design for those facilities. After
\protect\hyperlink{appendix-executors-bibilography}{much discussion and
collaboration}, SG1 adopted this design by universal consensus at the
Cologne meeting in 2019.

\hypertarget{usage-example}{%
\subsection{Usage Example}\label{usage-example}}

This proposal defines requirements for two key components of execution:
a work execution interface and a representation of work and their
interrelationships. Respectively, these are \textbf{executors} and
\textbf{senders and receivers}:

\begin{minted}{cpp}
// make P0443 APIs in namespace std::execution available
using namespace std::execution;

// get an executor from somewhere, e.g. a thread pool
std::static_thread_pool pool(16);
executor auto ex = pool.executor();

// use the executor to describe where some high-level library should execute its work
perform_business_logic(ex);

// alternatively, use primitive P0443 APIs directly

// immediately submit work to the pool
execute(ex, []{ std::cout << "Hello world from the thread pool!"; });

// immediately submit work to the pool and require this thread to block until completion
execute(std::require(ex, blocking.always), foo);

// describe a chain of dependent work to submit later
sender auto begin    = schedule(ex);
sender auto hi_again = then(begin, []{ std::cout << "Hi again! Have an int."; return 13; });
sender auto work     = then(hi_again, [](int arg) { return arg + 42; });

// prints the final result
receiver auto print_result = as_receiver([](int arg) { std::cout << "Received " << arg << std::endl; });

// submit the work for execution on the pool by combining with the receiver
submit(work, print_result);

// Blue: proposed by P0443. Teal: possible extensions.
\end{minted}

\hypertarget{executors-execute-work}{%
\subsection{Executors Execute Work}\label{executors-execute-work}}

As lightweight handles, executors impose uniform access to execution
contexts.

Executors provide a uniform interface for work creation by abstracting
underlying resources where work physically executes. The previous code
example's underlying resource was a thread pool. Other examples include
SIMD units, GPU runtimes, or simply the current thread. In general, we
call such resources \textbf{execution contexts}. As lightweight handles,
executors impose uniform access to execution contexts. Uniformity
enables control over where work executes, even when it is executed
indirectly behind library interfaces.

The basic executor interface is the \mintinline[]{text}{execute}
function through which clients execute work:

\begin{minted}{cpp}
// obtain an executor
executor auto ex = ...

// define our work as a nullary invocable
invocable auto work = []{ cout << "My work" << endl; };

// execute our work via the execute customization point
execute(ex, work);
\end{minted}

On its own, \mintinline[]{text}{execute} is a primitive
``fire-and-forget''-style interface. It accepts a single nullary
invocable, and returns nothing to identify or interact with the work it
creates. In this way, it trades convenience for universality. As a
consequence, we expect most programmers to interact with executors via
more convenient higher-level libraries, our envisioned asynchronous STL
being such an example.

Consider how \mintinline[]{text}{std::async} could be extended to
interoperate with executors enabling client control over execution:

\begin{minted}{cpp}
template<class Executor, class F, class Args...>
future<invoke_result_t<F,Args...>> async(const Executor& ex, F&& f, Args&&... args) {
  // package up the work
  packaged_task work(forward<F>(f), forward<Args>(args)...);

  // get the future
  auto result = work.get_future();

  // execute work on the given executor
  execution::execute(ex, move(work));

  return result;
}
\end{minted}

The benefit of such an extension is that a client can select from among
multiple thread pools to control exactly which pool
\mintinline[]{text}{std::async} uses simply by providing a corresponding
executor. Inconveniences of work packaging and submission become the
library's responsibility.

\textbf{Authoring executors.} Programmers author custom executor types
by defining a type with an \mintinline[]{text}{execute} function.
Consider the implementation of an executor whose
\mintinline[]{text}{execute} function executes the client's work
``inline'':

\begin{minted}{cpp}
struct inline_executor {
  // define execute
  template<class F>
  void execute(F&& f) const noexcept {
    std::invoke(std::forward<F>(f));
  }

  // enable comparisons
  auto operator<=>(const inline_executor&) const = default;
};
\end{minted}

Additionally, a comparison function determines whether two executor
objects refer to the same underlying resource and therefore execute with
equivalent semantics. Concepts \mintinline[]{text}{executor} and
\mintinline[]{text}{executor_of} summarize these requirements. The
former validates executors in isolation; the latter, when both executor
and work are available.

\textbf{Executor customization} can accelerate execution or introduce
novel behavior. The previous example demonstrated custom execution at
the granularity of a new executor type, but finer-grained and
coarser-grained customization techniques are also possible. These are
\textbf{executor properties} and \textbf{control structures},
respectively.

\textbf{Executor properties} communicate optional behavioral
requirements beyond the minimal contract of
\mintinline[]{text}{execute}, and this proposal specifies several. We
expect expert implementors to impose these requirements beneath
higher-level abstractions. In principle, optional, dynamic data members
or function parameters could communicate these requirements, but C++
requires the ability to introduce customization at compile time.
Moreover, optional parameters lead to
\href{https://wg21.link/P2033}{combinatorially many function variants}.

Instead, statically-actionable properties factor such requirements and
thereby avoid a combinatorial explosion of executor APIs. For example,
consider the requirement to execute blocking work with priority. An
unscalable design might embed these options into the
\mintinline[]{text}{execute} interface by multiplying individual factors
into separate functions: \mintinline[]{text}{execute},
\mintinline[]{text}{blocking_execute},
\mintinline[]{text}{execute_with_priority},
\mintinline[]{text}{blocking_execute_with_priority}, etc.

Executors avoid this unscalable situation by adopting
\href{https://wg21.link/P1393}{P1393}'s properties design based on
\mintinline[]{text}{require} and \mintinline[]{text}{prefer}:

\begin{minted}{cpp}
// obtain an executor
executor auto ex = ...;

// require the execute operation to block
executor auto blocking_ex = std::require(ex, execution::blocking.always);

// prefer to execute with a particular priority p
executor auto blocking_ex_with_priority = std::prefer(blocking_ex, execution::priority(p));

// execute my blocking, possibly prioritized work
execution::execute(blocking_ex_with_priority, work);
\end{minted}

Each application of \mintinline[]{text}{require} or
\mintinline[]{text}{prefer} transforms an executor into one with the
requested property. In this example, if \mintinline[]{text}{ex} cannot
be transformed into a blocking executor, the call to
\mintinline[]{text}{require} will fail to compile.
\mintinline[]{text}{prefer} is a weaker request used to communicate
hints and consequently always succeeds because it may ignore the
request.

Consider a version of \mintinline[]{text}{std::async} which \emph{never}
blocks the caller:

\begin{minted}{cpp}
template<executor E, class F, class... Args>
auto really_async(const E& ex, F&& f, Args&&... args) {
  // package up the work
  std::packaged_task work(std::forward<F>(f), std::forward<Args>(args)...);

  // get the future
  auto result = work.get_future();

  // execute the nonblocking work on the given executor
  execution::execute(std::require(ex, execution::blocking.never), std::move(work));

  return result;
}
\end{minted}

Such an enhancement could address a well-known hazard of
\mintinline[]{text}{std::async}:

\begin{minted}{cpp}
// confusingly, always blocks in the returned but discarded future's destructor
std::async(foo);

// *never* blocks
really_async(ex, foo);
\end{minted}

\textbf{Control structures} permit customizations at a higher level of
abstraction by allowing executors to ``hook'' them and is useful when an
efficient implementation is possible on a particular execution context.
The first such control structure this proposal defines is
\mintinline[]{text}{bulk_execute}, which creates a group of function
invocations in a single operation. This pattern permits a wide range of
efficient implementations and is of fundamental importance to C++
programs and the standard library.

By default, \mintinline[]{text}{bulk_execute} invokes
\mintinline[]{text}{execute} repeatedly, but repeatedly executing
individual work items is inefficient at scale. Consequently, many
platforms provide APIs that explicitly and efficiently execute bulk
work. In such cases, a custom \mintinline[]{text}{bulk_execute} avoids
inefficient platform interactions via direct access to these accelerated
bulk APIs while also optimizing the use of scalar APIs.

\mintinline[]{text}{bulk_execute} receives an invocable and an
invocation count. Consider a possible implementation:

\begin{minted}{cpp}
struct simd_executor : inline_executor { // first, satisfy executor requirements via inheritance
  template<class F>
  simd_sender bulk_execute(F f, size_t n) const {
    #pragma simd
    for(size_t i = 0; i != n; ++i) {
      std::invoke(f, i);
    }

    return {};
  }
};
\end{minted}

To accelerate \mintinline[]{text}{bulk_execute},
\mintinline[]{text}{simd_executor} uses a SIMD loop.

\mintinline[]{text}{bulk_execute} should be used in cases where multiple
pieces of work are available at once:

\begin{minted}{cpp}
template<class Executor, class F, class Range>
void my_for_each(const Executor& ex, F f, Range rng) {
  // request bulk execution, receive a sender
  sender auto s = execution::bulk_execute(ex, [=](size_t i) {
    f(rng[i]);
  }, std::ranges::size(rng));

  // initiate execution and wait for it to complete
  execution::sync_wait(s);
}
\end{minted}

\mintinline[]{text}{simd_executor}'s particular
\mintinline[]{text}{bulk_execute} implementation executes ``eagerly'',
but \mintinline[]{text}{bulk_execute}'s semantics do not require it. As
\mintinline[]{text}{my_for_each} demonstrates, unlike
\mintinline[]{text}{execute}, \mintinline[]{text}{bulk_execute} is an
example of a ``lazy'' operation whose execution may be optionally
postponed. The token this \mintinline[]{text}{bulk_execute} returns is
an example of a sender a client may use to initiate execution or
otherwise interact with the work. For example, calling
\mintinline[]{text}{sync_wait} on the sender ensures that the bulk work
completes before the caller continues. Senders and receivers are the
subject of the next section.

\hypertarget{senders-and-receivers-represent-work}{%
\subsection{Senders and Receivers Represent
Work}\label{senders-and-receivers-represent-work}}

The \mintinline[]{text}{executor} concept addresses a basic need of
executing a single operation in a specified execution context. The
expressive power of \mintinline[]{text}{executor} is limited, however:
since \mintinline[]{text}{execute} returns \mintinline[]{text}{void}
instead of a handle to the just-scheduled work, the
\mintinline[]{text}{executor} abstraction gives no generic way to chain
operations and thereby propagate values, errors, and cancellation
signals downstream; no way to handle scheduling errors occurring between
when work submission and execution; and no convenient way to control the
allocation and lifetime of state associated with an operation.

Without such controls, it is not possible to define Generic (in the
Stepanov sense) asynchronous algorithms that compose efficiently with
sensible default implementations. To fill this gap, this paper proposes
two related abstractions, \mintinline[]{text}{sender} and
\mintinline[]{text}{receiver}, concretely motivated below.

\hypertarget{generic-async-algorithm-example-retry}{%
\subsubsection{\texorpdfstring{Generic async algorithm example:
\mintinline[]{text}{retry}}{Generic async algorithm example: }}\label{generic-async-algorithm-example-retry}}

\mintinline[]{text}{retry} is the kind of Generic algorithm senders and
receivers enable. It has simple semantics: schedule work on an execution
context; if the execution succeeds, done; otherwise, if the user
requests cancellation, done; otherwise, if a scheduling error occurs,
try again.

\begin{minted}{cpp}
template<invocable Fn>
void retry(executor_of<Fn> auto ex, Fn fn) {
  // ???
}
\end{minted}

Executors alone prohibit a generic implementation because they lack a
portable way to intercept and react to scheduling errors. Later we show
how this algorithm might look when implemented with senders and
receivers.

\hypertarget{goal-an-asynchronous-stl}{%
\subsubsection{Goal: an asynchronous
STL}\label{goal-an-asynchronous-stl}}

Suitably chosen concepts driving the definition of Generic async
algorithms like \mintinline[]{text}{retry} streamline the creation of
efficient, asynchronous graphs of work. Here is some sample syntax for
the sorts of async programs we envision (borrowed from
\href{http://wg21.link/P1897}{P1897}):

\begin{minted}{cpp}
sender auto s = just(3) |                               // produce '3' immediately
                on(scheduler1) |                        // transition context
                transform([](int a){return a+1;}) |     // chain continuation
                transform([](int a){return a*2;}) |     // chain another continuation
                on(scheduler2) |                        // transition context
                let_error([](auto e){return just(3);}); // with default value on errors
int r = sync_wait(s);                                   // wait for the result
\end{minted}

It should be possible to replace \mintinline[]{text}{just(3)} with a
call to any asynchronous API whose return type satisfies the correct
concept and maintain this program's correctness. Generic algorithms like
\mintinline[]{text}{when_all} and \mintinline[]{text}{when_any} would
permit users to express fork/join concurrency in their DAGs. As with
STL's \mintinline[]{text}{iterator} abstraction, the cost of satisfying
the conceptual requirements are offset by the expressivity of a large
reusable and composable library of algorithms.

\hypertarget{current-techniques}{%
\subsubsection{Current techniques}\label{current-techniques}}

There are many techniques for creating chains of dependent asynchronous
execution. Ordinary callbacks have enjoyed success in C++ and elsewhere
for years. Modern codebases have switched to variations of future
abstractions that support continuations (e.g.,
\mintinline[]{text}{std::experimental::future::then}). In C++20 and
beyond, we could imagine standardizing on coroutines, so that launching
an async operation returns an awaitable. Each of these approaches has
strengths and weaknesses.

\textbf{Futures}, as traditionally realized, require the dynamic
allocation and management of a shared state, synchronization, and
typically type-erasure of work and continuation. Many of these costs are
inherent in the nature of ``future'' as a handle to an operation that is
already scheduled for execution. These expenses rule out the future
abstraction for many uses and makes it a poor choice for a basis of a
Generic mechanism.

\textbf{Coroutines} suffer many of the same problems but can avoid
synchronizing when chaining dependent work because they typically start
suspended. In many cases, coroutine frames require unavoidable dynamic
allocation. Consequently, coroutines in embedded or heterogeneous
environments require great attention to detail. Neither are coroutines
good candidates for cancellation because the early and safe termination
of coordinating coroutines requires unsatisfying solutions. On the one
hand, exceptions are inefficient and disallowed in many environments.
Alternatively, clumsy \emph{ad hoc} mechanisms, whereby
\mintinline[]{text}{co_yield} returns a status code, hinder correctness.
\href{http://wg21.link/P1662}{P1662} provides a complete discussion.

\textbf{Callbacks} are the simplest, most powerful, and most efficient
mechanism for creating chains of work, but suffer problems of their own.
Callbacks must propagate either errors or values. This simple
requirement yields many different interface possibilities, but the lack
of a standard obstructs Generic design. Additionally, few of these
possibilities accomodate cancellation signals when the user requests
upstream work to stop and clean up.

\hypertarget{receiver-sender-and-scheduler}{%
\subsection{Receiver, sender, and
scheduler}\label{receiver-sender-and-scheduler}}

With the preceding as motivation, we introduce primitives to address the
needs of Generic asynchronous programming in the presence of value,
error, and cancellation propagation.

\hypertarget{receiver}{%
\subsubsection{Receiver}\label{receiver}}

A \mintinline[]{text}{receiver} is simply a callback with a particular
interface and semantics. Unlike a traditional callback which uses
function-call syntax and a single signature handling both success and
error cases, a receiver has three separate channels for value, error,
and ``done'' (aka cancelled).

These channels are specified as customization points, and a type
\mintinline[]{text}{R} modeling
\mintinline[]{text}{receiver_of<R,Ts...>} supports them:

\begin{minted}{cpp}
std::execution::set_value(r, ts...); // signal success, but set_value itself may fail
std::execution::set_error(r, ep);    // signal error (ep is std::exception_ptr), never fails
std::execution::set_done(r);         // signal stopped, never fails
\end{minted}

Exactly one of the three functions must be called on a
\mintinline[]{text}{receiver} before it is destroyed. Each of these
interfaces is considered ``terminal''. That is, a particular receiver
may assume that if one is called, no others ever will be. The one
exception being if \mintinline[]{text}{set_value} exits with an
exception, the receiver is not yet complete. Consequently, another
function must be called on it before it is destroyed. After a failed
call to \mintinline[]{text}{set_value}, correctness requires a
subsequent call either to \mintinline[]{text}{set_error} or
\mintinline[]{text}{set_done}; a receiver need not guarantee that a
second call to \mintinline[]{text}{set_value} is well-formed.
Collectively, these requirements are the ``\emph{receiver contract}''.

Although \mintinline[]{text}{receiver}'s interface appears novel at
first glance, it remains just a callback. Moreover,
\mintinline[]{text}{receiver}'s novelty disappears when recognizing that
\mintinline[]{text}{std::promise}'s \mintinline[]{text}{set_value} and
\mintinline[]{text}{set_exception} provide essentially the same
interface. This choice of interface and semantics, along with
\mintinline[]{text}{sender}, facilitate the Generic implementation of
many useful async algorithms like \mintinline[]{text}{retry}.

\hypertarget{sender}{%
\subsubsection{Sender}\label{sender}}

A \mintinline[]{text}{sender} represents work that has not been
scheduled for execution yet, to which one must add a continuation (a
\mintinline[]{text}{receiver}) and then ``launch'', or enqueue for
execution. A sender's duty to its connected receiver is to fulfill the
\emph{receiver contract} by ensuring that one of the three
\mintinline[]{text}{receiver} functions returns normally.

Earlier versions of this paper fused these two operations --- attach a
continuation and launch for execution --- into the single operation
\mintinline[]{text}{submit}. This paper proposes to split
\mintinline[]{text}{submit} into a \mintinline[]{text}{connect} step
that packages a \mintinline[]{text}{sender} and a
\mintinline[]{text}{receiver} into an operation state, and a
\mintinline[]{text}{start} step that logically starts the operation and
schedules the receiver completion-signalling methods to be called when
the operation completes.

\begin{minted}{cpp}
// P0443R12
std::execution::submit(snd, rec);

// P0443R13
auto state = std::execution::connect(snd, rec);
// ... later
std::execution::start(state);
\end{minted}

This split offers interesting opportunities for optimization, and
\protect\hyperlink{appendix-a-note-on-coroutines}{harmonizes senders
with coroutines}.

The \mintinline[]{text}{sender} concept itself places no requirements on
the execution context on which a sender's work executes. Instead,
specific models of the \mintinline[]{text}{sender} concept may offer
stronger guarantees about the context from which the receiver's methods
will be invoked. This is particularly true of the senders created by a
\mintinline[]{text}{scheduler}.

\hypertarget{scheduler}{%
\subsubsection{Scheduler}\label{scheduler}}

Many generic async algorithms create multiple execution agents on the
same execution context. Therefore, it is insufficient to parameterize
these algorithms with a single-shot sender completing in a known
context. Rather, it makes sense to pass these algorithms a factory of
single-shot senders. Such a factory is called a
``\mintinline[]{text}{scheduler}'', and it has a single basis operation:
\mintinline[]{text}{schedule}:

\begin{minted}{cpp}
sender auto s = std::execution::schedule(sched);
// OK, s is a single-shot sender of void that completes in sched's execution context
\end{minted}

Like executors, schedulers act as handles to an execution context.
Unlike executors, schedulers submit execution lazily, but a single type
may simultaneously model both concepts. We envision that subsumptions of
the \mintinline[]{text}{scheduler} concept will add the ability to
postpone or cancel execution until after some time period has elapsed.

\hypertarget{senders-receivers-and-generic-algorithms}{%
\subsection{Senders, receivers, and generic
algorithms}\label{senders-receivers-and-generic-algorithms}}

Useful concepts constrain generic algorithms while allowing default
implementations via those concepts' basis operations. Below, we show how
these \mintinline[]{text}{sender} and \mintinline[]{text}{receiver}
provide efficient default implementations of common async algorithms. We
envision that most generic async algorithms will be implemented as
taking a sender and returning a sender whose
\mintinline[]{text}{connect} method wraps its receiver an adaptor that
implements the algorithm's logic. The \mintinline[]{text}{then}
algorithm below, which chains a continuation function on a
\mintinline[]{text}{sender}, is a simple demonstration.

\hypertarget{algorithm-then}{%
\subsubsection{\texorpdfstring{Algorithm
\mintinline[]{text}{then}}{Algorithm }}\label{algorithm-then}}

The following code implements a \mintinline[]{text}{then} algorithm
that, like \mintinline[]{text}{std::experimental::future::then},
schedules a function to be applied to the result of an asynchronous
operation when available. This code demonstrates how an algorithm can
adapt receivers to codify the algorithm's logic.

\begin{minted}{cpp}
template<receiver R, class F>
struct _then_receiver : R { // for exposition, inherit set_error and set_done from R
    F f_;

    // Customize set_value by invoking the callable and passing the result to the base class
    template<class... As>
      requires receiver_of<R, invoke_result_t<F, As...>>
    void set_value(As&&... as) && noexcept(/*...*/) {
      std::execution::set_value((R&&) *this, invoke((F&&) f_, (As&&) as...));
    }

    // Not shown: handle the case when the callable returns void
};

template<sender S, class F>
struct _then_sender : std::execution::sender_base {
    S s_;
    F f_;

    template<receiver R>
      requires sender_to<S, _then_receiver<R, F>>
    state_t<S, _then_receiver<R, F>> connect(R r) && {
        return std::execution::connect((S&&)s_, _then_receiver<R, F>{(R&&)r, (F&&)f_});
    }
};

template<sender S, class F>
sender auto then(S s, F f) {
    return _then_sender{{}, (S&&)s, (F&&)f};
}
\end{minted}

Given some asynchronous, \mintinline[]{text}{sender}-returning API
\mintinline[]{text}{async_foo}, a user of \mintinline[]{text}{then} can
execute some code once the async result is available:

\begin{minted}{cpp}
sender auto s = then(async_foo(args...), [](auto result) {/* stuff... */});
\end{minted}

This builds a composed asynchronous operation. When the user wants to
schedule this operation for execution, they would
\mintinline[]{text}{connect} a receiver, and then call
\mintinline[]{text}{start} on the resulting operation state.

Scheduling work on an execution context can also be done with
\mintinline[]{text}{then}. Given a
\mintinline[]{text}{static_thread_pool} object \mintinline[]{text}{pool}
that satisfied the \mintinline[]{text}{scheduler} concept, a user may do
the following:

\begin{minted}{cpp}
sender auto s = then(
    std::execution::schedule( pool ),
    []{ std::printf("hello world"); } );
\end{minted}

This creates a \mintinline[]{text}{sender} that, when submitted, will
call \mintinline[]{text}{printf} from a thread in the thread pool.

There exist heterogeneous computing environments that are unable to
execute arbitrary code. For those, an implementation of
\mintinline[]{text}{then} as shown above would either not work or would
incur the cost of a transition to the host in order to execute the
unknown code. Therefore, \mintinline[]{text}{then} itself and several
other fundamental algorithmic primitives, would themselves need to be
customizable on a per-execution context basis.

A full working example of \mintinline[]{text}{then} can be found here:
\url{https://godbolt.org/z/dafqM-}

\hypertarget{algorithm-retry}{%
\subsubsection{\texorpdfstring{Algorithm
\mintinline[]{text}{retry}}{Algorithm }}\label{algorithm-retry}}

As described above, the idea of \mintinline[]{text}{retry} is to retry
the async operation on failure, but not on success or cancellation. Key
to a correct generic implementation of \mintinline[]{text}{retry} is the
ability to distinguish the error case from the cancelled case.

As with the \mintinline[]{text}{then} algorithm, the
\mintinline[]{text}{retry} algorithm places the logic of the algorithm
into a custom receiver to which the sender to be retried is
\mintinline[]{text}{connect}-ed.~That custom receiver has
\mintinline[]{text}{set_value} and \mintinline[]{text}{set_done} members
that simply pass their signals through unmodified. The
\mintinline[]{text}{set_error} member, on the other hand, reconstructs
the operation state in-place by making another call to
\mintinline[]{text}{connect} with the original sender and a new instance
of the custom receiver. That new operation state is then
\mintinline[]{text}{start}-ed again, which effectively causes the
original sender to be retried.

\protect\hyperlink{appendix-the-retry-algorithm}{The appendix} lists the
source of the \mintinline[]{text}{retry} algorithm. Note that the
signature of the retry algorithm is simply:

\begin{minted}{cpp}
sender auto retry(sender auto s);
\end{minted}

That is, it is not parameterized on an execution context on which to
retry the operation. That is because we can assume the existence of a
function \mintinline[]{text}{on} which schedules a sender for execution
on a specified execution context:

\begin{minted}{cpp}
sender auto on(sender auto s, scheduler auto sched);
\end{minted}

Given these two functions, a user can simply do
\mintinline[]{text}{retry(on(s, sched))} to retry an operation on a
particular execution context.

\hypertarget{toward-an-asynchronous-stl}{%
\subsubsection{Toward an asynchronous
STL}\label{toward-an-asynchronous-stl}}

The algorithms \mintinline[]{text}{then} and \mintinline[]{text}{retry}
are only two of many interesting Generic asynchronous algorithms that
are expressible in terms of senders and receivers. Two other important
algorithms are \mintinline[]{text}{on} and \mintinline[]{text}{via}, the
former which schedules a sender for execution on a particular
\mintinline[]{text}{scheduler}, and the latter which causes a sender's
\emph{continuations} to be run on a particular
\mintinline[]{text}{scheduler}. In this way, chains of asynchronous
computation can be created that transition from one execution context to
another.

Other important algorithms are \mintinline[]{text}{when_all} and
\mintinline[]{text}{when_any}, encapsulating fork/join semantics. With
these algorithms and others, entire DAGs of async computation can be
created and executed. \mintinline[]{text}{when_any} can in turn be used
to implement a generic \mintinline[]{text}{timeout} algorithm, together
with a sender that sleeps for a duration and then sends a ``done''
signal, and so these algorithms compose.

In short, sender/receiver permits a rich set of Generic asynchronous
algorithms to sit alongside Stepanov's sequence algorithms in the STL.
Asynchronous APIs that return senders would be usable with these Generic
algorithms, increasing reusability. \href{http://wg21.link/P1897}{P1897}
suggest an initial set of these algorithms.

\hypertarget{summary}{%
\subsection{Summary}\label{summary}}

We envision a future when C++ programmers can express asynchronous,
parallel execution of work on diverse hardware resources through elegant
standard interfaces. This proposal provides a foundation for flexible
execution and is our initial step towards that goal. \textbf{Executors}
represent hardware resources that execute work. \textbf{Senders and
receivers} represent lazily-constructed asynchronous DAGs of work. These
primitives empower programmers to control where and when work happens.

\hypertarget{changelog}{%
\subsection{Changelog}\label{changelog}}

\hypertarget{revision-14}{%
\subsubsection{Revision 14}\label{revision-14}}

Fixed many editorial issues and these bug fixes:

\begin{itemize}

\item
  \href{https://github.com/executors/executors/issues/462}{as-receiver::set\_error()
  should accept any error type, not just std::exception\_ptr}
\item
  \href{https://github.com/executors/executors/issues/473}{execution::connect
  should require its second argument to satisfy receiver}
\item
  \href{https://github.com/executors/executors/issues/474}{Constrain
  recursion in sender\_to and executor\_of concepts}
\item
  \href{https://github.com/executors/executors/issues/508}{any\_executor's
  FIND\_CONVERTIBLE\_PROPERTY can lead to wrong results}
\item
  \href{https://github.com/executors/executors/issues/512}{Generic
  blocking adapter is not implementable}
\end{itemize}

\hypertarget{revision-13}{%
\subsubsection{Revision 13}\label{revision-13}}

As directed by SG1 at the 2020-02 Prague meeting, we have split the
\mintinline[]{text}{submit} operation into the primitive operations
\mintinline[]{text}{connect} and \mintinline[]{text}{start}.

\hypertarget{revision-12}{%
\subsubsection{Revision 12}\label{revision-12}}

Introduced introductory design discussion which replaces the obsolete
\href{https://wg21.link/P0761}{P0761}. No normative changes.

\hypertarget{revision-11}{%
\subsubsection{Revision 11}\label{revision-11}}

As directed by SG1 at the 2019-07 Cologne meeting, we have implemented
the following changes suggested by P1658 and P1660 which incorporate
``lazy'' execution:

\begin{itemize}

\item
  Eliminated all interface-changing properties.
\item
  Introduced \mintinline[]{text}{set_value},
  \mintinline[]{text}{set_error}, \mintinline[]{text}{set_done},
  \mintinline[]{text}{execute}, \mintinline[]{text}{submit}, and
  \mintinline[]{text}{bulk_execute} customization point objects.
\item
  Introduced \mintinline[]{text}{executor},
  \mintinline[]{text}{executor_of}, \mintinline[]{text}{receiver},
  \mintinline[]{text}{receiver_of}, \mintinline[]{text}{sender},
  \mintinline[]{text}{sender_to}, \mintinline[]{text}{typed_sender}, and
  \mintinline[]{text}{scheduler} concepts.
\item
  Renamed polymorphic executor to \mintinline[]{text}{any_executor}.
\item
  Introduced \mintinline[]{text}{invocable_archetype}.
\item
  Eliminated \mintinline[]{text}{OneWayExecutor} and
  \mintinline[]{text}{BulkOneWayExecutor} requirements.
\item
  Eliminated \mintinline[]{text}{is_executor},
  \mintinline[]{text}{is_oneway_executor}, and
  \mintinline[]{text}{is_bulk_oneway_executor} type traits.
\item
  Eliminated interface-changing properties from
  \mintinline[]{text}{any_executor}.
\end{itemize}

\hypertarget{revision-10}{%
\subsubsection{Revision 10}\label{revision-10}}

As directed by LEWG at the 2018-11 San Diego meeting, we have migrated
the property customization mechanism to namespace
\mintinline[]{text}{std} and moved all of the details of its
specification to a separate paper, \href{http://wg21.link/P1393}{P1393}.
This change also included the introduction of a separate customization
point for interface-enforcing properties,
\mintinline[]{text}{require_concept}. The generalization also
necessitated the introduction of
\mintinline[]{text}{is_applicable_property_v} in the properties paper,
which in turn led to the introduction of
\mintinline[]{text}{is_executor_v} to express the applicability of
properties in this paper.

\hypertarget{revision-9}{%
\subsubsection{Revision 9}\label{revision-9}}

As directed by the SG1/LEWG straw poll taken during the 2018 Bellevue
executors meeting, we have separated The Unified Executors programming
model proposal into two papers. This paper contains material related to
one-way execution which the authors hope to standardize with C++20 as
suggested by the Bellevue poll. \href{http://wg21.link/P1244}{P1244}
contains remaining material related to dependent execution. We expect
P1244 to evolve as committee consensus builds around a design for
dependent execution.

This revision also contains bug fixes to the
\mintinline[]{text}{allocator_t} property which were originally
scheduled for Revision 7 but were inadvertently omitted.

\hypertarget{revision-8}{%
\subsubsection{Revision 8}\label{revision-8}}

Revision 8 of this proposal makes interface-changing properties such as
\mintinline[]{text}{oneway} mutually exclusive in order to simplify
implementation requirements for executor adaptors such as polymorphic
executors. Additionally, this revision clarifies wording regarding
execution agent lifetime.

\hypertarget{revision-7}{%
\subsubsection{Revision 7}\label{revision-7}}

Revision 7 of this proposal corrects wording bugs discovered by the
authors after Revision 6's publication.

\begin{itemize}

\item
  Enhanced \mintinline[]{text}{static_query_v} to result in a default
  property value for executors which do not provide a
  \mintinline[]{text}{query} function for the property of interest
\item
  Revise \mintinline[]{text}{then_execute} and
  \mintinline[]{text}{bulk_then_execute}'s operational semantics to
  allow user functions to handle incoming exceptions thrown by preceding
  execution agents
\item
  Introduce \mintinline[]{text}{exception_arg} to disambiguate the user
  function's exceptional overload from its nonexceptional overload in
  \mintinline[]{text}{then_execute} and
  \mintinline[]{text}{bulk_then_execute}
\end{itemize}

\hypertarget{revision-6}{%
\subsubsection{Revision 6}\label{revision-6}}

Revision 6 of this proposal corrects bugs and omissions discovered by
the authors after Revision 5's publication, and introduces an
enhancement improving the safety of the design.

\begin{itemize}

\item
  Enforce mutual exclusion of behavioral properties via the type system
  instead of via convention
\item
  Introduce missing \mintinline[]{text}{execution::require} adaptations
\item
  Allow executors to opt-out of invoking factory functions when
  appropriate
\item
  Various bug fixes and corrections
\end{itemize}

\hypertarget{revision-5}{%
\subsubsection{Revision 5}\label{revision-5}}

Revision 5 of this proposal responds to feedback requested during the
2017 Albuquerque ISO C++ Standards Committee meeting and introduces
changes which allow properties to better interoperate with polymorphic
executor wrappers and also simplify
\mintinline[]{text}{execution::require}'s behavior.

\begin{itemize}

\item
  Defined general property type requirements
\item
  Elaborated specification of standard property types
\item
  Simplified \mintinline[]{text}{execution::require}'s specification
\item
  Enhanced polymorphic executor wrapper

  \begin{itemize}

  \item
    Templatized
    \mintinline[]{text}{execution::executor<SupportableProperties...>}
  \item
    Introduced \mintinline[]{text}{prefer_only} property adaptor
  \end{itemize}
\item
  Responded to Albuquerque feedback

  \begin{itemize}

  \item
    From SG1

    \begin{itemize}

    \item
      Execution contexts are now optional properties of executors
    \item
      Eliminated ill-specified caller-agent forward progress properties
    \item
      Elaborated \mintinline[]{text}{Future}'s requirements to
      incorporate forward progress
    \item
      Reworded operational semantics of execution functions to use
      similar language as the blocking properties
    \item
      Elaborated \mintinline[]{text}{static_thread_pool}'s specification
      to guarantee that threads in the bool boost-block their work
    \item
      Elaborated operational semantics of execution functions to note
      that forward progress guarantees are specific to the concrete
      executor type
    \end{itemize}
  \item
    From LEWG

    \begin{itemize}

    \item
      Eliminated named \mintinline[]{text}{BaseExecutor} concept
    \item
      Simplified general executor requirements
    \item
      Enhanced the \mintinline[]{text}{OneWayExecutor} introductory
      paragraph
    \item
      Eliminated \mintinline[]{text}{has_*_member} type traits
    \end{itemize}
  \end{itemize}
\item
  Minor changes

  \begin{itemize}

  \item
    Renamed TS namespace from \mintinline[]{text}{concurrency_v2} to
    \mintinline[]{text}{executors_v1}
  \item
    Introduced \mintinline[]{text}{static_query_v} enabling static
    queries
  \item
    Eliminated unused \mintinline[]{text}{property_value} trait
  \item
    Eliminated the names \mintinline[]{text}{allocator_wrapper_t} and
    \mintinline[]{text}{default_allocator}
  \end{itemize}
\end{itemize}

\hypertarget{revision-4}{%
\subsubsection{Revision 4}\label{revision-4}}

\begin{itemize}

\item
  Specified the guarantees implied by
  \mintinline[]{text}{bulk_sequenced_execution},
  \mintinline[]{text}{bulk_parallel_execution}, and
  \mintinline[]{text}{bulk_unsequenced_execution}
\end{itemize}

\hypertarget{revision-3}{%
\subsubsection{Revision 3}\label{revision-3}}

\begin{itemize}

\item
  Introduced \mintinline[]{text}{execution::query()} for executor
  property introspection
\item
  Simplified the design of \mintinline[]{text}{execution::prefer()}
\item
  \mintinline[]{text}{oneway}, \mintinline[]{text}{twoway},
  \mintinline[]{text}{single}, and \mintinline[]{text}{bulk} are now
  \mintinline[]{text}{require()}-only properties
\item
  Introduced properties allowing executors to opt into adaptations that
  add blocking semantics
\item
  Introduced properties describing the forward progress relationship
  between caller and agents
\item
  Various minor improvements to existing functionality based on
  prototyping
\end{itemize}

\hypertarget{revision-2}{%
\subsubsection{Revision 2}\label{revision-2}}

\begin{itemize}

\item
  Separated wording from explanatory prose, now contained in paper
  \href{https://wg21.link/P0761}{P0761}
\item
  Applied the simplification proposed by paper
  \href{https://wg21.link/P0688}{P0688}
\end{itemize}

\hypertarget{revision-1}{%
\subsubsection{Revision 1}\label{revision-1}}

\begin{itemize}

\item
  Executor category simplification
\item
  Specified executor customization points in detail
\item
  Introduced new fine-grained executor type traits

  \begin{itemize}

  \item
    Detectors for execution functions
  \item
    Traits for introspecting cross-cutting concerns

    \begin{itemize}

    \item
      Introspection of mapping of agents to threads
    \item
      Introspection of execution function blocking behavior
    \end{itemize}
  \end{itemize}
\item
  Allocator support for single agent execution functions
\item
  Renamed \mintinline[]{text}{thread_pool} to
  \mintinline[]{text}{static_thread_pool}
\item
  New introduction
\end{itemize}

\hypertarget{revision-0}{%
\subsubsection{Revision 0}\label{revision-0}}

\begin{itemize}

\item
  Initial design
\end{itemize}

\hypertarget{appendix-executors-bibilography}{%
\subsection{Appendix: Executors
Bibilography}\label{appendix-executors-bibilography}}

\begin{longtable}[]{@{}lll@{}}
\toprule
\begin{minipage}[b]{0.32\columnwidth}\raggedright
Paper\strut
\end{minipage} & \begin{minipage}[b]{0.54\columnwidth}\raggedright
Notes\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright
Date introduced\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/N3378}{N3378 - A preliminary proposal for work
executors}\\
\href{https://wg21.link/N3562}{N3562 - Executors and schedulers,
revision 1}\\
\href{https://wg21.link/N3371}{N3731 - Executors and schedulers,
revision 2}\\
\href{https://wg21.link/N3785}{N3785 - Executors and schedulers,
revision 3}\\
\href{https://wg21.link/N4143}{N4143 - Executors and schedulers,
revision 4}\\
\href{https://wg21.link/N4414}{N4414 - Executors and schedulers,
revision 5}\\
\href{https://wg21.link/P0008}{P0008 - C++ Executors}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Initial executors proposal from Google, based on an abstract base
class.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2012-02-24\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/N4046}{N4046 - Executors and Asynchronous
Operations}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Initial executors proposal from Kohlhoff, based on extensions to
ASIO.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2014-05-26\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/N4406}{N4406 - Parallel Algorithms Need
Executors}\\
\href{https://wg21.link/P0058}{P0058 - An interface for abstracting
execution}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Initial executors proposal from Nvidia, based on a traits class.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2015-04-10\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P0285}{P0285 - Using customization points to
unify executors}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Proposes unifying various competing executors proposals via
customization points.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2016-02-14\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P0443}{P0443 - A Unified Executors Proposal for
C++}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
This proposal.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2016-10-17\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P0688}{P0688 - A Proposal to Simplify the
Executors Design}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Proposes simplifying this proposal's APIs using properties.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2017-06-19\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P0761}{P0761 - Executors Design Document}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Describes the design of this proposal circa 2017.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2017-07-31\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1055}{P1055 - A Modest Executor Proposal}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Initial executors proposal from Facebook, based on lazy execution.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2018-04-26\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1194}{P1194 - The Compromise Executors
Proposal: A lazy simplification of P0443}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Initial proposal to integrate senders and receivers into this
proposal.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2018-10-08\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1232}{P1232 - Integrating executors with the
standard library through customization}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Proposes to allow executors to customize standard algorithms
directly.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2018-10-08\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1244}{P1244 - Dependent Execution for a Unified
Executors Proposal for C++}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Vestigal futures-based dependent execution functionality excised from
later revisions of this proposal.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2018-10-08\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1341}{P1341 - Unifying asynchronous APIs in C++
standard Library}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Proposes enhancements making senders awaitable.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2018-11-25\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1393}{P1393 - A General Property Customization
Mechanism}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Standalone paper proposing the property customization used by P0443
executors.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-01-13\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1677}{P1677 - Cancellation is
serendipitous-success}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Motivates the need for \mintinline[]{text}{done} in addition to
\mintinline[]{text}{error}.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-05-18\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1678}{P1678 - Callbacks and Composition}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Argues for callbacks/receivers as a universal design pattern in the
standard library.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-05-18\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1525}{P1525 - One-Way execute is a Poor Basis
Operation}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Identifies deficiencies of \mintinline[]{text}{execute} as a basis
operation.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-06-17\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1658}{P1658 - Suggestions for Consensus on
Executors}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Suggests progress-making changes to this proposal circa 2019.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-06-17\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1660}{P1660 - A Compromise Executor Design
Sketch}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Proposes concrete changes to this proposal along the lines of
\href{https://wg21.link/P1525}{P1525},
\href{https://wg21.link/P1658}{P1658}, and
\href{https://wg21.link/P1738}{P1738}.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-06-17\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1738}{P1738 - The Executor Concept Hierarchy
Needs a Single Root}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Identifies problems caused by a multi-root executor concept
hierarchy.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-06-17\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1897}{P1897 - Towards C++23 executors: A
proposal for an initial set of algorithms}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Initial proposal for a set of customizable sender algorithms.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-10-06\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P1898}{P1898 - Forward progress delegation for
executors}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Proposes a model of forward progress for executors and asynchronous
graphs of work.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2019-10-06\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P2006}{P2006 - Splitting submit() into
connect()/start()}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Proposes refactoring \mintinline[]{text}{submit} into more fundamental
\mintinline[]{text}{connect} and \mintinline[]{text}{start} sender
operations.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2020-01-13\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright
\href{https://wg21.link/P2033}{P2033 - History of Executor
Properties}\strut
\end{minipage} & \begin{minipage}[t]{0.54\columnwidth}\raggedright
Documents the evolution of \href{https://wg21.link/P1393}{P1393}'s
property system, especially as it relates to executors.\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright
2020-01-13\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{appendix-a-note-on-coroutines}{%
\subsection{Appendix: A note on
coroutines}\label{appendix-a-note-on-coroutines}}

\href{http://wg21.link/P1341}{P1341} leverages the structural
similarities between coroutines and the sender/receiver abstraction to
give a class of senders a standard-provided
\mintinline[]{text}{operator co_await}. The end result is that a sender,
simply by dint of being a sender, can be
\mintinline[]{text}{co_await}-ed in a coroutine. With the refinement of
sender/receiver that was proposed in
\href{https://wg21.link/P2006}{P2006} --- namely, the splitting of
\mintinline[]{text}{submit} into
\mintinline[]{text}{connect}/\mintinline[]{text}{start} --- that
automatic adaptation from sender-to-awaitable is allocation- and
synchronization-free.

\hypertarget{appendix-the-retry-algorithm}{%
\subsection{\texorpdfstring{Appendix: The \mintinline[]{text}{retry}
Algorithm}{Appendix: The  Algorithm}}\label{appendix-the-retry-algorithm}}

Below is an implementation of a simple \mintinline[]{text}{retry}
algorithm in terms of
\mintinline[]{text}{sender}/\mintinline[]{text}{receiver}. This
algorithm is Generic in the sense that it will retry any multi-shot
asynchronous operation that satisfies the \mintinline[]{text}{sender}
concept. More accurately, it takes any deferred async operation and
wraps it so that when it is executed, it will retry the wrapped
operation until it either succeeds or is cancelled.

Full working code can be found here: \url{https://godbolt.org/z/nm6GmH}

\begin{minted}{cpp}
// _conv needed so we can emplace construct non-movable types into
// a std::optional.
template<invocable F>
    requires std::is_nothrow_move_constructible_v<F>
struct _conv {
    F f_;
    explicit _conv(F f) noexcept : f_((F&&) f) {}
    operator invoke_result_t<F>() && {
        return ((F&&) f_)();
    }
};

// pass through set_value and set_error, but retry the operation
// from set_error.
template<class O, class R>
struct _retry_receiver {
    O* o_;
    explicit _retry_receiver(O* o): o_(o) {}
    template<class... As>
        requires receiver_of<R, As...>
    void set_value(As&&... as) &&
        noexcept(is_nothrow_receiver_of_v<R, As...>) {
        ::set_value(std::move(o_->r_), (As&&) as...);
    }
    void set_error(auto&&) && noexcept {
        o_->_retry(); // This causes the op to be retried
    }
    void set_done() && noexcept {
        ::set_done(std::move(o_->r_));
    }
};

template<sender S>
struct _retry_sender : sender_base {
    S s_;
    explicit _retry_sender(S s): s_((S&&) s) {}

    // Hold the nested operation state in an optional so we can
    // re-construct and re-start it when the operation fails.
    template<receiver R>
    struct _op {
        S s_;
        R r_;
        std::optional<state_t<S&, _retry_receiver<_op, R>>> o_;

        _op(S s, R r): s_((S&&)s), r_((R&&)r), o_{_connect()} {}
        _op(_op&&) = delete;

        auto _connect() noexcept {
            return _conv{[this] {
                return ::connect(s_, _retry_receiver<_op, R>{this});
            }};
        }
        void _retry() noexcept try {
            o_.emplace(_connect()); // potentially throwing
            ::start(std::move(*o_));
        } catch(...) {
            ::set_error((R&&) r_, std::current_exception());
        }
        void start() && noexcept {
            ::start(std::move(*o_));
        }
    };

    template<receiver R>
        requires sender_to<S&, _retry_receiver<_op<R>, R>>
    auto connect(R r) && -> _op<R> {
        return _op<R>{(S&&) s_, (R&&) r};
    }
};

template<sender S>
sender auto retry(S s) {
    return _retry_sender{(S&&)s};
}
\end{minted}

\end{document}
