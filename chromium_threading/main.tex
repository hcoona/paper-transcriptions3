\PassOptionsToPackage{dvipsnames}{xcolor}
\PassOptionsToPackage{unicode=true,colorlinks=true,urlcolor=blue}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\documentclass[a4paper,12pt,notitlepage,twoside,openright]{article}

\usepackage{ifxetex}
\ifxetex{}
\else
\errmessage{Must be built with XeLaTeX}
\fi

\input{../common/fonts.tex}
\input{../common/packages.tex}
\usepackage{endnotes}
\input{../common/setup.tex}

\title{Threading and Tasks in Chrome \\{\footnotesize \url{https://chromium.googlesource.com/chromium/src.git/+/4fd187a77c89105ffaf4ad9b3c28dfa2d1668c08/docs/threading_and_tasks.md}}}
\author{Chromium Project}
\date{Tue Jun 30 06:36:29 2020}

\begin{document}

\maketitle

Note: See \href{threading_and_tasks_faq.md}{Threading and Tasks FAQ} for
more examples.

\hypertarget{overview}{%
\section{Overview}\label{overview}}

Chrome has a
\href{https://www.chromium.org/developers/design-documents/multi-process-architecture}{multi-process
architecture} and each process is heavily multi-threaded. In this
document we will go over the basic threading system shared by each
process. The main goal is to keep the main thread (a.k.a. ``UI'' thread
in the browser process) and IO thread (each process' thread for handling
\href{https://en.wikipedia.org/wiki/Inter-process_communication}{IPC})
responsive. This means offloading any blocking I/O or other expensive
operations to other threads. Our approach is to use message passing as
the way of communicating between threads. We discourage locking and
thread-safe objects. Instead, objects live on only one (often virtual --
we'll get to that later!) thread and we pass messages between those
threads for communication.

This documentation assumes familiarity with computer science
\href{https://en.wikipedia.org/wiki/Thread_(computing)}{threading
concepts}.

\hypertarget{nomenclature}{%
\subsection{Nomenclature}\label{nomenclature}}

\hypertarget{core-concepts}{%
\section{Core Concepts}\label{core-concepts}}

\begin{itemize}
\item
  \textbf{Task}: A unit of work to be processed. Effectively a function
  pointer with optionally associated state. In Chrome this is
  \texttt{base::Callback} created via \texttt{base::Bind}
  (\href{https://chromium.googlesource.com/chromium/src/+/HEAD/docs/callback.md}{documentation}).
\item
  \textbf{Task queue}: A queue of tasks to be processed.
\item
  \textbf{Physical thread}: An operating system provided thread
  (e.g.~pthread on POSIX or CreateThread() on Windows). The Chrome
  cross-platform abstraction is \texttt{base::PlatformThread}. You
  should pretty much never use this directly.
\item
  \textbf{\texttt{base::Thread}}: A physical thread forever processing
  messages from a dedicated task queue until Quit(). You should pretty
  much never be creating your own \texttt{base::Thread}'s.
\item
  \textbf{Thread pool}: A pool of physical threads with a shared task
  queue. In Chrome, this is \texttt{base::ThreadPoolInstance}. There's
  exactly one instance per Chrome process, it serves tasks posted
  through
  \href{https://cs.chromium.org/chromium/src/base/task/post_task.h}{\texttt{base/task/post\_task.h}}
  and as such you should rarely need to use the
  \texttt{base::ThreadPoolInstance} API directly (more on posting tasks
  later).
\item
  \textbf{Sequence} or \textbf{Virtual thread}: A chrome-managed thread
  of execution. Like a physical thread, only one task can run on a given
  sequence / virtual thread at any given moment and each task sees the
  side-effects of the preceding tasks. Tasks are executed sequentially
  but may hop physical threads between each one.
\item
  \textbf{Task runner}: An interface through which tasks can be posted.
  In Chrome this is \texttt{base::TaskRunner}.
\item
  \textbf{Sequenced task runner}: A task runner which guarantees that
  tasks posted to it will run sequentially, in posted order. Each such
  task is guaranteed to see the side-effects of the task preceding it.
  Tasks posted to a sequenced task runner are typically processed by a
  single thread (virtual or physical). In Chrome this is
  \texttt{base::SequencedTaskRunner} which is-a
  \texttt{base::TaskRunner}.
\item
  \textbf{Single-thread task runner}: A sequenced task runner which
  guarantees that all tasks will be processed by the same physical
  thread. In Chrome this is \texttt{base::SingleThreadTaskRunner} which
  is-a \texttt{base::SequencedTaskRunner}. We
  \protect\hyperlink{prefer-sequences-to-physical-threads}{prefer
  sequences to threads} whenever possible.
\end{itemize}

\hypertarget{threading-lexicon}{%
\section{Threading Lexicon}\label{threading-lexicon}}

Note to the reader: the following terms are an attempt to bridge the gap
between common threading nomenclature and the way we use them in Chrome.
It might be a bit heavy if you're just getting started. Should this be
hard to parse, consider skipping to the more detailed sections below and
referring back to this as necessary.

\begin{itemize}
\item
  \textbf{Thread-unsafe}: The vast majority of types in Chrome are
  thread-unsafe (by design). Access to such types/methods must be
  externally synchronized. Typically thread-unsafe types require that
  all tasks accessing their state be posted to the same
  \texttt{base::SequencedTaskRunner} and they verify this in debug
  builds with a \texttt{SEQUENCE\_CHECKER} member. Locks are also an
  option to synchronize access but in Chrome we strongly
  \protect\hyperlink{Using-Sequences-Instead-of-Locks}{prefer sequences
  to locks}.
\item
  \textbf{Thread-affine}: Such types/methods need to be always accessed
  from the same physical thread (i.e.~from the same
  \texttt{base::SingleThreadTaskRunner}) and typically have a
  \texttt{THREAD\_CHECKER} member to verify that they are. Short of
  using a third-party API or having a leaf dependency which is
  thread-affine: there's pretty much no reason for a type to be
  thread-affine in Chrome. Note that
  \texttt{base::SingleThreadTaskRunner} is-a
  \texttt{base::SequencedTaskRunner} so thread-affine is a subset of
  thread-unsafe. Thread-affine is also sometimes referred to as
  \textbf{thread-hostile}.
\item
  \textbf{Thread-safe}: Such types/methods can be safely accessed
  concurrently.
\item
  \textbf{Thread-compatible}: Such types provide safe concurrent access
  to const methods but require synchronization for non-const (or mixed
  const/non-const access). Chrome doesn't expose reader-writer locks; as
  such, the only use case for this is objects (typically globals) which
  are initialized once in a thread-safe manner (either in the
  single-threaded phase of startup or lazily through a thread-safe
  static-local-initialization paradigm a la \texttt{base::NoDestructor})
  and forever after immutable.
\item
  \textbf{Immutable}: A subset of thread-compatible types which cannot
  be modified after construction.
\item
  \textbf{Sequence-friendly}: Such types/methods are thread-unsafe types
  which support being invoked from a \texttt{base::SequencedTaskRunner}.
  Ideally this would be the case for all thread-unsafe types but legacy
  code sometimes has overzealous checks that enforce thread-affinity in
  mere thread-unsafe scenarios. See
  \protect\hyperlink{prefer-sequences-to-physical-threads}{Prefer
  Sequences to Threads} below for more details.
\end{itemize}

\hypertarget{threads}{%
\subsection{Threads}\label{threads}}

Every Chrome process has

\begin{itemize}
\item
  a main thread

  \begin{itemize}
  \item
    in the browser process (BrowserThread::UI): updates the UI
  \item
    in renderer processes (Blink main thread): runs most of Blink
  \end{itemize}
\item
  an IO thread

  \begin{itemize}
  \item
    in the browser process (BrowserThread::IO): handles IPCs and network
    requests
  \item
    in renderer processes: handles IPCs
  \end{itemize}
\item
  a few more special-purpose threads
\item
  and a pool of general-purpose threads
\end{itemize}

Most threads have a loop that gets tasks from a queue and runs them (the
queue may be shared between multiple threads).

\hypertarget{tasks}{%
\subsection{Tasks}\label{tasks}}

A task is a \texttt{base::OnceClosure} added to a queue for asynchronous
execution.

A \texttt{base::OnceClosure} stores a function pointer and arguments. It
has a \texttt{Run()} method that invokes the function pointer using the
bound arguments. It is created using \texttt{base::BindOnce}. (ref.
\href{callback.md}{Callback\textless\textgreater{} and Bind()
documentation}).

\begin{verbatim}
void TaskA() {}
void TaskB(int v) {}

auto task_a = base::BindOnce(&TaskA);
auto task_b = base::BindOnce(&TaskB, 42);
\end{verbatim}

A group of tasks can be executed in one of the following ways:

\begin{itemize}
\item
  \protect\hyperlink{Posting-a-Parallel-Task}{Parallel}: No task
  execution ordering, possibly all at once on any thread
\item
  \protect\hyperlink{Posting-a-Sequenced-Task}{Sequenced}: Tasks
  executed in posting order, one at a time on any thread.
\item
  \protect\hyperlink{Posting-Multiple-Tasks-to-the-Same-Thread}{Single
  Threaded}: Tasks executed in posting order, one at a time on a single
  thread.

  \begin{itemize}
  \item
    \protect\hyperlink{Posting-Tasks-to-a-COM-Single_Thread-Apartment-STA_Thread-Windows}{COM
    Single Threaded}: A variant of single threaded with COM initialized.
  \end{itemize}
\end{itemize}

\hypertarget{prefer-sequences-to-physical-threads}{%
\subsection{Prefer Sequences to Physical
Threads}\label{prefer-sequences-to-physical-threads}}

Sequenced execution (on virtual threads) is strongly preferred to
single-threaded execution (on physical threads). Except for
types/methods bound to the main thread (UI) or IO threads: thread-safety
is better achieved via \texttt{base::SequencedTaskRunner} than through
managing your own physical threads (ref.
\protect\hyperlink{posting-a-sequenced-task}{Posting a Sequenced Task}
below).

All APIs which are exposed for ``current physical thread'' have an
equivalent for ``current sequence''
(\href{threading_and_tasks_faq.md\#How-to-migrate-from-SingleThreadTaskRunner-to-SequencedTaskRunner}{mapping}).

If you find yourself writing a sequence-friendly type and it fails
thread-affinity checks (e.g., \texttt{THREAD\_CHECKER}) in a leaf
dependency: consider making that dependency sequence-friendly as well.
Most core APIs in Chrome are sequence-friendly, but some legacy types
may still over-zealously use
ThreadChecker/ThreadTaskRunnerHandle/SingleThreadTaskRunner when they
could instead rely on the ``current sequence'' and no longer be
thread-affine.

\hypertarget{posting-a-parallel-task}{%
\section{Posting a Parallel Task}\label{posting-a-parallel-task}}

\hypertarget{direct-posting-to-the-thread-pool}{%
\subsection{Direct Posting to the Thread
Pool}\label{direct-posting-to-the-thread-pool}}

A task that can run on any thread and doesn't have ordering or mutual
exclusion requirements with other tasks should be posted using one of
the \texttt{base::ThreadPool::PostTask*()} functions defined in
\href{https://cs.chromium.org/chromium/src/base/task/thread_pool.h}{\texttt{base/task/thread\_pool.h}}.

\begin{minted}{cpp}
base::ThreadPool::PostTask(FROM_HERE, base::BindOnce(&Task));
\end{minted}

This posts tasks with default traits.

The \texttt{base::ThreadPool::PostTask*()} functions allow the caller to
provide additional details about the task via TaskTraits (ref.
\protect\hyperlink{Annotating-Tasks-with-TaskTraits}{Annotating Tasks
with TaskTraits}).

\begin{minted}{cpp}
base::ThreadPool::PostTask(
    FROM_HERE, {base::TaskPriority::BEST_EFFORT, MayBlock()},
    base::BindOnce(&Task));
\end{minted}

\hypertarget{posting-via-a-taskrunner}{%
\subsection{Posting via a
TaskRunner}\label{posting-via-a-taskrunner}}

A parallel
\href{https://cs.chromium.org/chromium/src/base/task_runner.h}{\texttt{base::TaskRunner}}
is an alternative to calling \texttt{base::ThreadPool::PostTask*()}
directly. This is mainly useful when it isn't known in advance whether
tasks will be posted in parallel, in sequence, or to a single-thread
(ref. \protect\hyperlink{Posting-a-Sequenced-Task}{Posting a Sequenced
Task},
\protect\hyperlink{Posting-Multiple-Tasks-to-the-Same-Thread}{Posting
Multiple Tasks to the Same Thread}). Since \texttt{base::TaskRunner} is
the base class of \texttt{base::SequencedTaskRunner} and
\texttt{base::SingleThreadTaskRunner}, a
\texttt{scoped\_refptr\textless{}TaskRunner\textgreater{}} member can
hold a \texttt{base::TaskRunner}, a \texttt{base::SequencedTaskRunner}
or a \texttt{base::SingleThreadTaskRunner}.

\begin{minted}{cpp}
class A {
 public:
  A() = default;

  void PostSomething() {
    task_runner_->PostTask(FROM_HERE, base::BindOnce(&A, &DoSomething));
  }

  void DoSomething() {
  }

 private:
  scoped_refptr<base::TaskRunner> task_runner_ =
      base::ThreadPool::CreateTaskRunner({base::TaskPriority::USER_VISIBLE});
};
\end{minted}

Unless a test needs to control precisely how tasks are executed, it is
preferred to call \texttt{base::ThreadPool::PostTask*()} directly (ref.
\protect\hyperlink{Testing}{Testing} for less invasive ways of
controlling tasks in tests).

\hypertarget{posting-a-sequenced-task}{%
\section{Posting a Sequenced Task}\label{posting-a-sequenced-task}}

A sequence is a set of tasks that run one at a time in posting order
(not necessarily on the same thread). To post tasks as part of a
sequence, use a
\href{https://cs.chromium.org/chromium/src/base/sequenced_task_runner.h}{\texttt{base::SequencedTaskRunner}}.

\hypertarget{posting-to-a-new-sequence}{%
\subsection{Posting to a New
Sequence}\label{posting-to-a-new-sequence}}

A \texttt{base::SequencedTaskRunner} can be created by
\texttt{base::ThreadPool::CreateSequencedTaskRunner()}.

\begin{minted}{cpp}
scoped_refptr<SequencedTaskRunner> sequenced_task_runner =
  base::ThreadPool::CreateSequencedTaskRunner(...);

// TaskB runs after TaskA completes.
sequenced_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskA));
sequenced_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskB));
\end{minted}

\hypertarget{posting-to-the-current-virtual-thread}{%
\subsection{Posting to the Current (Virtual)
Thread}\label{posting-to-the-current-virtual-thread}}

The preferred way of posting to the current (virtual) thread is via
\texttt{base::SequencedTaskRunnerHandle::Get()}.

\begin{minted}{cpp}
// The task will run on the current (virtual) thread's default task queue.
base::SequencedTaskRunnerHandle::Get()->PostTask(
    FROM_HERE, base::BindOnce(&Task);
\end{minted}

Note that \texttt{SequencedTaskRunnerHandle::Get()} returns the default queue for
the current virtual thread. On threads with multiple task queues (e.g.
BrowserThread::UI) this can be a different queue than the one the
current task belongs to. The ``current'' task runner is intentionally
not exposed via a static getter. Either you know it already and can post
to it directly or you don't and the only sensible destination is the
default queue.

\hypertarget{using-sequences-instead-of-locks}{%
\section{Using Sequences Instead of
Locks}\label{using-sequences-instead-of-locks}}

Usage of locks is discouraged in Chrome. Sequences inherently provide
thread-safety. Prefer classes that are always accessed from the same
sequence to managing your own thread-safety with locks.

\textbf{Thread-safe but not thread-affine; how so?} Tasks posted to the
same sequence will run in sequential order. After a sequenced task
completes, the next task may be picked up by a different worker thread,
but that task is guaranteed to see any side-effects caused by the
previous one(s) on its sequence.

\begin{minted}{cpp}
class A {
 public:
  A() {
    // Do not require accesses to be on the creation sequence.
    DETACH_FROM_SEQUENCE(sequence_checker_);
  }

  void AddValue(int v) {
    // Check that all accesses are on the same sequence.
    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
    values_.push_back(v);
}

 private:
  SEQUENCE_CHECKER(sequence_checker_);

  // No lock required, because all accesses are on the
  // same sequence.
  std::vector<int> values_;
};

A a;
scoped_refptr<SequencedTaskRunner> task_runner_for_a = ...;
task_runner_for_a->PostTask(FROM_HERE,
                      base::BindOnce(&A::AddValue, base::Unretained(&a), 42));
task_runner_for_a->PostTask(FROM_HERE,
                      base::BindOnce(&A::AddValue, base::Unretained(&a), 27));

// Access from a different sequence causes a DCHECK failure.
scoped_refptr<SequencedTaskRunner> other_task_runner = ...;
other_task_runner->PostTask(FROM_HERE,
                            base::BindOnce(&A::AddValue, base::Unretained(&a), 1));
\end{minted}

Locks should only be used to swap in a shared data structure that can be
accessed on multiple threads. If one thread updates it based on
expensive computation or through disk access, then that slow work should
be done without holding the lock. Only when the result is available
should the lock be used to swap in the new data. An example of this is
in PluginList::LoadPlugins
(\href{https://cs.chromium.org/chromium/src/content/browser/plugin_list.cc}{\texttt{content/browser/plugin\_list.cc}}.
If you must use locks,
\href{https://www.chromium.org/developers/lock-and-condition-variable}{here}
are some best practices and pitfalls to avoid.

In order to write non-blocking code, many APIs in Chrome are
asynchronous. Usually this means that they either need to be executed on
a particular thread/sequence and will return results via a custom
delegate interface, or they take a
\texttt{base::Callback\textless{}\textgreater{}} object that is called
when the requested operation is completed. Executing work on a specific
thread/sequence is covered in the PostTask sections above.

\hypertarget{posting-multiple-tasks-to-the-same-thread}{%
\section{Posting Multiple Tasks to the Same
Thread}\label{posting-multiple-tasks-to-the-same-thread}}

If multiple tasks need to run on the same thread, post them to a
\href{https://cs.chromium.org/chromium/src/base/single_thread_task_runner.h}{\texttt{base::SingleThreadTaskRunner}}.
All tasks posted to the same \texttt{base::SingleThreadTaskRunner} run
on the same thread in posting order.

\hypertarget{posting-to-the-main-thread-or-to-the-io-thread-in-the-browser-process}{%
\subsection{Posting to the Main Thread or to the IO Thread in the
Browser
Process}\label{posting-to-the-main-thread-or-to-the-io-thread-in-the-browser-process}}

To post tasks to the main thread or to the IO thread, use
\texttt{content::GetUIThreadTaskRunner(\{\})} or
\texttt{content::GetIOThreadTaskRunner(\{\})} from
\href{https://cs.chromium.org/chromium/src/content/public/browser/browser_thread.h}{\texttt{content/public/browser/browser\_thread.h}}

You may provide additional BrowserTaskTraits as a parameter to those
methods though this is generally still uncommon in BrowserThreads and
should be reserved for advanced use cases.

There's an ongoing migration
(\href{https://docs.google.com/document/d/1tssusPykvx3g0gvbvU4HxGyn3MjJlIylnsH13-Tv6s4/edit?ts=5de99a52\#heading=h.ss4tw38hvh3s}{task
APIs v3}) away from the previous base-API-with-traits which you may
still find throughout the codebase (it's equivalent):

\begin{minted}{cpp}
base::PostTask(FROM_HERE, {content::BrowserThread::UI}, ...);

base::CreateSingleThreadTaskRunner({content::BrowserThread::IO})
    ->PostTask(FROM_HERE, ...);
\end{minted}

Note: For the duration of the migration, you'll unfortunately need to
continue manually including
\href{https://cs.chromium.org/chromium/src/content/public/browser/browser_task_traits.h}{\texttt{content/public/browser/browser\_task\_traits.h}}.
to use the browser\_thread.h API.

The main thread and the IO thread are already super busy. Therefore,
prefer posting to a general purpose thread when possible (ref.
\protect\hyperlink{Posting-a-Parallel-Task}{Posting a Parallel Task},
\protect\hyperlink{Posting-a-Sequenced-Task}{Posting a Sequenced task}).
Good reasons to post to the main thread are to update the UI or access
objects that are bound to it (e.g.~\texttt{Profile}). A good reason to
post to the IO thread is to access the internals of components that are
bound to it (e.g.~IPCs, network). Note: It is not necessary to have an
explicit post task to the IO thread to send/receive an IPC or
send/receive data on the network.

\hypertarget{posting-to-the-main-thread-in-a-renderer-process}{%
\subsection{Posting to the Main Thread in a Renderer
Process}\label{posting-to-the-main-thread-in-a-renderer-process}}

TODO(blink-dev)

\hypertarget{posting-to-a-custom-singlethreadtaskrunner}{%
\subsection{Posting to a Custom
SingleThreadTaskRunner}\label{posting-to-a-custom-singlethreadtaskrunner}}

If multiple tasks need to run on the same thread and that thread doesn't
have to be the main thread or the IO thread, post them to a
\texttt{base::SingleThreadTaskRunner} created by
\texttt{base::Threadpool::CreateSingleThreadTaskRunner}.

\begin{minted}{cpp}
scoped_refptr<SingleThreadTaskRunner> single_thread_task_runner =
    base::Threadpool::CreateSingleThreadTaskRunner(...);

// TaskB runs after TaskA completes. Both tasks run on the same thread.
single_thread_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskA));
single_thread_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskB));
\end{minted}

Remember that we
\protect\hyperlink{prefer-sequences-to-physical-threads}{prefer
sequences to physical threads} and that this thus should rarely be
necessary.

\hypertarget{posting-to-the-current-thread}{%
\subsection{Posting to the Current
Thread}\label{posting-to-the-current-thread}}

*** note \textbf{IMPORTANT:} To post a task that needs mutual exclusion
with the current sequence of tasks but doesn't absolutely need to run on
the current physical thread, use
\texttt{base::SequencedTaskRunnerHandle::Get()} instead of
\texttt{base::ThreadTaskRunnerHandle::Get()} (ref.
\protect\hyperlink{Posting-to-the-Current-Virtual_Thread}{Posting to the
Current Sequence}). That will better document the requirements of the
posted task and will avoid unnecessarily making your API physical
thread-affine. In a single-thread task,
\texttt{base::SequencedTaskRunnerHandle::Get()} is equivalent to
\texttt{base::ThreadTaskRunnerHandle::Get()}. ***

If you must post a task to the current physical thread nonetheless, use
\href{https://cs.chromium.org/chromium/src/base/threading/thread_task_runner_handle.h}{\texttt{base::ThreadTaskRunnerHandle}}.

\begin{minted}{cpp}
// The task will run on the current thread in the future.
base::ThreadTaskRunnerHandle::Get()->PostTask(
    FROM_HERE, base::BindOnce(&Task));
\end{minted}

\hypertarget{posting-tasks-to-a-com-single-thread-apartment-sta-thread-windows}{%
\section{Posting Tasks to a COM Single-Thread Apartment (STA) Thread
(Windows)}\label{posting-tasks-to-a-com-single-thread-apartment-sta-thread-windows}}

Tasks that need to run on a COM Single-Thread Apartment (STA) thread
must be posted to a \texttt{base::SingleThreadTaskRunner} returned by
\texttt{base::ThreadPool::CreateCOMSTATaskRunner()}. As mentioned in
\protect\hyperlink{Posting-Multiple-Tasks-to-the-Same-Thread}{Posting
Multiple Tasks to the Same Thread}, all tasks posted to the same
\texttt{base::SingleThreadTaskRunner} run on the same thread in posting
order.

\begin{minted}{cpp}
// Task(A|B|C)UsingCOMSTA will run on the same COM STA thread.

void TaskAUsingCOMSTA() {
  // [ This runs on a COM STA thread. ]

  // Make COM STA calls.
  // ...

  // Post another task to the current COM STA thread.
  base::ThreadTaskRunnerHandle::Get()->PostTask(
      FROM_HERE, base::BindOnce(&TaskCUsingCOMSTA));
}
void TaskBUsingCOMSTA() { }
void TaskCUsingCOMSTA() { }

auto com_sta_task_runner = base::ThreadPool::CreateCOMSTATaskRunner(...);
com_sta_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskAUsingCOMSTA));
com_sta_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskBUsingCOMSTA));
\end{minted}

\hypertarget{annotating-tasks-with-tasktraits}{%
\section{Annotating Tasks with
TaskTraits}\label{annotating-tasks-with-tasktraits}}

\href{https://cs.chromium.org/chromium/src/base/task/task_traits.h}{\texttt{base::TaskTraits}}
encapsulate information about a task that helps the thread pool make
better scheduling decisions.

Methods that take \texttt{base::TaskTraits} can be be passed
\texttt{\{\}} when default traits are sufficient. Default traits are
appropriate for tasks that:

\begin{enumerate}
  \item Don't block (ref. MayBlock and WithBaseSyncPrimitives);
  \item Pertain to user-blocking activity;
  (explicitly or implicitly by having an ordering dependency with a
  component that does)
  \item Can either block shutdown or be skipped on
  shutdown (thread pool is free to choose a fitting default). Tasks that
  don't match this description must be posted with explicit TaskTraits.
\end{enumerate}

\href{https://cs.chromium.org/chromium/src/base/task/task_traits.h}{\texttt{base/task/task\_traits.h}}
provides exhaustive documentation of available traits. The content layer
also provides additional traits in
\href{https://cs.chromium.org/chromium/src/content/public/browser/browser_task_traits.h}{\texttt{content/public/browser/browser\_task\_traits.h}}
to facilitate posting a task onto a BrowserThread.

Below are some examples of how to specify \texttt{base::TaskTraits}.

\begin{minted}{cpp}
// This task has no explicit TaskTraits. It cannot block. Its priority is
// USER_BLOCKING. It will either block shutdown or be skipped on shutdown.
base::ThreadPool::PostTask(FROM_HERE, base::BindOnce(...));

// This task has the highest priority. The thread pool will schedule it before
// USER_VISIBLE and BEST_EFFORT tasks.
base::ThreadPool::PostTask(
    FROM_HERE, {base::TaskPriority::USER_BLOCKING},
    base::BindOnce(...));

// This task has the lowest priority and is allowed to block (e.g. it
// can read a file from disk).
base::ThreadPool::PostTask(
    FROM_HERE, {base::TaskPriority::BEST_EFFORT, base::MayBlock()},
    base::BindOnce(...));

// This task blocks shutdown. The process won't exit before its
// execution is complete.
base::ThreadPool::PostTask(
    FROM_HERE, {base::TaskShutdownBehavior::BLOCK_SHUTDOWN},
    base::BindOnce(...));
\end{minted}

\hypertarget{keeping-the-browser-responsive}{%
\section{Keeping the Browser
Responsive}\label{keeping-the-browser-responsive}}

Do not perform expensive work on the main thread, the IO thread or any
sequence that is expected to run tasks with a low latency. Instead,
perform expensive work asynchronously using
\texttt{base::ThreadPool::PostTaskAndReply*()} or
\texttt{base::SequencedTaskRunner::PostTaskAndReply()}. Note that
asynchronous/overlapped I/O on the IO thread are fine.

Example: Running the code below on the main thread will prevent the
browser from responding to user input for a long time.

\begin{minted}{cpp}
// GetHistoryItemsFromDisk() may block for a long time.
// AddHistoryItemsToOmniboxDropDown() updates the UI and therefore must
// be called on the main thread.
AddHistoryItemsToOmniboxDropdown(GetHistoryItemsFromDisk("keyword"));
\end{minted}

The code below solves the problem by scheduling a call to
\texttt{GetHistoryItemsFromDisk()} in a thread pool followed by a call
to \texttt{AddHistoryItemsToOmniboxDropdown()} on the origin sequence
(the main thread in this case). The return value of the first call is
automatically provided as argument to the second call.

\begin{minted}{cpp}
base::ThreadPool::PostTaskAndReplyWithResult(
    FROM_HERE, {base::MayBlock()},
    base::BindOnce(&GetHistoryItemsFromDisk, "keyword"),
    base::BindOnce(&AddHistoryItemsToOmniboxDropdown));
\end{minted}

\hypertarget{posting-a-task-with-a-delay}{%
\section{Posting a Task with a
Delay}\label{posting-a-task-with-a-delay}}

\hypertarget{posting-a-one-off-task-with-a-delay}{%
\subsection{Posting a One-Off Task with a
Delay}\label{posting-a-one-off-task-with-a-delay}}

To post a task that must run once after a delay expires, use
\texttt{base::ThreadPool::PostDelayedTask*()} or
\texttt{base::TaskRunner::PostDelayedTask()}.

\begin{minted}{cpp}
base::ThreadPool::PostDelayedTask(
  FROM_HERE, {base::TaskPriority::BEST_EFFORT}, base::BindOnce(&Task),
  base::TimeDelta::FromHours(1));

scoped_refptr<base::SequencedTaskRunner> task_runner =
    base::ThreadPool::CreateSequencedTaskRunner(
        {base::TaskPriority::BEST_EFFORT});
task_runner->PostDelayedTask(
    FROM_HERE, base::BindOnce(&Task), base::TimeDelta::FromHours(1));
\end{minted}

*** note \textbf{NOTE:} A task that has a 1-hour delay probably doesn't
have to run right away when its delay expires. Specify
\texttt{base::TaskPriority::BEST\_EFFORT} to prevent it from slowing
down the browser when its delay expires. ***

\hypertarget{posting-a-repeating-task-with-a-delay}{%
\subsection{Posting a Repeating Task with a
Delay}\label{posting-a-repeating-task-with-a-delay}}

To post a task that must run at regular intervals, use
\href{https://cs.chromium.org/chromium/src/base/timer/timer.h}{\texttt{base::RepeatingTimer}}.

\begin{minted}{cpp}
class A {
 public:
  ~A() {
    // The timer is stopped automatically when it is deleted.
  }
  void StartDoingStuff() {
    timer_.Start(FROM_HERE, TimeDelta::FromSeconds(1),
                 this, &MyClass::DoStuff);
  }
  void StopDoingStuff() {
    timer_.Stop();
  }
 private:
  void DoStuff() {
    // This method is called every second on the sequence that invoked
    // StartDoingStuff().
  }
  base::RepeatingTimer timer_;
};
\end{minted}

\hypertarget{cancelling-a-task}{%
\section{Cancelling a Task}\label{cancelling-a-task}}

\hypertarget{using-baseweakptr}{%
\subsection{Using base::WeakPtr}\label{using-baseweakptr}}

\href{https://cs.chromium.org/chromium/src/base/memory/weak_ptr.h}{\texttt{base::WeakPtr}}
can be used to ensure that any callback bound to an object is canceled
when that object is destroyed.

\begin{minted}{cpp}
int Compute() { … }

class A {
 public:
  void ComputeAndStore() {
    // Schedule a call to Compute() in a thread pool followed by
    // a call to A::Store() on the current sequence. The call to
    // A::Store() is canceled when |weak_ptr_factory_| is destroyed.
    // (guarantees that |this| will not be used-after-free).
    base::ThreadPool::PostTaskAndReplyWithResult(
        FROM_HERE, base::BindOnce(&Compute),
        base::BindOnce(&A::Store, weak_ptr_factory_.GetWeakPtr()));
  }

 private:
  void Store(int value) { value_ = value; }

  int value_;
  base::WeakPtrFactory<A> weak_ptr_factory_{this};
};
\end{minted}

Note: \texttt{WeakPtr} is not thread-safe: \texttt{GetWeakPtr()},
\texttt{\textasciitilde{}WeakPtrFactory()}, and \texttt{Compute()}
(bound to a \texttt{WeakPtr}) must all run on the same sequence.

\hypertarget{using-basecancelabletasktracker}{%
\subsection{Using
base::CancelableTaskTracker}\label{using-basecancelabletasktracker}}

\href{https://cs.chromium.org/chromium/src/base/task/cancelable_task_tracker.h}{\texttt{base::CancelableTaskTracker}}
allows cancellation to happen on a different sequence than the one on
which tasks run. Keep in mind that \texttt{CancelableTaskTracker} cannot
cancel tasks that have already started to run.

\begin{minted}{cpp}
auto task_runner = base::ThreadPool::CreateTaskRunner({});
base::CancelableTaskTracker cancelable_task_tracker;
cancelable_task_tracker.PostTask(task_runner.get(), FROM_HERE,
                                 base::DoNothing());
// Cancels Task(), only if it hasn't already started running.
cancelable_task_tracker.TryCancelAll();
\end{minted}

\hypertarget{posting-a-job-to-run-in-parallel}{%
\section{Posting a Job to run in
parallel}\label{posting-a-job-to-run-in-parallel}}

The
\href{https://cs.chromium.org/chromium/src/base/task/post_job.h}{\texttt{base::PostJob}}
is a power user API to be able to schedule a single
base::RepeatingCallback worker task and request that ThreadPool workers
invoke it concurrently. This avoids degenerate cases:

\begin{enumerate}
  \item Calling
  \texttt{PostTask()} for each work item, causing significant overhead.
  \item Fixed number of \texttt{PostTask()} calls that split the work and might
  run for a long time. This is problematic when many components post ``num
  cores'' tasks and all expect to use all the cores. In these cases, the
  scheduler lacks context to be fair to multiple same-priority requests
  and/or ability to request lower priority work to yield when high
  priority work comes in.
\end{enumerate}

See
\href{https://cs.chromium.org/chromium/src/base/task/job_perftest.cc}{\texttt{base/task/job\_perftest.cc}}
for a complete example.

\begin{minted}{cpp}
// A canonical implementation of |worker_task|.
void WorkerTask(base::JobDelegate* job_delegate) {
  while (!job_delegate->ShouldYield()) {
    auto work_item = TakeWorkItem(); // Smallest unit of work.
    if (!work_item)
      return:
    ProcessWork(work_item);
  }
}

// Returns the latest thread-safe number of incomplete work items.
void NumIncompleteWorkItems();

base::PostJob(FROM_HERE, {},
              base::BindRepeating(&WorkerTask),
              base::BindRepeating(&NumIncompleteWorkItems));
\end{minted}

By doing as much work as possible in a loop when invoked, the worker
task avoids scheduling overhead. Meanwhile
\texttt{base::JobDelegate::ShouldYield()} is periodically invoked to
conditionally exit and let the scheduler prioritize other work. This
yield-semantic allows, for example, a user-visible job to use all cores
but get out of the way when a user-blocking task comes in.

\hypertarget{adding-additional-work-to-a-running-job.}{%
\subsection{Adding additional work to a running
job.}\label{adding-additional-work-to-a-running-job.}}

When new work items are added and the API user wants additional threads
to invoke the worker task concurrently,
\texttt{JobHandle/JobDelegate::NotifyConcurrencyIncrease()} \emph{must}
be invoked shortly after max concurrency increases.

\hypertarget{testing}{%
\section{Testing}\label{testing}}

For more details see \href{threading_and_tasks_testing.md}{Testing
Components Which Post Tasks}.

To test code that uses \texttt{base::ThreadTaskRunnerHandle},
\texttt{base::SequencedTaskRunnerHandle} or a function in
\href{https://cs.chromium.org/chromium/src/base/task/post_task.h}{\texttt{base/task/post\_task.h}},
instantiate a
\href{https://cs.chromium.org/chromium/src/base/test/task_environment.h}{\texttt{base::test::TaskEnvironment}}
for the scope of the test. If you need BrowserThreads, use
\texttt{content::BrowserTaskEnvironment} instead of
\texttt{base::test::TaskEnvironment}.

Tests can run the \texttt{base::test::TaskEnvironment}'s message pump
using a \texttt{base::RunLoop}, which can be made to run until
\texttt{Quit()} (explicitly or via \texttt{RunLoop::QuitClosure()}), or
to \texttt{RunUntilIdle()} ready-to-run tasks and immediately return.

TaskEnvironment configures RunLoop::Run() to GTEST\_FAIL() if it hasn't
been explicitly quit after TestTimeouts::action\_timeout(). This is
preferable to having the test hang if the code under test fails to
trigger the RunLoop to quit. The timeout can be overridden with
base::test::ScopedRunLoopTimeout.

\begin{minted}{cpp}
class MyTest : public testing::Test {
 public:
  // ...
 protected:
   base::test::TaskEnvironment task_environment_;
};

TEST(MyTest, MyTest) {
  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, base::BindOnce(&A));
  base::SequencedTaskRunnerHandle::Get()->PostTask(FROM_HERE,
                                                   base::BindOnce(&B));
  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
      FROM_HERE, base::BindOnce(&C), base::TimeDelta::Max());

  // This runs the (Thread|Sequenced)TaskRunnerHandle queue until it is empty.
  // Delayed tasks are not added to the queue until they are ripe for execution.
  base::RunLoop().RunUntilIdle();
  // A and B have been executed. C is not ripe for execution yet.

  base::RunLoop run_loop;
  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, base::BindOnce(&D));
  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, run_loop.QuitClosure());
  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, base::BindOnce(&E));

  // This runs the (Thread|Sequenced)TaskRunnerHandle queue until QuitClosure is
  // invoked.
  run_loop.Run();
  // D and run_loop.QuitClosure() have been executed. E is still in the queue.

  // Tasks posted to thread pool run asynchronously as they are posted.
  base::ThreadPool::PostTask(FROM_HERE, {}, base::BindOnce(&F));
  auto task_runner =
      base::ThreadPool::CreateSequencedTaskRunner({});
  task_runner->PostTask(FROM_HERE, base::BindOnce(&G));

  // To block until all tasks posted to thread pool are done running:
  base::ThreadPoolInstance::Get()->FlushForTesting();
  // F and G have been executed.

  base::ThreadPool::PostTaskAndReplyWithResult(
      FROM_HERE, {}, base::BindOnce(&H), base::BindOnce(&I));

  // This runs the (Thread|Sequenced)TaskRunnerHandle queue until both the
  // (Thread|Sequenced)TaskRunnerHandle queue and the TaskSchedule queue are
  // empty:
  task_environment_.RunUntilIdle();
  // E, H, I have been executed.
}
\end{minted}

\hypertarget{using-threadpool-in-a-new-process}{%
\section{Using ThreadPool in a New
Process}\label{using-threadpool-in-a-new-process}}

ThreadPoolInstance needs to be initialized in a process before the
functions in
\href{https://cs.chromium.org/chromium/src/base/task/post_task.h}{\texttt{base/task/post\_task.h}}
can be used. Initialization of ThreadPoolInstance in the Chrome browser
process and child processes (renderer, GPU, utility) has already been
taken care of. To use ThreadPoolInstance in another process, initialize
ThreadPoolInstance early in the main function:

\begin{minted}{cpp}
// This initializes and starts ThreadPoolInstance with default params.
base::ThreadPoolInstance::CreateAndStartWithDefaultParams(“process_name”);
// The base/task/post_task.h API can now be used with base::ThreadPool trait.
// Tasks will be // scheduled as they are posted.

// This initializes ThreadPoolInstance.
base::ThreadPoolInstance::Create(“process_name”);
// The base/task/post_task.h API can now be used with base::ThreadPool trait. No
// threads will be created and no tasks will be scheduled until after Start() is
// called.
base::ThreadPoolInstance::Get()->Start(params);
// ThreadPool can now create threads and schedule tasks.
\end{minted}

And shutdown ThreadPoolInstance late in the main function:

\begin{minted}{cpp}
base::ThreadPoolInstance::Get()->Shutdown();
// Tasks posted with TaskShutdownBehavior::BLOCK_SHUTDOWN and
// tasks posted with TaskShutdownBehavior::SKIP_ON_SHUTDOWN that
// have started to run before the Shutdown() call have now completed their
// execution. Tasks posted with
// TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN may still be
// running.
\end{minted}

\hypertarget{taskrunner-ownership-encourage-no-dependency-injection}{%
\section{TaskRunner ownership (encourage no dependency
injection)}\label{taskrunner-ownership-encourage-no-dependency-injection}}

TaskRunners shouldn't be passed through several components. Instead, the
components that uses a TaskRunner should be the one that creates it.

See \href{https://codereview.chromium.org/2885173002/}{this example} of
a refactoring where a TaskRunner was passed through a lot of components
only to be used in an eventual leaf. The leaf can and should now obtain
its TaskRunner directly from
\href{https://cs.chromium.org/chromium/src/base/task/post_task.h}{\texttt{base/task/post\_task.h}}.

As mentioned above, \texttt{base::test::TaskEnvironment} allows unit
tests to control tasks posted from underlying TaskRunners. In rare cases
where a test needs to more precisely control task ordering: dependency
injection of TaskRunners can be useful. For such cases the preferred
approach is the following:

\begin{minted}{cpp}
class Foo {
 public:

  // Overrides |background_task_runner_| in tests.
  void SetBackgroundTaskRunnerForTesting(
      scoped_refptr<base::SequencedTaskRunner> background_task_runner) {
    background_task_runner_ = std::move(background_task_runner);
  }

 private:
  scoped_refptr<base::SequencedTaskRunner> background_task_runner_ =
      base::ThreadPool::CreateSequencedTaskRunner(
          {base::MayBlock(), base::TaskPriority::BEST_EFFORT});
}
\end{minted}

Note that this still allows removing all layers of plumbing between
//chrome and that component since unit tests will use the leaf layer
directly.

\hypertarget{faq}{%
\section{FAQ}\label{faq}}

See \href{threading_and_tasks_faq.md}{Threading and Tasks FAQ} for more
examples.

\hypertarget{internals}{%
\section{Internals}\label{internals}}

\hypertarget{sequencemanager}{%
\subsection{SequenceManager}\label{sequencemanager}}

\href{https://cs.chromium.org/chromium/src/base/task/sequence_manager/sequence_manager.h}{SequenceManager}
manages TaskQueues which have different properties (e.g.~priority,
common task type) multiplexing all posted tasks into a single backing
sequence. This will usually be a MessagePump. Depending on the type of
message pump used other events such as UI messages may be processed as
well. On Windows APC calls (as time permits) and signals sent to a
registered set of HANDLEs may also be processed.

\subsubsection{MessagePump}

\href{https://cs.chromium.org/chromium/src/base/message_loop/message_pump.h}{MessagePumps}
are responsible for processing native messages as well as for giving
cycles to their delegate (SequenceManager) periodically. MessagePumps
take care to mixing delegate callbacks with native message processing so
neither type of event starves the other of cycles.

There are different
\href{https://cs.chromium.org/chromium/src/base/message_loop/message_pump_type.h}{MessagePumpTypes},
most common are:

\begin{itemize}
\item
  DEFAULT: Supports tasks and timers only
\item
  UI: Supports native UI events (e.g.~Windows messages)
\item
  IO: Supports asynchronous IO (not file I/O!)
\item
  CUSTOM: User provided implementation of MessagePump interface
\end{itemize}

\subsubsection{RunLoop}

RunLoop is s helper class to run the RunLoop::Delegate associated with
the current thread (usually a SequenceManager). Create a RunLoop on the
stack and call Run/Quit to run a nested RunLoop but please avoid nested
loops in production code!

\subsubsection{Task Reentrancy}

SequenceManager has task reentrancy protection. This means that if a
task is being processed, a second task cannot start until the first task
is finished. Reentrancy can happen when processing a task, and an inner
message pump is created. That inner pump then processes native messages
which could implicitly start an inner task. Inner message pumps are
created with dialogs (DialogBox), common dialogs (GetOpenFileName), OLE
functions (DoDragDrop), printer functions (StartDoc) and \emph{many}
others.

\begin{minted}{cpp}
Sample workaround when inner task processing is needed:
  HRESULT hr;
  {
    MessageLoopCurrent::ScopedNestableTaskAllower allow;
    hr = DoDragDrop(...); // Implicitly runs a modal message loop.
  }
  // Process |hr| (the result returned by DoDragDrop()).
\end{minted}

Please be SURE your task is reentrant (nestable) and all global
variables are stable and accessible before before using
MessageLoopCurrent::ScopedNestableTaskAllower.

\hypertarget{apis-for-general-use}{%
\section{APIs for general use}\label{apis-for-general-use}}

User code should hardly ever need to access SequenceManager APIs
directly as these are meant for code that deals with scheduling. Instead
you should use the following:

\begin{itemize}
\item
  base::RunLoop: Drive the SequenceManager from the thread it's bound
  to.
\item
  base::Thread/SequencedTaskRunnerHandle: Post back to the
  SequenceManager TaskQueues from a task running on it.
\item
  SequenceLocalStorageSlot : Bind external state to a sequence.
\item
  base::MessageLoopCurrent : Proxy to a subset of Task related APIs
  bound to the current thread
\item
  Embedders may provide their own static accessors to post tasks on
  specific loops (e.g.~content::BrowserThreads).
\end{itemize}

\hypertarget{singlethreadtaskexecutor-and-taskenvironment}{%
\subsection{SingleThreadTaskExecutor and
TaskEnvironment}\label{singlethreadtaskexecutor-and-taskenvironment}}

Instead of having to deal with SequenceManager and TaskQueues code that
needs a simple task posting environment (one default task queue) can use
a
\href{https://cs.chromium.org/chromium/src/base/task/single_thread_task_executor.h}{SingleThreadTaskExecutor}.

Unit tests can use
\href{https://cs.chromium.org/chromium/src/base/test/task_environment.h}{TaskEnvironment}
which is highly configurable.

\end{document}
