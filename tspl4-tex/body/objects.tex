\chapter{Operations on Objects\label{objects_CHPTOBJECTS}}
\label{objects_g106}
\label{objects_h0}
\begin{figure}[H]
\centering
\setlength{\fboxrule}{3pt}
\fbox{
\includegraphics[width=0.9\textwidth]{canned/ch6.png}
\begin{rotate}{90}
\copyright~2009 Jean-Pierre H\'{e}bert
\end{rotate}}
\end{figure}
\clearpage





This chapter describes the \label{objects_s0}operations on objects, including lists,
numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations.
The first section covers constant objects and quotation.
The second section describes generic equivalence predicates for
comparing two objects and predicates for determining the type
of an object.
Later sections describe procedures that deal primarily with one of
the object types mentioned above.
There is no section treating operations on procedures, since the only
operation defined specifically for procedures is application, and this
is described in Chapter \ref{control_g96}.
Operations on ports are covered in the more general discussion of
input and output in Chapter \ref{io_g121}.
A mechanism for defining new data types is described in
Chapter \ref{records_g138}.


\section{\label{objects_g107}\label{objects_h1}Constants and Quotation\label{objects_SECTQUOTING}}


\begin{description}

\label{objects_s1}\item[syntax] \texttt{\textit{constant}}



\item[returns] \texttt{\textit{constant}}
\end{description}

\texttt{\textit{constant}} is any self-evaluating constant, i.e., a number,
boolean, character, string, or bytevector.
Constants are immutable; see the note in the description of
\texttt{quote} below.

\begin{alltt}
3.2 \(\Rightarrow\) 3.2
\#{}f \(\Rightarrow\) \#{}f
\#{}\textbackslash{}c \(\Rightarrow\) \#{}\textbackslash{}c
"hi" \(\Rightarrow\) "hi"
\#{}vu8(3 4 5) \(\Rightarrow\) \#{}vu8(3 4 5)
\end{alltt}

\begin{description}

\label{objects_s2}\item[syntax] \texttt{(quote \textit{obj})}



\item[syntax] \texttt{'\textit{obj}}



\item[returns] \texttt{\textit{obj}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{'\textit{obj}} is equivalent to \texttt{(quote \textit{obj})}.
The abbreviated form is converted into the longer form by the Scheme
reader (see \texttt{read}).
\texttt{quote} inhibits the normal evaluation rule for
\texttt{\textit{obj}}, allowing \texttt{\textit{obj}} to be employed as \label{objects_s3}data.
Although any Scheme object may be quoted, quotation is not necessary
for self-evaluating \label{objects_s4}constants, i.e., numbers, booleans,
characters, strings, and bytevectors.

Quoted and self-evaluating constants are immutable.
That is, programs should not alter a constant via \texttt{set-car!},
\texttt{string-set!}, etc., and implementations are permitted to raise
an exception with condition type \texttt{\&{}assertion} if such an
alteration is attempted.
If an attempt to alter an immutable object is undetected, the behavior of
the program is unspecified.
An implementation may choose to share storage among different
constants to save space.


\begin{alltt}
(+ 2 3) \(\Rightarrow\) 5
'(+ 2 3) \(\Rightarrow\) (+ 2 3)
(quote (+ 2 3)) \(\Rightarrow\) (+ 2 3)
'a \(\Rightarrow\) a
'cons \(\Rightarrow\) cons
'() \(\Rightarrow\) ()
'7 \(\Rightarrow\) 7
\end{alltt}

\begin{description}

\label{objects_s5}\item[syntax] \texttt{(quasiquote \textit{obj} ...)}



\item[syntax] \texttt{`\textit{obj}}



\item[syntax] \texttt{(unquote \textit{obj} ...)}



\item[syntax] \texttt{,\textit{obj}}



\item[syntax] \texttt{(unquote-splicing \textit{obj} ...)}



\item[syntax] \texttt{,\@{}\textit{obj}}



\item[returns] see below
 

\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{`\textit{obj}} is equivalent to \texttt{(quasiquote \textit{obj})},
\texttt{,\textit{obj}} is equivalent to \texttt{(unquote \textit{obj})}, and
\texttt{,\@{}\textit{obj}} is equivalent to \texttt{(unquote-splicing \textit{obj})}.
The abbreviated forms are converted into the longer forms by the
Scheme reader (see \texttt{read}).
\texttt{quasiquote} is similar to \texttt{quote}, but it allows parts
of the quoted text to be ``unquoted.''
Within a \texttt{quasiquote} expression,
\texttt{unquote} and \texttt{unquote-splicing} subforms are evaluated,
and everything else is quoted, i.e., left unevaluated.
The value of each \texttt{unquote} subform is inserted into the output
in place of the \texttt{unquote} form, while the value of each
\texttt{unquote-splicing} subform is spliced into the surrounding list
or vector structure.
\texttt{unquote} and \texttt{unquote-splicing} are valid only within
\texttt{quasiquote} expressions.
\texttt{quasiquote} expressions may be nested, with each \texttt{quasiquote}
introducing a new level of quotation and each \texttt{unquote} or
\texttt{unquote-splicing} taking away a level of quotation.
An expression nested within \textit{n} \texttt{quasiquote} expressions must
be within \textit{n} \texttt{unquote} or \texttt{unquote-splicing} expressions to
be evaluated.

\begin{alltt}
`(+ 2 3) \(\Rightarrow\) (+ 2 3)

`(+ 2 ,(* 3 4)) \(\Rightarrow\) (+ 2 12)
`(a b (,(+ 2 3) c) d) \(\Rightarrow\) (a b (5 c) d)
`(a b ,(reverse '(c d e)) f g) \(\Rightarrow\) (a b (e d c) f g)
(let ([a 1] [b 2])
  `(,a . ,b)) \(\Rightarrow\) (1 . 2)

`(+ ,\@{}(cdr '(* 2 3))) \(\Rightarrow\) (+ 2 3)
`(a b ,\@{}(reverse '(c d e)) f g) \(\Rightarrow\) (a b e d c f g)
(let ([a 1] [b 2])
  `(,a ,\@{}b)) \(\Rightarrow\) (1 . 2)
`\#{}(,\@{}(list 1 2 3)) \(\Rightarrow\) \#{}(1 2 3)

'`,(cons 'a 'b) \(\Rightarrow\) `,(cons 'a 'b)
`',(cons 'a 'b) \(\Rightarrow\) '(a . b)
\end{alltt}

\texttt{unquote} and \texttt{unquote-splicing} forms with zero or more than
one subform are valid only in splicing (list or
vector) contexts.
\texttt{(unquote \textit{obj} ...)} is equivalent to
\texttt{(unquote \textit{obj}) ...}, and
\texttt{(unquote-splicing \textit{obj} ...)} is equivalent to
\texttt{(unquote-splicing \textit{obj}) ...}.
These forms are primarily useful as intermediate forms in the output
of the \texttt{quasiquote} expander.
They support certain useful nested quasiquotation
idioms [\hyperref[bibliography_g221]{3}], such as \texttt{,\@{},\@{}}, which has the
effect of a doubly indirect splicing when used within a doubly nested
and doubly evaluated \texttt{quasiquote} expression.

\begin{alltt}
`(a (unquote) b) \(\Rightarrow\) (a b)
`(a (unquote (+ 3 3)) b) \(\Rightarrow\) (a 6 b)
`(a (unquote (+ 3 3) (* 3 3)) b) \(\Rightarrow\) (a 6 9 b)

(let ([x '(m n)]) "(a ,\@{},\@{}x f)) \(\Rightarrow\) `(a (unquote-splicing m n) f)
(let ([x '(m n)])
  (eval `(let ([m '(b c)] [n '(d e)]) `(a ,\@{},\@{}x f))
        (environment '(rnrs)))) \(\Rightarrow\) (a b c d e f)
\end{alltt}

\texttt{unquote} and \texttt{unquote-splicing} are auxiliary keywords for
\texttt{quasiquote}.
It is a syntax violation to reference these identifiers except in contexts
where they are recognized as auxiliary keywords.


\section{\label{objects_g108}\label{objects_h2}Generic Equivalence and Type Predicates\label{objects_SECTGENERIC}}



This section describes the basic Scheme \label{objects_s6}predicates (procedures
returning one of the boolean values \label{objects_s7}\texttt{\#{}t} or \label{objects_s8}\texttt{\#{}f}) for
determining the type of an object or the equivalence of two objects.
The \label{objects_s9}equivalence predicates \texttt{eq?}, \texttt{eqv?}, and \texttt{equal?}
are discussed first, followed by the type predicates.

\begin{description}

\label{objects_s10}\item[procedure] \texttt{(eq? \textit{obj\textsubscript{1}} \textit{obj\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj\textsubscript{1}}} and \texttt{\textit{obj\textsubscript{2}}} are identical, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


In most Scheme systems, two objects are considered identical if they
are represented internally by the same pointer value and distinct
(not identical) if they are represented internally by different pointer
values, although other criteria, such as time-stamping, are possible.


Although the particular rules for \label{objects_s11}object identity
vary somewhat from system to system, the following rules always hold.

\begin{itemize}
\item 
Two objects of different types
(booleans, the empty list, pairs, numbers, characters, strings,
vectors, symbols, and procedures)
are distinct.

\item 
Two objects of the same type with different contents or values are distinct.

\item 
The boolean object \texttt{\#{}t} is identical to itself wherever it
appears, and \texttt{\#{}f} is identical to itself wherever it appears,
but \texttt{\#{}t} and \texttt{\#{}f} are distinct.

\item 
The empty list \texttt{()} is identical to itself wherever it appears.

\item 
Two symbols are identical if and only if they have the same name (by
\texttt{string=?}).

\item 
A constant pair, vector, string, or bytevector is identical to itself, as is a
pair, vector, string, or bytevector created by an application of \texttt{cons},
\texttt{vector}, \texttt{string}, \texttt{make-bytevector}, etc.
Two pairs, vectors, strings, or bytevectors created by different applications
of \texttt{cons}, \texttt{vector}, \texttt{string}, \texttt{make-bytevector},
etc., are distinct.
One consequence is that \texttt{cons}, for example, may be used to create
a unique object distinct from all other objects.

\item 
Two procedures that may behave differently are distinct.
A procedure created by an evaluation of a
\texttt{lambda} expression is identical to itself.
Two procedures created by the same \texttt{lambda} expression at different
times, or by similar \texttt{lambda} expressions, may or may not be
distinct.

\end{itemize}

\texttt{eq?} cannot be used to compare numbers and characters
reliably.
Although every inexact number is distinct from every exact number,
two exact numbers, two inexact numbers, or two characters with the
same value may or may not be identical.

Since constant objects are immutable, i.e., programs should not modify them via
\texttt{vector-set!}, \texttt{set-car!}, or any other structure mutation
operation,
all or portions of different quoted constants or self-evaluating
literals may be represented internally by the same object.
Thus, \texttt{eq?} may return \texttt{\#{}t} when applied to equal parts of different
immutable constants.

\texttt{eq?} is most often used to compare symbols or to check for
pointer equivalence of allocated objects, e.g., pairs, vectors,
or record instances.

\begin{alltt}
(eq? 'a 3) \(\Rightarrow\) \#{}f
(eq? \#{}t 't) \(\Rightarrow\) \#{}f
(eq? "abc" 'abc) \(\Rightarrow\) \#{}f
(eq? "hi" '(hi)) \(\Rightarrow\) \#{}f
(eq? \#{}f '()) \(\Rightarrow\) \#{}f

(eq? 9/2 7/2) \(\Rightarrow\) \#{}f
(eq? 3.4 53344) \(\Rightarrow\) \#{}f
(eq? 3 3.0) \(\Rightarrow\) \#{}f
(eq? 1/3 \#{}i1/3) \(\Rightarrow\) \#{}f

(eq? 9/2 9/2) \(\Rightarrow\) \textit{unspecified}
(eq? 3.4 (+ 3.0 .4)) \(\Rightarrow\) \textit{unspecified}
(let ([x (* 12345678987654321 2)])
  (eq? x x)) \(\Rightarrow\) \textit{unspecified}

(eq? \#{}\textbackslash{}a \#{}\textbackslash{}b) \(\Rightarrow\) \#{}f
(eq? \#{}\textbackslash{}a \#{}\textbackslash{}a) \(\Rightarrow\) \textit{unspecified}
(let ([x (string-ref "hi" 0)])
  (eq? x x)) \(\Rightarrow\) \textit{unspecified}

(eq? \#{}t \#{}t) \(\Rightarrow\) \#{}t
(eq? \#{}f \#{}f) \(\Rightarrow\) \#{}t
(eq? \#{}t \#{}f) \(\Rightarrow\) \#{}f
(eq? (null? '()) \#{}t) \(\Rightarrow\) \#{}t
(eq? (null? '(a)) \#{}f) \(\Rightarrow\) \#{}t

(eq? (cdr '(a)) '()) \(\Rightarrow\) \#{}t

(eq? 'a 'a) \(\Rightarrow\) \#{}t
(eq? 'a 'b) \(\Rightarrow\) \#{}f
(eq? 'a (string-\textgreater{}symbol "a")) \(\Rightarrow\) \#{}t

(eq? '(a) '(b)) \(\Rightarrow\) \#{}f
(eq? '(a) '(a)) \(\Rightarrow\) \textit{unspecified}
(let ([x '(a . b)]) (eq? x x)) \(\Rightarrow\) \#{}t
(let ([x (cons 'a 'b)])
  (eq? x x)) \(\Rightarrow\) \#{}t
(eq? (cons 'a 'b) (cons 'a 'b)) \(\Rightarrow\) \#{}f

(eq? "abc" "cba") \(\Rightarrow\) \#{}f
(eq? "abc" "abc") \(\Rightarrow\) \textit{unspecified}
(let ([x "hi"]) (eq? x x)) \(\Rightarrow\) \#{}t
(let ([x (string \#{}\textbackslash{}h \#{}\textbackslash{}i)]) (eq? x x)) \(\Rightarrow\) \#{}t
(eq? (string \#{}\textbackslash{}h \#{}\textbackslash{}i)
     (string \#{}\textbackslash{}h \#{}\textbackslash{}i)) \(\Rightarrow\) \#{}f

(eq? '\#{}vu8(1) '\#{}vu8(1)) \(\Rightarrow\) \textit{unspecified}
(eq? '\#{}vu8(1) '\#{}vu8(2)) \(\Rightarrow\) \#{}f
(let ([x (make-bytevector 10 0)])
  (eq? x x)) \(\Rightarrow\) \#{}t
(let ([x (make-bytevector 10 0)])
  (eq? x (make-bytevector 10 0))) \(\Rightarrow\) \#{}f

(eq? '\#{}(a) '\#{}(b)) \(\Rightarrow\) \#{}f
(eq? '\#{}(a) '\#{}(a)) \(\Rightarrow\) \textit{unspecified}
(let ([x '\#{}(a)]) (eq? x x)) \(\Rightarrow\) \#{}t
(let ([x (vector 'a)])
  (eq? x x)) \(\Rightarrow\) \#{}t
(eq? (vector 'a) (vector 'a)) \(\Rightarrow\) \#{}f

(eq? car car) \(\Rightarrow\) \#{}t
(eq? car cdr) \(\Rightarrow\) \#{}f
(let ([f (lambda (x) x)])
  (eq? f f)) \(\Rightarrow\) \#{}t
(let ([f (lambda () (lambda (x) x))])
  (eq? (f) (f))) \(\Rightarrow\) \textit{unspecified}
(eq? (lambda (x) x) (lambda (y) y)) \(\Rightarrow\) \textit{unspecified}

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (eq? (f 0) (f 0))) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s12}\item[procedure] \texttt{(eqv? \textit{obj\textsubscript{1}} \textit{obj\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj\textsubscript{1}}} and \texttt{\textit{obj\textsubscript{2}}} are equivalent, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{eqv?} is similar to \texttt{eq?} except \texttt{eqv?}
is guaranteed to return \texttt{\#{}t} for two characters that are considered
equal by \texttt{char=?} and two numbers that are (a) considered
equal by \texttt{=} and (b) cannot be distinguished by any other
operation besides \texttt{eq?} and \texttt{eqv?}.
A consequence of (b) is that \texttt{(eqv? -0.0 +0.0)} is \texttt{\#{}f} even
though \texttt{(= -0.0 +0.0)} is \texttt{\#{}t} in systems that distinguish
\texttt{-0.0} and \texttt{+0.0}, such as those based on IEEE floating-point
arithmetic.
This is because operations such as \texttt{/} can expose the difference:

\begin{alltt}
(/ 1.0 -0.0) \(\Rightarrow\) -inf.0
(/ 1.0 +0.0) \(\Rightarrow\) +inf.0
\end{alltt}


Similarly, although 3.0 and 3.0+0.0i are considered numerically equal,
they are not considered equivalent by \texttt{eqv?} if -0.0 and
0.0 have different representations.


\begin{alltt}
(= 3.0+0.0i 3.0) \(\Rightarrow\) \#{}t
(eqv? 3.0+0.0i 3.0) \(\Rightarrow\) \#{}f
\end{alltt}


The boolean value returned by \texttt{eqv?} is not specified when the
arguments are NaNs.


\texttt{(eqv? +nan.0 (/ 0.0 0.0)) \(\Rightarrow\) \textit{unspecified}}
\texttt{eqv?} is less implementation-dependent but generally more
expensive than \texttt{eq?}.

\begin{alltt}
(eqv? 'a 3) \(\Rightarrow\) \#{}f
(eqv? \#{}t 't) \(\Rightarrow\) \#{}f
(eqv? "abc" 'abc) \(\Rightarrow\) \#{}f
(eqv? "hi" '(hi)) \(\Rightarrow\) \#{}f
(eqv? \#{}f '()) \(\Rightarrow\) \#{}f

(eqv? 9/2 7/2) \(\Rightarrow\) \#{}f
(eqv? 3.4 53344) \(\Rightarrow\) \#{}f
(eqv? 3 3.0) \(\Rightarrow\) \#{}f
(eqv? 1/3 \#{}i1/3) \(\Rightarrow\) \#{}f

(eqv? 9/2 9/2) \(\Rightarrow\) \#{}t
(eqv? 3.4 (+ 3.0 .4)) \(\Rightarrow\) \#{}t
(let ([x (* 12345678987654321 2)])
  (eqv? x x)) \(\Rightarrow\) \#{}t

(eqv? \#{}\textbackslash{}a \#{}\textbackslash{}b) \(\Rightarrow\) \#{}f
(eqv? \#{}\textbackslash{}a \#{}\textbackslash{}a) \(\Rightarrow\) \#{}t
(let ([x (string-ref "hi" 0)])
  (eqv? x x)) \(\Rightarrow\) \#{}t

(eqv? \#{}t \#{}t) \(\Rightarrow\) \#{}t
(eqv? \#{}f \#{}f) \(\Rightarrow\) \#{}t
(eqv? \#{}t \#{}f) \(\Rightarrow\) \#{}f
(eqv? (null? '()) \#{}t) \(\Rightarrow\) \#{}t
(eqv? (null? '(a)) \#{}f) \(\Rightarrow\) \#{}t

(eqv? (cdr '(a)) '()) \(\Rightarrow\) \#{}t

(eqv? 'a 'a) \(\Rightarrow\) \#{}t
(eqv? 'a 'b) \(\Rightarrow\) \#{}f
(eqv? 'a (string-\textgreater{}symbol "a")) \(\Rightarrow\) \#{}t

(eqv? '(a) '(b)) \(\Rightarrow\) \#{}f
(eqv? '(a) '(a)) \(\Rightarrow\) \textit{unspecified}
(let ([x '(a . b)]) (eqv? x x)) \(\Rightarrow\) \#{}t
(let ([x (cons 'a 'b)])
  (eqv? x x)) \(\Rightarrow\) \#{}t
(eqv? (cons 'a 'b) (cons 'a 'b)) \(\Rightarrow\) \#{}f

(eqv? "abc" "cba") \(\Rightarrow\) \#{}f
(eqv? "abc" "abc") \(\Rightarrow\) \textit{unspecified}
(let ([x "hi"]) (eqv? x x)) \(\Rightarrow\) \#{}t
(let ([x (string \#{}\textbackslash{}h \#{}\textbackslash{}i)]) (eqv? x x)) \(\Rightarrow\) \#{}t
(eqv? (string \#{}\textbackslash{}h \#{}\textbackslash{}i)
      (string \#{}\textbackslash{}h \#{}\textbackslash{}i)) \(\Rightarrow\) \#{}f

(eqv? '\#{}vu8(1) '\#{}vu8(1)) \(\Rightarrow\) \textit{unspecified}
(eqv? '\#{}vu8(1) '\#{}vu8(2)) \(\Rightarrow\) \#{}f
(let ([x (make-bytevector 10 0)])
  (eqv? x x)) \(\Rightarrow\) \#{}t
(let ([x (make-bytevector 10 0)])
  (eqv? x (make-bytevector 10 0))) \(\Rightarrow\) \#{}f

(eqv? '\#{}(a) '\#{}(b)) \(\Rightarrow\) \#{}f
(eqv? '\#{}(a) '\#{}(a)) \(\Rightarrow\) \textit{unspecified}
(let ([x '\#{}(a)]) (eqv? x x)) \(\Rightarrow\) \#{}t
(let ([x (vector 'a)])
  (eqv? x x)) \(\Rightarrow\) \#{}t
(eqv? (vector 'a) (vector 'a)) \(\Rightarrow\) \#{}f

(eqv? car car) \(\Rightarrow\) \#{}t
(eqv? car cdr) \(\Rightarrow\) \#{}f
(let ([f (lambda (x) x)])
  (eqv? f f)) \(\Rightarrow\) \#{}t
(let ([f (lambda () (lambda (x) x))])
  (eqv? (f) (f))) \(\Rightarrow\) \textit{unspecified}
(eqv? (lambda (x) x) (lambda (y) y)) \(\Rightarrow\) \textit{unspecified}

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (eqv? (f 0) (f 0))) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s13}\item[procedure] \texttt{(equal? \textit{obj\textsubscript{1}} \textit{obj\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj\textsubscript{1}}} and \texttt{\textit{obj\textsubscript{2}}} have the same
structure and contents, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


Two objects are equal if they are equivalent according to \texttt{eqv?},
strings that are \texttt{string=?}, bytevectors that are \texttt{bytevector=?},
pairs whose cars and cdrs are equal, or
vectors of the same length whose corresponding elements are equal.

\texttt{equal?} is required to terminate even for cyclic arguments and
return \texttt{\#{}t} "if and only if the (possibly infinite) unfoldings of
its arguments into regular trees are equal as ordered trees" [\hyperref[bibliography_g242]{24}].
In essence, two values are equivalent, in the sense of \texttt{equal?},
if the structure of the two objects cannot be distinguished by any
composition of pair and vector accessors along with the
\texttt{eqv?}, \texttt{string=?}, and \texttt{bytevector=?} procedures for
comparing data at the leaves.

Implementing \texttt{equal?} efficiently is tricky [\hyperref[bibliography_g219]{1}], and
even with a good implementation, it is likely to be more expensive than
either \texttt{eqv?} or \texttt{eq?}.


\begin{alltt}
(equal? 'a 3) \(\Rightarrow\) \#{}f
(equal? \#{}t 't) \(\Rightarrow\) \#{}f
(equal? "abc" 'abc) \(\Rightarrow\) \#{}f
(equal? "hi" '(hi)) \(\Rightarrow\) \#{}f
(equal? \#{}f '()) \(\Rightarrow\) \#{}f

(equal? 9/2 7/2) \(\Rightarrow\) \#{}f
(equal? 3.4 53344) \(\Rightarrow\) \#{}f
(equal? 3 3.0) \(\Rightarrow\) \#{}f
(equal? 1/3 \#{}i1/3) \(\Rightarrow\) \#{}f

(equal? 9/2 9/2) \(\Rightarrow\) \#{}t
(equal? 3.4 (+ 3.0 .4)) \(\Rightarrow\) \#{}t
(let ([x (* 12345678987654321 2)])
  (equal? x x)) \(\Rightarrow\) \#{}t

(equal? \#{}\textbackslash{}a \#{}\textbackslash{}b) \(\Rightarrow\) \#{}f
(equal? \#{}\textbackslash{}a \#{}\textbackslash{}a) \(\Rightarrow\) \#{}t
(let ([x (string-ref "hi" 0)])
  (equal? x x)) \(\Rightarrow\) \#{}t

(equal? \#{}t \#{}t) \(\Rightarrow\) \#{}t
(equal? \#{}f \#{}f) \(\Rightarrow\) \#{}t
(equal? \#{}t \#{}f) \(\Rightarrow\) \#{}f
(equal? (null? '()) \#{}t) \(\Rightarrow\) \#{}t
(equal? (null? '(a)) \#{}f) \(\Rightarrow\) \#{}t

(equal? (cdr '(a)) '()) \(\Rightarrow\) \#{}t

(equal? 'a 'a) \(\Rightarrow\) \#{}t
(equal? 'a 'b) \(\Rightarrow\) \#{}f
(equal? 'a (string-\textgreater{}symbol "a")) \(\Rightarrow\) \#{}t

(equal? '(a) '(b)) \(\Rightarrow\) \#{}f
(equal? '(a) '(a)) \(\Rightarrow\) \#{}t
(let ([x '(a . b)]) (equal? x x)) \(\Rightarrow\) \#{}t
(let ([x (cons 'a 'b)])
  (equal? x x)) \(\Rightarrow\) \#{}t
(equal? (cons 'a 'b) (cons 'a 'b)) \(\Rightarrow\) \#{}t

(equal? "abc" "cba") \(\Rightarrow\) \#{}f
(equal? "abc" "abc") \(\Rightarrow\) \#{}t
(let ([x "hi"]) (equal? x x)) \(\Rightarrow\) \#{}t
(let ([x (string \#{}\textbackslash{}h \#{}\textbackslash{}i)]) (equal? x x)) \(\Rightarrow\) \#{}t
(equal? (string \#{}\textbackslash{}h \#{}\textbackslash{}i)
        (string \#{}\textbackslash{}h \#{}\textbackslash{}i)) \(\Rightarrow\) \#{}t

(equal? '\#{}vu8(1) '\#{}vu8(1)) \(\Rightarrow\) \#{}t
(equal? '\#{}vu8(1) '\#{}vu8(2)) \(\Rightarrow\) \#{}f
(let ([x (make-bytevector 10 0)])
  (equal? x x)) \(\Rightarrow\) \#{}t
(let ([x (make-bytevector 10 0)])
  (equal? x (make-bytevector 10 0))) \(\Rightarrow\) \#{}t

(equal? '\#{}(a) '\#{}(b)) \(\Rightarrow\) \#{}f
(equal? '\#{}(a) '\#{}(a)) \(\Rightarrow\) \#{}t
(let ([x '\#{}(a)]) (equal? x x)) \(\Rightarrow\) \#{}t
(let ([x (vector 'a)])
  (equal? x x)) \(\Rightarrow\) \#{}t
(equal? (vector 'a) (vector 'a)) \(\Rightarrow\) \#{}t

(equal? car car) \(\Rightarrow\) \#{}t
(equal? car cdr) \(\Rightarrow\) \#{}f
(let ([f (lambda (x) x)])
  (equal? f f)) \(\Rightarrow\) \#{}t
(let ([f (lambda () (lambda (x) x))])
  (equal? (f) (f))) \(\Rightarrow\) \textit{unspecified}
(equal? (lambda (x) x) (lambda (y) y)) \(\Rightarrow\) \textit{unspecified}

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (equal? (f 0) (f 0))) \(\Rightarrow\) \#{}f

(equal?
  (let ([x (cons 'x 'x)])
    (set-car! x x)
    (set-cdr! x x)
    x)
  (let ([x (cons 'x 'x)])
    (set-car! x x)
    (set-cdr! x x)
    (cons x x))) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s14}\item[procedure] \texttt{(boolean? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is either \texttt{\#{}t} or \texttt{\#{}f}, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{boolean?} is equivalent to
\texttt{(lambda (x) (or (eq? x \#{}t) (eq? x \#{}f)))}.

\begin{alltt}
(boolean? \#{}t) \(\Rightarrow\) \#{}t
(boolean? \#{}f) \(\Rightarrow\) \#{}t
(or (boolean? 't) (boolean? '())) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s15}\item[procedure] \texttt{(null? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is the empty list, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{null?} is equivalent to \texttt{(lambda (x) (eq? x '()))}.

\begin{alltt}
(null? '()) \(\Rightarrow\) \#{}t
(null? '(a)) \(\Rightarrow\) \#{}f
(null? (cdr '(a))) \(\Rightarrow\) \#{}t
(null? 3) \(\Rightarrow\) \#{}f
(null? \#{}f) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s16}\item[procedure] \texttt{(pair? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a pair, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(pair? '(a b c)) \(\Rightarrow\) \#{}t
(pair? '(3 . 4)) \(\Rightarrow\) \#{}t
(pair? '()) \(\Rightarrow\) \#{}f
(pair? '\#{}(a b)) \(\Rightarrow\) \#{}f
(pair? 3) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s17}\item[procedure] \texttt{(number? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a number object, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(complex? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a complex number object, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(real? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a real number object, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(rational? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a rational number object, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(integer? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is an integer object, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


These predicates form a hierarchy: any integer is rational, any
rational is real, any real is complex, and any complex is numeric.
Most implementations do not provide internal representations for
irrational numbers, so all real numbers are typically rational
as well.


The \texttt{real?}, \texttt{rational?}, and \texttt{integer?} predicates do
not recognize as real, rational, or integer complex numbers with inexact
zero imaginary parts.


\begin{alltt}
(integer? 1901) \(\Rightarrow\) \#{}t
(rational? 1901) \(\Rightarrow\) \#{}t
(real? 1901) \(\Rightarrow\) \#{}t
(complex? 1901) \(\Rightarrow\) \#{}t
(number? 1901) \(\Rightarrow\) \#{}t

(integer? -3.0) \(\Rightarrow\) \#{}t
(rational? -3.0) \(\Rightarrow\) \#{}t
(real? -3.0) \(\Rightarrow\) \#{}t
(complex? -3.0) \(\Rightarrow\) \#{}t
(number? -3.0) \(\Rightarrow\) \#{}t

(integer? 7+0i) \(\Rightarrow\) \#{}t
(rational? 7+0i) \(\Rightarrow\) \#{}t
(real? 7+0i) \(\Rightarrow\) \#{}t
(complex? 7+0i) \(\Rightarrow\) \#{}t
(number? 7+0i) \(\Rightarrow\) \#{}t

(integer? -2/3) \(\Rightarrow\) \#{}f
(rational? -2/3) \(\Rightarrow\) \#{}t
(real? -2/3) \(\Rightarrow\) \#{}t
(complex? -2/3) \(\Rightarrow\) \#{}t
(number? -2/3) \(\Rightarrow\) \#{}t

(integer? -2.345) \(\Rightarrow\) \#{}f
(rational? -2.345) \(\Rightarrow\) \#{}t
(real? -2.345) \(\Rightarrow\) \#{}t
(complex? -2.345) \(\Rightarrow\) \#{}t
(number? -2.345) \(\Rightarrow\) \#{}t

(integer? 7.0+0.0i) \(\Rightarrow\) \#{}f
(rational? 7.0+0.0i) \(\Rightarrow\) \#{}f
(real? 7.0+0.0i) \(\Rightarrow\) \#{}f
(complex? 7.0+0.0i) \(\Rightarrow\) \#{}t
(number? 7.0+0.0i) \(\Rightarrow\) \#{}t

(integer? 3.2-2.01i) \(\Rightarrow\) \#{}f
(rational? 3.2-2.01i) \(\Rightarrow\) \#{}f
(real? 3.2-2.01i) \(\Rightarrow\) \#{}f
(complex? 3.2-2.01i) \(\Rightarrow\) \#{}t
(number? 3.2-2.01i) \(\Rightarrow\) \#{}t

(integer? 'a) \(\Rightarrow\) \#{}f
(rational? '(a b c)) \(\Rightarrow\) \#{}f
(real? "3") \(\Rightarrow\) \#{}f
(complex? '\#{}(1 2)) \(\Rightarrow\) \#{}f
(number? \#{}\textbackslash{}a) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s18}\item[procedure] \texttt{(real-valued? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a real number, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(rational-valued? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a rational number, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(integer-valued? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is an integer, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


These predicates are similar to \texttt{real?}, \texttt{rational?}, and
\texttt{integer?}, but treat as real, rational, or integral complex numbers
with inexact zero imaginary parts.


\begin{alltt}
(integer-valued? 1901) \(\Rightarrow\) \#{}t
(rational-valued? 1901) \(\Rightarrow\) \#{}t
(real-valued? 1901) \(\Rightarrow\) \#{}t

(integer-valued? -3.0) \(\Rightarrow\) \#{}t
(rational-valued? -3.0) \(\Rightarrow\) \#{}t
(real-valued? -3.0) \(\Rightarrow\) \#{}t

(integer-valued? 7+0i) \(\Rightarrow\) \#{}t
(rational-valued? 7+0i) \(\Rightarrow\) \#{}t
(real-valued? 7+0i) \(\Rightarrow\) \#{}t

(integer-valued? -2/3) \(\Rightarrow\) \#{}f
(rational-valued? -2/3) \(\Rightarrow\) \#{}t
(real-valued? -2/3) \(\Rightarrow\) \#{}t

(integer-valued? -2.345) \(\Rightarrow\) \#{}f
(rational-valued? -2.345) \(\Rightarrow\) \#{}t
(real-valued? -2.345) \(\Rightarrow\) \#{}t

(integer-valued? 7.0+0.0i) \(\Rightarrow\) \#{}t
(rational-valued? 7.0+0.0i) \(\Rightarrow\) \#{}t
(real-valued? 7.0+0.0i) \(\Rightarrow\) \#{}t

(integer-valued? 3.2-2.01i) \(\Rightarrow\) \#{}f
(rational-valued? 3.2-2.01i) \(\Rightarrow\) \#{}f
(real-valued? 3.2-2.01i) \(\Rightarrow\) \#{}f
\end{alltt}


As with \texttt{real?}, \texttt{rational?}, and \texttt{integer?}, these
predicates return \texttt{\#{}f} for all non-numeric values.


\begin{alltt}
(integer-valued? 'a) \(\Rightarrow\) \#{}f
(rational-valued? '(a b c)) \(\Rightarrow\) \#{}f
(real-valued? "3") \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s19}\item[procedure] \texttt{(char? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a character, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(char? 'a) \(\Rightarrow\) \#{}f
(char? 97) \(\Rightarrow\) \#{}f
(char? \#{}\textbackslash{}a) \(\Rightarrow\) \#{}t
(char? "a") \(\Rightarrow\) \#{}f
(char? (string-ref (make-string 1) 0)) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s20}\item[procedure] \texttt{(string? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a string, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(string? "hi") \(\Rightarrow\) \#{}t
(string? 'hi) \(\Rightarrow\) \#{}f
(string? \#{}\textbackslash{}h) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s21}\item[procedure] \texttt{(vector? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a vector, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(vector? '\#{}()) \(\Rightarrow\) \#{}t
(vector? '\#{}(a b c)) \(\Rightarrow\) \#{}t
(vector? (vector 'a 'b 'c)) \(\Rightarrow\) \#{}t
(vector? '()) \(\Rightarrow\) \#{}f
(vector? '(a b c)) \(\Rightarrow\) \#{}f
(vector? "abc") \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s22}\item[procedure] \texttt{(symbol? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a symbol, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(symbol? 't) \(\Rightarrow\) \#{}t
(symbol? "t") \(\Rightarrow\) \#{}f
(symbol? '(t)) \(\Rightarrow\) \#{}f
(symbol? \#{}\textbackslash{}t) \(\Rightarrow\) \#{}f
(symbol? 3) \(\Rightarrow\) \#{}f
(symbol? \#{}t) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s23}\item[procedure] \texttt{(procedure? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a procedure, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(procedure? car) \(\Rightarrow\) \#{}t
(procedure? 'car) \(\Rightarrow\) \#{}f
(procedure? (lambda (x) x)) \(\Rightarrow\) \#{}t
(procedure? '(lambda (x) x)) \(\Rightarrow\) \#{}f
(call/cc procedure?) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s24}\item[procedure] \texttt{(bytevector? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a bytevector, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(bytevector? \#{}vu8()) \(\Rightarrow\) \#{}t
(bytevector? '\#{}()) \(\Rightarrow\) \#{}f
(bytevector? "abc") \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s25}\item[procedure] \texttt{(hashtable? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a hashtable, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(hashtable? (make-eq-hashtable)) \(\Rightarrow\) \#{}t
(hashtable? '(not a hash table)) \(\Rightarrow\) \#{}f
\end{alltt}

\section{\label{objects_g109}\label{objects_h3}Lists and Pairs\label{objects_SECTPAIRS}}



\label{objects_s26}The pair, or \label{objects_s27}\textit{cons cell}, is the most fundamental of Scheme's
structured object types.
The most common use for pairs is to build \label{objects_s28}lists, which are
ordered sequences of pairs linked one to the next by the
\label{objects_s29}\textit{cdr} field.
The elements of the list occupy the \label{objects_s30}\textit{car}
fields of the pairs.
The cdr of the last pair in a \label{objects_s31}\textit{proper list} is
the empty list, \texttt{()}; the cdr of the last pair in an
\label{objects_s32}\textit{improper list} can be anything other than
\texttt{()}.


Pairs may be used to construct \label{objects_s33}binary trees.
Each pair in the tree structure is an internal node of the binary tree;
its car and cdr are the children of the node.


Proper lists are printed as sequences of objects separated by whitespace
and enclosed in parentheses.
Matching pairs of \label{objects_s34}brackets
( \texttt{[} \texttt{]} ) may be used in place of parentheses.
For example, \texttt{(1 2 3)} and \texttt{(a [nested list])} are proper lists.
The empty list is written as \texttt{()}.


Improper lists and trees require a slightly more complex syntax.
A single pair is written as two objects separated by whitespace and a dot,
e.g., \texttt{(a . b)}.
\label{objects_s35}This is referred to as \textit{dotted-pair notation}.
Improper lists and trees are also written in dotted-pair notation; the dot
appears wherever necessary, e.g., \texttt{(1 2 3 . 4)} or \texttt{((1 . 2) . 3)}.
Proper lists may be written in dotted-pair notation as well.
For example, \texttt{(1 2 3)} may be written as \texttt{(1 . (2 . (3 . ())))}.


\label{objects_s36}It is possible to create a circular list or a cyclic
graph by destructively
altering the car or cdr field of a pair, using \texttt{set-car!} or \texttt{set-cdr!}.
Such lists are not considered proper lists.


Procedures that accept a \texttt{\textit{list}} argument
are required to detect that the list is improper only to the extent that they
actually traverse the list far enough either (a) to attempt to operate on a
non-list tail or (b) to loop indefinitely due to a circularity.
For example, \texttt{member} need not detect that a list is improper if it
actually finds the element being sought, and \texttt{list-ref} need never
detect circularities, because its recursion is bounded by the index
argument.

\begin{description}

\label{objects_s37}\item[procedure] \texttt{(cons \textit{obj\textsubscript{1}} \textit{obj\textsubscript{2}})}



\item[returns] a new pair whose car and cdr are \texttt{\textit{obj\textsubscript{1}}} and \texttt{\textit{obj\textsubscript{2}}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{cons} is the pair constructor procedure.
\texttt{\textit{obj\textsubscript{1}}} becomes the car and \texttt{\textit{obj\textsubscript{2}}} becomes the cdr of the
new pair.

\begin{alltt}
(cons 'a '()) \(\Rightarrow\) (a)
(cons 'a '(b c)) \(\Rightarrow\) (a b c)
(cons 3 4) \(\Rightarrow\) (3 . 4)
\end{alltt}

\begin{description}

\label{objects_s38}\item[procedure] \texttt{(car \textit{pair})}



\item[returns] the car of \texttt{\textit{pair}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The empty list is not a pair, so the argument must not be the empty list.


\begin{alltt}
(car '(a)) \(\Rightarrow\) a
(car '(a b c)) \(\Rightarrow\) a
(car (cons 3 4)) \(\Rightarrow\) 3
\end{alltt}

\begin{description}

\label{objects_s39}\item[procedure] \texttt{(cdr \textit{pair})}



\item[returns] the cdr of \texttt{\textit{pair}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The empty list is not a pair, so the argument must not be the empty list.


\begin{alltt}
(cdr '(a)) \(\Rightarrow\) ()
(cdr '(a b c)) \(\Rightarrow\) (b c)
(cdr (cons 3 4)) \(\Rightarrow\) 4
\end{alltt}

\begin{description}

\label{objects_s40}\item[procedure] \texttt{(set-car! \textit{pair} \textit{obj})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs mutable-pairs)}
\end{description}

\texttt{set-car!} changes the car of \texttt{\textit{pair}} to \texttt{\textit{obj}}.

\begin{alltt}
(let ([x (list 'a 'b 'c)])
  (set-car! x 1)
  x) \(\Rightarrow\) (1 b c)
\end{alltt}

\begin{description}

\label{objects_s41}\item[procedure] \texttt{(set-cdr! \textit{pair} \textit{obj})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs mutable-pairs)}
\end{description}

\texttt{set-cdr!} changes the cdr of \texttt{\textit{pair}} to \texttt{\textit{obj}}.

\begin{alltt}
(let ([x (list 'a 'b 'c)])
  (set-cdr! x 1)
  x) \(\Rightarrow\) (a . 1)
\end{alltt}

\begin{description}

\label{objects_s42}\item[procedure] \texttt{(caar \textit{pair})}



\item[procedure] \texttt{(cadr \textit{pair})}

\(\vdots\) 

\item[procedure] \texttt{(cddddr \textit{pair})}



\item[returns] the caar, cadr, ..., or cddddr of \texttt{\textit{pair}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


These procedures are defined as the composition of up to four \texttt{car}s
and \texttt{cdr}s.
The \texttt{a}'s and \texttt{d}'s between the \texttt{c} and \texttt{r} represent the
application of \texttt{car} or \texttt{cdr} in order from right to left.
For example, the procedure \texttt{cadr} applied to a pair yields the \texttt{car}
of the \texttt{cdr} of the pair and is equivalent to
\texttt{(lambda (x) (car (cdr x)))}.


\begin{alltt}
(caar '((a))) \(\Rightarrow\) a
(cadr '(a b c)) \(\Rightarrow\) b
(cdddr '(a b c d)) \(\Rightarrow\) (d)
(cadadr '(a (b c))) \(\Rightarrow\) c
\end{alltt}

\begin{description}

\label{objects_s43}\item[procedure] \texttt{(list \textit{obj} ...)}



\item[returns] a list of \texttt{\textit{obj} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{list} is equivalent to \texttt{(lambda x x)}.

\begin{alltt}
(list) \(\Rightarrow\) ()
(list 1 2 3) \(\Rightarrow\) (1 2 3)
(list 3 2 1) \(\Rightarrow\) (3 2 1)
\end{alltt}

\begin{description}

\label{objects_s44}\item[procedure] \texttt{(cons* \textit{obj} ... \textit{final-obj})}



\item[returns] a list of \texttt{\textit{obj} ...} terminated by \texttt{\textit{final-obj}}


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}


If the objects \texttt{\textit{obj} ...} are omitted, the result is simply
\texttt{\textit{final-obj}}.
Otherwise, a list of \texttt{\textit{obj} ...} is constructed, as with \texttt{list}, except
that the final cdr field is \texttt{\textit{final-obj}} instead of \texttt{()}.
If \texttt{\textit{final-obj}} is not a list, the result is an improper list.


\begin{alltt}
(cons* '()) \(\Rightarrow\) ()
(cons* '(a b)) \(\Rightarrow\) (a b)
(cons* 'a 'b 'c) \(\Rightarrow\) (a b . c)
(cons* 'a 'b '(c d)) \(\Rightarrow\) (a b c d)
\end{alltt}

\begin{description}

\label{objects_s45}\item[procedure] \texttt{(list? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a proper list, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{list?} must return \texttt{\#{}f} for all improper lists, including cyclic
lists.
A definition of \texttt{list?} is shown on page \pageref{further_defn_list_}.

\begin{alltt}
(list? '()) \(\Rightarrow\) \#{}t
(list? '(a b c)) \(\Rightarrow\) \#{}t
(list? 'a) \(\Rightarrow\) \#{}f
(list? '(3 . 4)) \(\Rightarrow\) \#{}f
(list? 3) \(\Rightarrow\) \#{}f
(let ([x (list 'a 'b 'c)])
  (set-cdr! (cddr x) x)
  (list? x)) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s46}\item[procedure] \texttt{(length \textit{list})}



\item[returns] the number of elements in \texttt{\textit{list}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{length} may be defined as follows, using an adaptation of the
hare and tortoise algorithm used for the definition of \texttt{list?}
on page \pageref{further_defn_list_}.

\begin{alltt}
(define length
  (lambda (x)
    (define improper-list
      (lambda ()
        (assertion-violation 'length "not a proper list" x)))

    (let f ([h x] [t x] [n 0])
      (if (pair? h)
          (let ([h (cdr h)])
            (if (pair? h)
                (if (eq? h t)
                    (improper-list)
                    (f (cdr h) (cdr t) (+ n 2)))
                (if (null? h)
                    (+ n 1)
                    (improper-list))))
          (if (null? h)
              n
              (improper-list))))))

(length '()) \(\Rightarrow\) 0
(length '(a b c)) \(\Rightarrow\) 3
(length '(a b . c)) \(\Rightarrow\) \textit{exception}
(length
  (let ([ls (list 'a 'b)])
    (set-cdr! (cdr ls) ls) \(\Rightarrow\) \textit{exception}
    ls))
(length
  (let ([ls (list 'a 'b)])
    (set-car! (cdr ls) ls) \(\Rightarrow\) 2
    ls))
\end{alltt}

\begin{description}

\label{objects_s47}\item[procedure] \texttt{(list-ref \textit{list} \textit{n})}



\item[returns] the \texttt{\textit{n}}th element (zero-based) of \texttt{\textit{list}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{list}}.
\texttt{list-ref} may be defined without error checks as follows.

\begin{alltt}
(define list-ref\label{objects_defn_list_ref}
  (lambda (ls n)
    (if (= n 0)
        (car ls)
        (list-ref (cdr ls) (- n 1)))))

(list-ref '(a b c) 0) \(\Rightarrow\) a
(list-ref '(a b c) 1) \(\Rightarrow\) b
(list-ref '(a b c) 2) \(\Rightarrow\) c
\end{alltt}

\begin{description}

\label{objects_s48}\item[procedure] \texttt{(list-tail \textit{list} \textit{n})}



\item[returns] the \texttt{\textit{n}}th tail (zero-based) of \texttt{\textit{list}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than or equal to
the length of \texttt{\textit{list}}.
The result is not a copy; the tail is \texttt{eq?} to the \texttt{\textit{n}}th cdr of
\texttt{\textit{list}} (or to \texttt{\textit{list}} itself, if \texttt{\textit{n}} is zero).
\texttt{list-tail} may be defined without error checks as follows.

\begin{alltt}
(define list-tail\label{objects_defn_list_tail}
  (lambda (ls n)
    (if (= n 0)
        ls
        (list-tail (cdr ls) (- n 1)))))

(list-tail '(a b c) 0) \(\Rightarrow\) (a b c)
(list-tail '(a b c) 2) \(\Rightarrow\) (c)
(list-tail '(a b c) 3) \(\Rightarrow\) ()
(list-tail '(a b c . d) 2) \(\Rightarrow\) (c . d)
(list-tail '(a b c . d) 3) \(\Rightarrow\) d
(let ([x (list 1 2 3)])
  (eq? (list-tail x 2)
       (cddr x))) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s49}\item[procedure] \texttt{(append)}



\item[procedure] \texttt{(append \textit{list} ... \textit{obj})}



\item[returns] the concatenation of the input lists


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{append} returns a new list consisting of the elements of the first
list followed by the elements of the second list, the elements of the
third list, and so on.
The new list is made from new pairs for all arguments but the last; the
last (which need not be a list) is merely placed at the end of
the new structure.
\texttt{append} may be defined without error checks as follows.

\begin{alltt}
(define append
  (lambda args
    (let f ([ls '()] [args args])
      (if (null? args)
          ls
          (let g ([ls ls])
            (if (null? ls)
                (f (car args) (cdr args))
                (cons (car ls) (g (cdr ls)))))))))

(append '(a b c) '()) \(\Rightarrow\) (a b c)
(append '() '(a b c)) \(\Rightarrow\) (a b c)
(append '(a b) '(c d)) \(\Rightarrow\) (a b c d)
(append '(a b) 'c) \(\Rightarrow\) (a b . c)
(let ([x (list 'b)])
  (eq? x (cdr (append '(a) x)))) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s50}\item[procedure] \texttt{(reverse \textit{list})}



\item[returns] a new list containing the elements of \texttt{\textit{list}} in reverse order


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{reverse} may be defined without error checks as follows.

\begin{alltt}
(define reverse
  (lambda (ls)
    (let rev ([ls ls] [new '()])
      (if (null? ls)
          new
          (rev (cdr ls) (cons (car ls) new))))))

(reverse '()) \(\Rightarrow\) ()
(reverse '(a b c)) \(\Rightarrow\) (c b a)
\end{alltt}

\begin{description}

\label{objects_s51}\item[procedure] \texttt{(memq \textit{obj} \textit{list})}



\item[procedure] \texttt{(memv \textit{obj} \textit{list})}



\item[procedure] \texttt{(member \textit{obj} \textit{list})}



\item[returns] the first tail of \texttt{\textit{list}} whose car is equivalent to \texttt{\textit{obj}}, or \texttt{\#{}f}


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}


These procedures traverse the argument \texttt{\textit{list}} in order, comparing the
elements of \texttt{\textit{list}} against \texttt{\textit{obj}}.
If an object equivalent to \texttt{\textit{obj}} is found, the tail of the list whose
first element is that object is returned.
If the list contains more than one object equivalent to \texttt{\textit{obj}}, the first
tail whose first element is equivalent to \texttt{\textit{obj}} is returned.
If no object equivalent to \texttt{\textit{obj}} is found, \texttt{\#{}f} is returned.
The equivalence test for \texttt{memq} is \texttt{eq?}, for \texttt{memv} is \texttt{eqv?},
and for \texttt{member} is \texttt{equal?}.


These procedures are most often used as predicates, but their names do not
end with a question mark because they return a useful true value in place
of \texttt{\#{}t}.
\texttt{memq} may be defined without error checks as follows.


\begin{alltt}
(define memq
  (lambda (x ls)
    (cond
      [(null? ls) \#{}f]
      [(eq? (car ls) x) ls]
      [else (memq x (cdr ls))])))
\end{alltt}

\texttt{memv} and \texttt{member} may be defined similarly, with \texttt{eqv?} and \texttt{equal?}
in place of \texttt{eq?}.

\begin{alltt}
(memq 'a '(b c a d e)) \(\Rightarrow\) (a d e)
(memq 'a '(b c d e g)) \(\Rightarrow\) \#{}f
(memq 'a '(b a c a d a)) \(\Rightarrow\) (a c a d a)

(memv 3.4 '(1.2 2.3 3.4 4.5)) \(\Rightarrow\) (3.4 4.5)
(memv 3.4 '(1.3 2.5 3.7 4.9)) \(\Rightarrow\) \#{}f
(let ([ls (list 'a 'b 'c)])
  (set-car! (memv 'b ls) 'z)
  ls) \(\Rightarrow\) (a z c)

(member '(b) '((a) (b) (c))) \(\Rightarrow\) ((b) (c))
(member '(d) '((a) (b) (c))) \(\Rightarrow\) \#{}f
(member "b" '("a" "b" "c")) \(\Rightarrow\) ("b" "c")

(let ()
  (define member?
    (lambda (x ls)
      (and (member x ls) \#{}t)))
  (member? '(b) '((a) (b) (c)))) \(\Rightarrow\) \#{}t

(define count-occurrences
  (lambda (x ls)
    (cond
      [(memq x ls) =\textgreater{}
       (lambda (ls)
         (+ (count-occurrences x (cdr ls)) 1))]
      [else 0])))

(count-occurrences 'a '(a b c d a)) \(\Rightarrow\) 2
\end{alltt}

\begin{description}

\label{objects_s52}\item[procedure] \texttt{(memp \textit{procedure} \textit{list})}



\item[returns] the first tail of \texttt{\textit{list}} for whose car \texttt{\textit{procedure}} returns true, or \texttt{\#{}f}


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{procedure}} should accept one argument and return a single value.
It should not modify \texttt{\textit{list}}.

\begin{alltt}
(memp odd? '(1 2 3 4)) \(\Rightarrow\) (1 2 3 4)
(memp even? '(1 2 3 4)) \(\Rightarrow\) (2 3 4)
(let ([ls (list 1 2 3 4)])
  (eq? (memp odd? ls) ls)) \(\Rightarrow\) \#{}t
(let ([ls (list 1 2 3 4)])
  (eq? (memp even? ls) (cdr ls))) \(\Rightarrow\) \#{}t
(memp odd? '(2 4 6 8)) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s53}\item[procedure] \texttt{(remq \textit{obj} \textit{list})}



\item[procedure] \texttt{(remv \textit{obj} \textit{list})}



\item[procedure] \texttt{(remove \textit{obj} \textit{list})}



\item[returns] a list containing the elements of \texttt{\textit{list}} with all occurrences of \texttt{\textit{obj}} removed


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}


These procedures traverse the argument \texttt{\textit{list}}, removing any objects
that are equivalent to \texttt{\textit{obj}}.
The elements remaining in the output list are in the same order as they appear
in the input list.
If a tail of \texttt{\textit{list}} (including \texttt{\textit{list}} itself) contains no occurrences of 
\texttt{\textit{obj}}, the corresponding tail of the result list may be the same
(by \texttt{eq?}) as the tail of the input list.


The equivalence test for \texttt{remq} is \texttt{eq?},
for \texttt{remv} is \texttt{eqv?},
and for \texttt{remove} is \texttt{equal?}.


\begin{alltt}
(remq 'a '(a b a c a d)) \(\Rightarrow\) (b c d)
(remq 'a '(b c d)) \(\Rightarrow\) (b c d)

(remv 1/2 '(1.2 1/2 0.5 3/2 4)) \(\Rightarrow\) (1.2 0.5 3/2 4)

(remove '(b) '((a) (b) (c))) \(\Rightarrow\) ((a) (c))
\end{alltt}

\begin{description}

\label{objects_s54}\item[procedure] \texttt{(remp \textit{procedure} \textit{list})}



\item[returns] a list of the elements of \texttt{\textit{list}} for which \texttt{\textit{procedure}} returns \texttt{\#{}f}


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{procedure}} should accept one argument and return a single value.
It should not modify \texttt{\textit{list}}.
\texttt{remp} applies \texttt{\textit{procedure}} to each element of \texttt{\textit{list}}
and returns a list containing only the elements for which
\texttt{\textit{procedure}} returns \texttt{\#{}f}.
The elements of the returned list appear in the same order as they
appeared in the original list.

\begin{alltt}
(remp odd? '(1 2 3 4)) \(\Rightarrow\) (2 4)
(remp
  (lambda (x) (and (\textgreater{} x 0) (\textless{} x 10)))
  '(-5 15 3 14 -20 6 0 -9)) \(\Rightarrow\) (-5 15 14 -20 0 -9)
\end{alltt}

\begin{description}

\label{objects_s55}\item[procedure] \texttt{(filter \textit{procedure} \textit{list})}



\item[returns] a list of the elements of \texttt{\textit{list}} for which \texttt{\textit{procedure}} returns true


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{procedure}} should accept one argument and return a single value.
It should not modify \texttt{\textit{list}}.
\texttt{filter} applies \texttt{\textit{procedure}} to each element of \texttt{\textit{list}}
and returns a new list containing only the elements for which
\texttt{\textit{procedure}} returns true.
The elements of the returned list appear in the same order as they
appeared in the original list.

\begin{alltt}
(filter odd? '(1 2 3 4)) \(\Rightarrow\) (1 3)
(filter
  (lambda (x) (and (\textgreater{} x 0) (\textless{} x 10)))
  '(-5 15 3 14 -20 6 0 -9)) \(\Rightarrow\) (3 6)
\end{alltt}

\begin{description}

\label{objects_s56}\item[procedure] \texttt{(partition \textit{procedure} \textit{list})}



\item[returns] see below


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{procedure}} should accept one argument and return a single value.
It should not modify \texttt{\textit{list}}.
\texttt{partition} applies \texttt{\textit{procedure}} to each element of \texttt{\textit{list}}
and returns two values:
a new list containing only the elements for which
\texttt{\textit{procedure}} returns true, and
a new list containing only the elements for which
\texttt{\textit{procedure}} returns \texttt{\#{}f}.
The elements of the returned lists appear in the same order as they
appeared in the original list.

\begin{alltt}
(partition odd? '(1 2 3 4)) \(\Rightarrow\) (1 3)
                             (2 4)
(partition
  (lambda (x) (and (\textgreater{} x 0) (\textless{} x 10)))
  '(-5 15 3 14 -20 6 0 -9)) \(\Rightarrow\) (3 6)
                             (-5 15 14 -20 0 -9)
\end{alltt}


The values returned by \texttt{partition} can be obtained by calling
\texttt{filter} and \texttt{remp} separately, but this would require
two calls to \texttt{\textit{procedure}} for each element of \texttt{\textit{list}}.

\begin{description}

\label{objects_s57}\item[procedure] \texttt{(find \textit{procedure} \textit{list})}



\item[returns] the first element of \texttt{\textit{list}} for which \texttt{\textit{procedure}} returns true, or \texttt{\#{}f}


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{procedure}} should accept one argument and return a single value.
It should not modify \texttt{\textit{list}}.
\texttt{find} traverses the argument \texttt{\textit{list}} in order, applying
\texttt{\textit{procedure}} to each element in turn.
If \texttt{\textit{procedure}} returns a true value for a given element, \texttt{find}
returns that element without applying \texttt{\textit{procedure}} to the remaining elements.
If \texttt{\textit{procedure}} returns \texttt{\#{}f} for each element of \texttt{\textit{list}},
\texttt{find} returns \texttt{\#{}f}.

If a program must distinguish between finding \texttt{\#{}f} in the list
and finding no element at all, \texttt{memp} should be used instead.


\begin{alltt}
(find odd? '(1 2 3 4)) \(\Rightarrow\) 1
(find even? '(1 2 3 4)) \(\Rightarrow\) 2
(find odd? '(2 4 6 8)) \(\Rightarrow\) \#{}f
(find not '(1 a \#{}f 55)) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s58}\label{objects_page_assq}
\item[procedure] \texttt{(assq \textit{obj} \textit{alist})}



\item[procedure] \texttt{(assv \textit{obj} \textit{alist})}



\item[procedure] \texttt{(assoc \textit{obj} \textit{alist})}



\item[returns] first element of \texttt{\textit{alist}} whose car is equivalent to \texttt{\textit{obj}}, or \texttt{\#{}f}


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}


The argument \texttt{\textit{alist}} must be an \label{objects_s59}\textit{association list}.
An association list is a proper list whose elements are key-value pairs
of the form \texttt{(key . value)}.
Associations are useful for storing information (values) associated with
certain objects (keys).


These procedures traverse the association list, testing each key for equivalence
with \texttt{\textit{obj}}.
If an equivalent key is found, the key-value pair is returned.
Otherwise, \texttt{\#{}f} is returned.


The equivalence test for \texttt{assq} is \texttt{eq?},
for \texttt{assv} is \texttt{eqv?},
and for \texttt{assoc} is \texttt{equal?}.
\texttt{assq} may be defined without error checks as follows.


\begin{alltt}
(define assq
  (lambda (x ls)
    (cond
      [(null? ls) \#{}f]
      [(eq? (caar ls) x) (car ls)]
      [else (assq x (cdr ls))])))
\end{alltt}

\texttt{assv} and \texttt{assoc} may be defined similarly, with \texttt{eqv?} and \texttt{equal?}
in place of \texttt{eq?}.

\begin{alltt}
(assq 'b '((a . 1) (b . 2))) \(\Rightarrow\) (b . 2)
(cdr (assq 'b '((a . 1) (b . 2)))) \(\Rightarrow\) 2
(assq 'c '((a . 1) (b . 2))) \(\Rightarrow\) \#{}f

(assv 2/3 '((1/3 . 1) (2/3 . 2))) \(\Rightarrow\) (2/3 . 2)
(assv 2/3 '((1/3 . a) (3/4 . b))) \(\Rightarrow\) \#{}f

(assoc '(a) '(((a) . a) (-1 . b))) \(\Rightarrow\) ((a) . a)
(assoc '(a) '(((b) . b) (a . c))) \(\Rightarrow\) \#{}f

(let ([alist (list (cons 2 'a) (cons 3 'b))])
  (set-cdr! (assv 3 alist) 'c)
  alist) \(\Rightarrow\) ((2 . a) (3 . c))
\end{alltt}


The interpreter given in Section \ref{examples_g187} represents
environments as association lists and uses \texttt{assq} for both
variable lookup and assignment.

\begin{description}

\label{objects_s60}\item[procedure] \texttt{(assp \textit{procedure} \textit{alist})}



\item[returns] first element of \texttt{\textit{alist}} for whose car \texttt{\textit{procedure}} returns true, or \texttt{\#{}f}


\item[libraries] \texttt{(rnrs lists)}, \texttt{(rnrs)}
\end{description}


\label{objects_s61}\texttt{\textit{alist}} must be an \textit{association list}.
An association list is a proper list whose elements are key-value pairs
of the form \texttt{(key . value)}.
\texttt{\textit{procedure}} should accept one argument and return a single value.
It should not modify \texttt{\textit{list}}.


\begin{alltt}
(assp odd? '((1 . a) (2 . b))) \(\Rightarrow\) (1 . a)
(assp even? '((1 . a) (2 . b))) \(\Rightarrow\) (2 . b)
(let ([ls (list (cons 1 'a) (cons 2 'b))])
  (eq? (assp odd? ls) (car ls))) \(\Rightarrow\) \#{}t
(let ([ls (list (cons 1 'a) (cons 2 'b))])
  (eq? (assp even? ls) (cadr ls))) \(\Rightarrow\) \#{}t
(assp odd? '((2 . b))) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s62}\item[procedure] \texttt{(list-sort \textit{predicate} \textit{list})}



\item[returns] a list containing the elements of \texttt{\textit{list}} sorted according to \texttt{\textit{predicate}}


\item[libraries] \texttt{(rnrs sorting)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{predicate}} should be a procedure that expects two arguments and
returns \texttt{\#{}t} if its first argument must precede its second in
the sorted list.
That is, if \texttt{\textit{predicate}} is applied to two elements \texttt{\textit{x}} and
\texttt{\textit{y}}, where \texttt{\textit{x}} appears after \texttt{\textit{y}} in the input list,
it should return true only if \texttt{\textit{x}} should appear before \texttt{\textit{y}}
in the output list.
If this constraint is met,
\texttt{list-sort} performs a stable sort, i.e., two elements are
reordered only when necessary according to \texttt{\textit{predicate}}.
Duplicate elements are not removed.
This procedure may call predicate up to \textit{n}log\textit{n} times, where \textit{n} is
the length of \texttt{\textit{list}}.

\begin{alltt}
(list-sort \textless{} '(3 4 2 1 2 5)) \(\Rightarrow\) (1 2 2 3 4 5)
(list-sort \textgreater{} '(0.5 1/2)) \(\Rightarrow\) (0.5 1/2)
(list-sort \textgreater{} '(1/2 0.5)) \(\Rightarrow\) (1/2 0.5)
(list-\textgreater{}string
  (list-sort char\textgreater{}?
    (string-\textgreater{}list "hello"))) \(\Rightarrow\) "ollhe"
\end{alltt}

\section{\label{objects_g110}\label{objects_h4}Numbers\label{objects_SECTNUMBERS}}



\label{objects_s63}Scheme numbers may be classified as
\label{objects_s64}integers, \label{objects_s65}rational numbers,
\label{objects_s66}real numbers, or \label{objects_s67}complex numbers.
This classification is hierarchical, in that all integers are
rational, all rational numbers are real, and all real numbers are
complex.
The predicates \label{objects_s68}\texttt{integer?}, \label{objects_s69}\texttt{rational?}, \label{objects_s70}\texttt{real?}, and
\label{objects_s71}\texttt{complex?} described in Section \ref{objects_g108} are used to
determine into which of these classes a number falls.


A Scheme number may also be classified as \label{objects_s72}\textit{exact} or
\textit{inexact}, depending upon the quality of operations used
to derive the number and the inputs to these operations.
The predicates \label{objects_s73}\texttt{exact?} and \label{objects_s74}\texttt{inexact?} may be used to
determine the exactness of a number.
Most operations on numbers in Scheme are \label{objects_s75}\textit{exactness preserving}:  if given exact operands they return exact values,
and if given inexact operands or a combination of exact and inexact
operands they return inexact values.


Exact integer and rational arithmetic is typically supported to
\label{objects_s76}arbitrary precision; the size of an integer or of the denominator
or numerator of a ratio is limited only by system storage constraints.
Although other representations are possible,
inexact numbers are typically represented by \label{objects_s77}\textit{floating-point} numbers supported by the host computer's
hardware or by system software.
Complex numbers are typically represented as ordered pairs
(\texttt{\textit{real-part}}, \texttt{\textit{imag-part}}), where \texttt{\textit{real-part}} and \texttt{\textit{imag-part}}
are exact integers, exact rationals, or floating-point numbers.


Scheme numbers are written in a straightforward manner not much different from
ordinary conventions for writing numbers.
An exact integer is normally written as a sequence of numerals
preceded by an optional sign.
For example, \texttt{3}, \texttt{+19}, \texttt{-100000}, and
\texttt{208423089237489374} all represent exact integers.


An exact rational number is normally written as two sequences of numerals
separated by a slash (\texttt{/}) and preceded by an optional sign.
For example, \texttt{3/4}, \texttt{-6/5}, and \texttt{1/1208203823} are all exact
rational numbers.
A ratio is reduced immediately to lowest terms when it is read and may in fact
reduce to an exact integer.


Inexact real numbers are normally written in either
floating-point or scientific notation.
Floating-point notation consists of a sequence of
numerals followed by a decimal point and another sequence of
numerals, all preceded by an optional sign.
Scientific notation consists of an optional sign, a sequence of numerals,
an optional decimal point followed by a second string of numerals,
and an exponent; an exponent is written as the letter \texttt{e}
followed by an optional sign and a sequence of numerals.
For example, \texttt{1.0} and \texttt{-200.0} are valid inexact integers, and
\texttt{1.5}, \texttt{0.034}, \texttt{-10e-10} and \texttt{1.5e-5} are valid inexact rational
numbers.
The exponent is the power of ten by which the number preceding the
exponent should be scaled, so that \texttt{2e3} is equivalent to \texttt{2000.0}.


A mantissa width \texttt{\textbar{}\textit{w}} may appear as the suffix of a real
number or the real components of a complex number written in floating-point
or scientific notation.
The mantissa width \texttt{\textit{m}} represents the number of significant bits
in the representation of the number.
The mantissa width defaults to 53, the number of significant bits in
a normalized IEEE double floating-point number, or more.
For denormalized IEEE double floating-point numbers, the mantissa width is
less than 53.
If an implementation cannot represent a number with the mantissa width
specified, it uses a representation with at least as many significant
bits as requested if possible, otherwise it uses its representation with
the largest mantissa width.


Exact and inexact real numbers are written as exact or inexact
integers or rational numbers; no provision is made in the syntax
of Scheme numbers for nonrational real numbers, i.e., irrational
numbers.


Complex numbers may be written in either rectangular or polar form.
In rectangular form, a complex number is written as \texttt{\textit{x}+\textit{y}i} or
\texttt{\textit{x}-\textit{y}i},
where \texttt{\textit{x}} is an integer, rational, or real number
and \texttt{\textit{y}} is an unsigned integer, rational, or real number.
The real part, \textit{x}, may be omitted, in which case it is assumed to
be zero.
For example, \texttt{3+4i}, \texttt{3.2-3/4i}, \texttt{+i}, and
\texttt{-3e-5i} are complex numbers written in rectangular form.
In polar form, a complex number is written as \texttt{\textit{x}\@{}\textit{y}},
where \texttt{\textit{x}}
and \texttt{\textit{y}} are integer, rational, or real numbers.
For example, \texttt{1.1\@{}1.764} and \texttt{-1\@{}-1/2} are complex numbers written
in polar form.


The syntaxes \texttt{+inf.0} and \texttt{-inf.0} represent inexact real
numbers that represent positive and negative infinity.
The syntaxes \texttt{+nan.0} and \texttt{-nan.0} represent an inexact
``not-a-number'' (NaN) value.
Infinities may be produced by dividing inexact positive and negative
values by inexact zero, and NaNs may also be produced by dividing inexact
zero by inexact zero, among other ways.


The exactness of a numeric representation may be overridden by
preceding the representation by either \texttt{\#{}e} or \texttt{\#{}i}.
\texttt{\#{}e} forces the number to be exact, and \texttt{\#{}i} forces it to be
inexact.
For example, \texttt{1}, \texttt{\#{}e1}, 1/1, \texttt{\#{}e1/1},
\texttt{\#{}e1.0}, and \texttt{\#{}e1e0} all
represent the exact integer 1, and \texttt{\#{}i3/10},
\texttt{0.3}, \texttt{\#{}i0.3},
and \texttt{3e-1} all represent the inexact rational 0.3.


Numbers are written by default in base 10, although the special prefixes
\label{objects_s78}\texttt{\#{}b} (binary), \label{objects_s79}\texttt{\#{}o} (octal), \label{objects_s80}\texttt{\#{}d} (decimal), and
\label{objects_s81}\texttt{\#{}x} (hexadecimal) can be used to specify base 2, base 8, base 10,
or base 16.
For radix 16, the letters \texttt{a} through \texttt{f}
or \texttt{A} through \texttt{F} serve as the additional numerals required to
express digit values 10 through 15.
For example, \texttt{\#{}b10101} is the binary equivalent of
21\textsubscript{10}, \texttt{\#{}o72} is the octal equivalent of 58\textsubscript{10}, and \texttt{\#{}xC7}
is the hexadecimal equivalent of 199\textsubscript{10}.
Numbers written in floating-point and scientific notations are
always written in base 10.


If both are present, radix and exactness prefixes may appear in
either order.


A Scheme implementation may support more than one size of internal
representation for inexact quantities.
The exponent markers
\label{objects_s82}\texttt{s} (\textit{short}),
\label{objects_s83}\texttt{f} (\textit{single}),
\label{objects_s84}\texttt{d} (\textit{double}),
and
\label{objects_s85}\texttt{l} (\textit{long})
may appear in place of the default exponent marker
\texttt{e} to override the default size for numbers written in scientific
notation.
In implementations that support multiple representations, the
default size has at least as much precision as \textit{double}.


A precise grammar for Scheme numbers is given 
on page \pageref{grammar_grammar_numbers}.


Any number can be written in a variety of different ways, but the
system printer (invoked by \texttt{put-datum}, \texttt{write}, and \texttt{display}) and
\texttt{number-\textgreater{}string} express numbers in a compact form,
using the fewest number of digits necessary to retain
the property that, when read, the printed number is identical
to the original number.



The remainder of this section describes ``generic arithmetic'' procedures
that operate on numbers.
The two sections that follow this section describe operations specific to
\textit{fixnums} and \textit{flonums}, which are representations of exact,
fixed-precision integer values and inexact real values.


The types of numeric arguments accepted by the procedures in this section
are implied by the names given to the arguments: \texttt{\textit{num}} for complex
numbers (that is, all numbers), \texttt{\textit{real}} for real numbers, \texttt{\textit{rat}}
for rational numbers, and \texttt{\textit{int}} for integers.
If a \texttt{\textit{real}}, \texttt{\textit{rat}}, or \texttt{\textit{int}} is required, the argument must be
considered real, rational, or integral by \texttt{real?},
\texttt{rational?}, or \texttt{integer?}, i.e., the imaginary part of the
number must be exactly zero.
Where exact integers are required, the name \texttt{\textit{exint}} is used.
In each case, a suffix may appear on the name, e.g., \texttt{\textit{int\textsubscript{2}}}.


\begin{description}

\label{objects_s86}\item[procedure] \texttt{(exact? \textit{num})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{num}} is exact, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(exact? 1) \(\Rightarrow\) \#{}t
(exact? -15/16) \(\Rightarrow\) \#{}t
(exact? 2.01) \(\Rightarrow\) \#{}f
(exact? \#{}i77) \(\Rightarrow\) \#{}f
(exact? \#{}i2/3) \(\Rightarrow\) \#{}f
(exact? 1.0-2i) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s87}\item[procedure] \texttt{(inexact? \textit{num})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{num}} is inexact, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(inexact? -123) \(\Rightarrow\) \#{}f
(inexact? \#{}i123) \(\Rightarrow\) \#{}t
(inexact? 1e23) \(\Rightarrow\) \#{}t
(inexact? +i) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s88}\item[procedure] \texttt{(= \textit{num\textsubscript{1}} \textit{num\textsubscript{2}} \textit{num\textsubscript{3}} ...)}



\item[procedure] \texttt{(\textless{} \textit{real\textsubscript{1}} \textit{real\textsubscript{2}} \textit{real\textsubscript{3}} ...)}



\item[procedure] \texttt{(\textgreater{} \textit{real\textsubscript{1}} \textit{real\textsubscript{2}} \textit{real\textsubscript{3}} ...)}



\item[procedure] \texttt{(\textless{}= \textit{real\textsubscript{1}} \textit{real\textsubscript{2}} \textit{real\textsubscript{3}} ...)}



\item[procedure] \texttt{(\textgreater{}= \textit{real\textsubscript{1}} \textit{real\textsubscript{2}} \textit{real\textsubscript{3}} ...)}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The predicate \texttt{=} returns \texttt{\#{}t} if its arguments are equal.
The predicate \texttt{\textless{}} returns \texttt{\#{}t} if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while \texttt{\textgreater{}} returns \texttt{\#{}t} if its arguments are monotonically decreasing.
The predicate \texttt{\textless{}=} returns \texttt{\#{}t} if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while \texttt{\textgreater{}=} returns \texttt{\#{}t} if its arguments are monotonically nonincreasing.


As implied by the names of the arguments, \texttt{=} is defined for complex
arguments while the other relational predicates are defined only for real
arguments.
Two complex numbers are considered equal if their real and imaginary parts
are equal.
Comparisons involving NaNs always return \texttt{\#{}f}.


\begin{alltt}
(= 7 7) \(\Rightarrow\) \#{}t
(= 7 9) \(\Rightarrow\) \#{}f

(\textless{} 2e3 3e2) \(\Rightarrow\) \#{}f
(\textless{}= 1 2 3 3 4 5) \(\Rightarrow\) \#{}t
(\textless{}= 1 2 3 4 5) \(\Rightarrow\) \#{}t

(\textgreater{} 1 2 2 3 3 4) \(\Rightarrow\) \#{}f
(\textgreater{}= 1 2 2 3 3 4) \(\Rightarrow\) \#{}f

(= -1/2 -0.5) \(\Rightarrow\) \#{}t
(= 2/3 .667) \(\Rightarrow\) \#{}f
(= 7.2+0i 7.2) \(\Rightarrow\) \#{}t
(= 7.2-3i 7) \(\Rightarrow\) \#{}f

(\textless{} 1/2 2/3 3/4) \(\Rightarrow\) \#{}t
(\textgreater{} 8 4.102 2/3 -5) \(\Rightarrow\) \#{}t

(let ([x 0.218723452])
  (\textless{} 0.210 x 0.220)) \(\Rightarrow\) \#{}t

(let ([i 1] [v (vector 'a 'b 'c)])
  (\textless{} -1 i (vector-length v))) \(\Rightarrow\) \#{}t

(apply \textless{} '(1 2 3 4)) \(\Rightarrow\) \#{}t
(apply \textgreater{} '(4 3 3 2)) \(\Rightarrow\) \#{}f

(= +nan.0 +nan.0) \(\Rightarrow\) \#{}f
(\textless{} +nan.0 +nan.0) \(\Rightarrow\) \#{}f
(\textgreater{} +nan.0 +nan.0) \(\Rightarrow\) \#{}f
(\textgreater{}= +inf.0 +nan.0) \(\Rightarrow\) \#{}f
(\textgreater{}= +nan.0 -inf.0) \(\Rightarrow\) \#{}f
(\textgreater{} +nan.0 0.0) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s89}\item[procedure] \texttt{(+ \textit{num} ...)}



\item[returns] the sum of the arguments \texttt{\textit{num} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


When called with no arguments, \texttt{+} returns 0.


\begin{alltt}
(+) \(\Rightarrow\) 0
(+ 1 2) \(\Rightarrow\) 3
(+ 1/2 2/3) \(\Rightarrow\) 7/6
(+ 3 4 5) \(\Rightarrow\) 12
(+ 3.0 4) \(\Rightarrow\) 7.0
(+ 3+4i 4+3i) \(\Rightarrow\) 7+7i
(apply + '(1 2 3 4 5)) \(\Rightarrow\) 15
\end{alltt}

\begin{description}

\label{objects_s90}\item[procedure] \texttt{(- \textit{num})}



\item[returns] the additive inverse of \texttt{\textit{num}}


\item[procedure] \texttt{(- \textit{num\textsubscript{1}} \textit{num\textsubscript{2}} \textit{num\textsubscript{3}} ...)}



\item[returns] the difference between \texttt{\textit{num\textsubscript{1}}} and the sum of \texttt{\textit{num\textsubscript{2}} \textit{num\textsubscript{3}} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(- 3) \(\Rightarrow\) -3
(- -2/3) \(\Rightarrow\) 2/3
(- 4 3.0) \(\Rightarrow\) 1.0
(- 3.25+4.25i 1/4+1/4i) \(\Rightarrow\) 3.0+4.0i
(- 4 3 2 1) \(\Rightarrow\) -2
\end{alltt}

\begin{description}

\label{objects_s91}\item[procedure] \texttt{(* \textit{num} ...)}



\item[returns] the product of the arguments \texttt{\textit{num} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


When called with no arguments, \texttt{*} returns 1.


\begin{alltt}
(*) \(\Rightarrow\) 1
(* 3.4) \(\Rightarrow\) 3.4
(* 1 1/2) \(\Rightarrow\) 1/2
(* 3 4 5.5) \(\Rightarrow\) 66.0
(* 1+2i 3+4i) \(\Rightarrow\) -5+10i
(apply * '(1 2 3 4 5)) \(\Rightarrow\) 120
\end{alltt}

\begin{description}

\label{objects_s92}\item[procedure] \texttt{(/ \textit{num})}



\item[returns] the multiplicative inverse of \texttt{\textit{num}}


\item[procedure] \texttt{(/ \textit{num\textsubscript{1}} \textit{num\textsubscript{2}} \textit{num\textsubscript{3}} ...)}



\item[returns] the result of dividing \texttt{\textit{num\textsubscript{1}}} by the product of \texttt{\textit{num\textsubscript{2}} \textit{num\textsubscript{3}} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(/ -17) \(\Rightarrow\) -1/17
(/ 1/2) \(\Rightarrow\) 2
(/ .5) \(\Rightarrow\) 2.0
(/ 3 4) \(\Rightarrow\) 3/4
(/ 3.0 4) \(\Rightarrow\) .75
(/ -5+10i 3+4i) \(\Rightarrow\) 1+2i
(/ 60 5 4 3 2) \(\Rightarrow\) 1/2
\end{alltt}

\begin{description}

\label{objects_s93}\item[procedure] \texttt{(zero? \textit{num})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{num}} is zero, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{zero?} is equivalent to \texttt{(lambda (x) (= x 0))}.

\begin{alltt}
(zero? 0) \(\Rightarrow\) \#{}t
(zero? 1) \(\Rightarrow\) \#{}f
(zero? (- 3.0 3.0)) \(\Rightarrow\) \#{}t
(zero? (+ 1/2 1/2)) \(\Rightarrow\) \#{}f
(zero? 0+0i) \(\Rightarrow\) \#{}t
(zero? 0.0-0.0i) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s94}\item[procedure] \texttt{(positive? \textit{real})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{real}} is greater than zero, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{positive?} is equivalent to \texttt{(lambda (x) (\textgreater{} x 0))}.

\begin{alltt}
(positive? 128) \(\Rightarrow\) \#{}t
(positive? 0.0) \(\Rightarrow\) \#{}f
(positive? 1.8e-15) \(\Rightarrow\) \#{}t
(positive? -2/3) \(\Rightarrow\) \#{}f
(positive? .001-0.0i) \(\Rightarrow\) \textit{exception: not a real number}
\end{alltt}

\begin{description}

\label{objects_s95}\item[procedure] \texttt{(negative? \textit{real})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{real}} is less than zero, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{negative?} is equivalent to \texttt{(lambda (x) (\textless{} x 0))}.

\begin{alltt}
(negative? -65) \(\Rightarrow\) \#{}t
(negative? 0) \(\Rightarrow\) \#{}f
(negative? -0.0121) \(\Rightarrow\) \#{}t
(negative? 15/16) \(\Rightarrow\) \#{}f
(negative? -7.0+0.0i) \(\Rightarrow\) \textit{exception: not a real number}
\end{alltt}

\begin{description}

\label{objects_s96}\item[procedure] \texttt{(even? \textit{int})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{int}} is even, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(odd? \textit{int})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{int}} is odd, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(even? 0) \(\Rightarrow\) \#{}t
(even? 1) \(\Rightarrow\) \#{}f
(even? 2.0) \(\Rightarrow\) \#{}t
(even? -120762398465) \(\Rightarrow\) \#{}f
(even? 2.0+0.0i) \(\Rightarrow\) \textit{exception: not an integer}

(odd? 0) \(\Rightarrow\) \#{}f
(odd? 1) \(\Rightarrow\) \#{}t
(odd? 2.0) \(\Rightarrow\) \#{}f
(odd? -120762398465) \(\Rightarrow\) \#{}t
(odd? 2.0+0.0i) \(\Rightarrow\) \textit{exception: not an integer}
\end{alltt}

\begin{description}

\label{objects_s97}\item[procedure] \texttt{(finite? \textit{real})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{real}} is finite, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(infinite? \textit{real})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{real}} is infinite, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(nan? \textit{real})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{real}} is a NaN, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(finite? 2/3) \(\Rightarrow\) \#{}t
(infinite? 2/3) \(\Rightarrow\) \#{}f
(nan? 2/3) \(\Rightarrow\) \#{}f

(finite? 3.1415) \(\Rightarrow\) \#{}t
(infinite? 3.1415) \(\Rightarrow\) \#{}f
(nan? 3.1415) \(\Rightarrow\) \#{}f

(finite? +inf.0) \(\Rightarrow\) \#{}f
(infinite? -inf.0) \(\Rightarrow\) \#{}t
(nan? -inf.0) \(\Rightarrow\) \#{}f

(finite? +nan.0) \(\Rightarrow\) \#{}f
(infinite? +nan.0) \(\Rightarrow\) \#{}f
(nan? +nan.0) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s98}\item[procedure] \texttt{(quotient \textit{int\textsubscript{1}} \textit{int\textsubscript{2}})}



\item[returns] the integer quotient of \texttt{\textit{int\textsubscript{1}}} and \texttt{\textit{int\textsubscript{2}}}


\item[procedure] \texttt{(remainder \textit{int\textsubscript{1}} \textit{int\textsubscript{2}})}



\item[returns] the integer remainder of \texttt{\textit{int\textsubscript{1}}} and \texttt{\textit{int\textsubscript{2}}}


\item[procedure] \texttt{(modulo \textit{int\textsubscript{1}} \textit{int\textsubscript{2}})}



\item[returns] the integer modulus of \texttt{\textit{int\textsubscript{1}}} and \texttt{\textit{int\textsubscript{2}}}


\item[libraries] \texttt{(rnrs r5rs)}
\end{description}


The result of \texttt{remainder} has the same sign as \texttt{\textit{int\textsubscript{1}}},
while the result of \texttt{modulo} has the same sign as \texttt{\textit{int\textsubscript{2}}}.


\begin{alltt}
(quotient 45 6) \(\Rightarrow\) 7
(quotient 6.0 2.0) \(\Rightarrow\) 3.0
(quotient 3.0 -2) \(\Rightarrow\) -1.0

(remainder 16 4) \(\Rightarrow\) 0
(remainder 5 2) \(\Rightarrow\) 1
(remainder -45.0 7) \(\Rightarrow\) -3.0
(remainder 10.0 -3.0) \(\Rightarrow\) 1.0
(remainder -17 -9) \(\Rightarrow\) -8

(modulo 16 4) \(\Rightarrow\) 0
(modulo 5 2) \(\Rightarrow\) 1
(modulo -45.0 7) \(\Rightarrow\) 4.0
(modulo 10.0 -3.0) \(\Rightarrow\) -2.0
(modulo -17 -9) \(\Rightarrow\) -8
\end{alltt}

\begin{description}

\label{objects_s99}\item[procedure] \texttt{(div \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})}



\item[procedure] \texttt{(mod \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})}



\item[procedure] \texttt{(div-and-mod \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{x\textsubscript{1}}} and \texttt{\textit{x\textsubscript{2}}} are exact, \texttt{\textit{x\textsubscript{2}}} must not be zero.
These procedures implement number-theoretic integer division, with the
\texttt{div} operation being related to \texttt{quotient} and the
\texttt{mod} operation being related to \texttt{remainder} or
\texttt{modulo}, but in both cases extended to handle real numbers.


The value \texttt{\textit{n\textsubscript{d}}} of \texttt{(div \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})} is an integer,
and the value \texttt{\textit{x\textsubscript{m}}} of \texttt{(mod \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})} is a real
number such that \textit{x}\textsubscript{1} = \textit{n}\textsubscript{d} · \textit{x}\textsubscript{2} + \textit{x}\textsubscript{m} and
0 ≤ \textit{x}\textsubscript{m} \textless{} \textbar{}\textit{x}\textsubscript{2}\textbar{}.
In situations where the implementation cannot represent the mathematical
results prescribed by these equations as a number object, \texttt{div} and
\texttt{mod} return an unspecified number or raise an exception with
condition type \texttt{\&{}implementation-restriction}.


The \texttt{div-and-mod} procedure behaves as if defined as follows.


\texttt{(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))}

That is, unless it raises an exception in the circumstance described
above, it returns two values: the result of calling \texttt{div} on the
two arguments and the result of calling \texttt{mod} on the two
arguments.


\begin{alltt}
(div 17 3) \(\Rightarrow\) 5
(mod 17 3) \(\Rightarrow\) 2
(div -17 3) \(\Rightarrow\) -6
(mod -17 3) \(\Rightarrow\) 1
(div 17 -3) \(\Rightarrow\) -5
(mod 17 -3) \(\Rightarrow\) 2
(div -17 -3) \(\Rightarrow\) 6
(mod -17 -3) \(\Rightarrow\) 1

(div-and-mod 17.5 3) \(\Rightarrow\) 5.0
                      2.5
\end{alltt}

\begin{description}

\label{objects_s100}\item[procedure] \texttt{(div0 \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})}



\item[procedure] \texttt{(mod0 \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})}



\item[procedure] \texttt{(div0-and-mod0 \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{x\textsubscript{1}}} and \texttt{\textit{x\textsubscript{2}}} are exact, \texttt{\textit{x\textsubscript{2}}} must not be zero.
These procedures are similar to \texttt{div}, \texttt{mod}, and
\texttt{div-and-mod}, but constrain the ``mod'' value differently,
which also affects the ``div'' value.
The value \texttt{\textit{n\textsubscript{d}}} of \texttt{(div0 \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})} is an integer,
and the value \texttt{\textit{x\textsubscript{m}}} of \texttt{(mod0 \textit{x\textsubscript{1}} \textit{x\textsubscript{2}})} is a real
number such that \textit{x}\textsubscript{1} = \textit{n}\textsubscript{d} · \textit{x}\textsubscript{2} + \textit{x}\textsubscript{m} and
-\textbar{}\textit{x}\textsubscript{2}/2\textbar{} ≤ \textit{x}\textsubscript{m} \textless{} \textbar{}\textit{x}\textsubscript{2}/2\textbar{}.
In situations where the implementation cannot represent the mathematical
results prescribed by these equations as a number object, \texttt{div0} and
\texttt{mod0} return an unspecified number or raise an exception with
condition type \texttt{\&{}implementation-restriction}.


The \texttt{div0-and-mod0} procedure behaves as if defined as follows.


\texttt{(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))}

That is, unless it raises an exception in the circumstance described
above, it returns two values: the result of calling \texttt{div0} on the
two arguments and the result of calling \texttt{mod0} on the two
arguments.


\begin{alltt}
(div0 17 3) \(\Rightarrow\) 6
(mod0 17 3) \(\Rightarrow\) -1
(div0 -17 3) \(\Rightarrow\) -6
(mod0 -17 3) \(\Rightarrow\) 1
(div0 17 -3) \(\Rightarrow\) -6
(mod0 17 -3) \(\Rightarrow\) -1
(div0 -17 -3) \(\Rightarrow\) 6
(mod0 -17 -3) \(\Rightarrow\) 1

(div0-and-mod0 17.5 3) \(\Rightarrow\) 6.0
                        -0.5
\end{alltt}

\begin{description}

\label{objects_s101}\item[procedure] \texttt{(truncate \textit{real})}



\item[returns] the integer closest to \texttt{\textit{real}} toward zero


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{real}} is an infinity or NaN, \texttt{truncate} returns \texttt{\textit{real}}.


\begin{alltt}
(truncate 19) \(\Rightarrow\) 19
(truncate 2/3) \(\Rightarrow\) 0
(truncate -2/3) \(\Rightarrow\) 0
(truncate 17.3) \(\Rightarrow\) 17.0
(truncate -17/2) \(\Rightarrow\) -8
\end{alltt}

\begin{description}

\label{objects_s102}\item[procedure] \texttt{(floor \textit{real})}



\item[returns] the integer closest to \texttt{\textit{real}} toward \(-\infty\)


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{real}} is an infinity or NaN, \texttt{floor} returns \texttt{\textit{real}}.


\begin{alltt}
(floor 19) \(\Rightarrow\) 19
(floor 2/3) \(\Rightarrow\) 0
(floor -2/3) \(\Rightarrow\) -1
(floor 17.3) \(\Rightarrow\) 17.0
(floor -17/2) \(\Rightarrow\) -9
\end{alltt}

\begin{description}

\label{objects_s103}\item[procedure] \texttt{(ceiling \textit{real})}



\item[returns] the integer closest to \texttt{\textit{real}} toward \(+\infty\)


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{real}} is an infinity or NaN, \texttt{ceiling} returns \texttt{\textit{real}}.


\begin{alltt}
(ceiling 19) \(\Rightarrow\) 19
(ceiling 2/3) \(\Rightarrow\) 1
(ceiling -2/3) \(\Rightarrow\) 0
(ceiling 17.3) \(\Rightarrow\) 18.0
(ceiling -17/2) \(\Rightarrow\) -8
\end{alltt}

\begin{description}

\label{objects_s104}\item[procedure] \texttt{(round \textit{real})}



\item[returns] the integer closest to \texttt{\textit{real}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{real}} is exactly between two integers, the closest even integer
is returned.
If \texttt{\textit{real}} is an infinity or NaN, \texttt{round} returns \texttt{\textit{real}}.


\begin{alltt}
(round 19) \(\Rightarrow\) 19
(round 2/3) \(\Rightarrow\) 1
(round -2/3) \(\Rightarrow\) -1
(round 17.3) \(\Rightarrow\) 17.0
(round -17/2) \(\Rightarrow\) -8
(round 2.5) \(\Rightarrow\) 2.0
(round 3.5) \(\Rightarrow\) 4.0
\end{alltt}

\begin{description}

\label{objects_s105}\label{objects_page_abs}
\item[procedure] \texttt{(abs \textit{real})}



\item[returns] the absolute value of \texttt{\textit{real}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{abs} is equivalent to \texttt{(lambda (x) (if (\textless{} x 0) (- x) x))}.
\texttt{abs} and \label{objects_s106}\texttt{magnitude}
(see page \pageref{objects_page_magnitude}) are identical for real inputs.

\begin{alltt}
(abs 1) \(\Rightarrow\) 1
(abs -3/4) \(\Rightarrow\) 3/4
(abs 1.83) \(\Rightarrow\) 1.83
(abs -0.093) \(\Rightarrow\) 0.093
\end{alltt}

\begin{description}

\label{objects_s107}\item[procedure] \texttt{(max \textit{real\textsubscript{1}} \textit{real\textsubscript{2}} ...)}



\item[returns] the maximum of \texttt{\textit{real\textsubscript{1}} \textit{real\textsubscript{2}} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(max 4 -7 2 0 -6) \(\Rightarrow\) 4
(max 1/2 3/4 4/5 5/6 6/7) \(\Rightarrow\) 6/7
(max 1.5 1.3 -0.3 0.4 2.0 1.8) \(\Rightarrow\) 2.0
(max 5 2.0) \(\Rightarrow\) 5.0
(max -5 -2.0) \(\Rightarrow\) -2.0
(let ([ls '(7 3 5 2 9 8)])
  (apply max ls)) \(\Rightarrow\) 9
\end{alltt}

\begin{description}

\label{objects_s108}\item[procedure] \texttt{(min \textit{real\textsubscript{1}} \textit{real\textsubscript{2}} ...)}



\item[returns] the minimum of \texttt{\textit{real\textsubscript{1}} \textit{real\textsubscript{2}} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(min 4 -7 2 0 -6) \(\Rightarrow\) -7
(min 1/2 3/4 4/5 5/6 6/7) \(\Rightarrow\) 1/2
(min 1.5 1.3 -0.3 0.4 2.0 1.8) \(\Rightarrow\) -0.3
(min 5 2.0) \(\Rightarrow\) 2.0
(min -5 -2.0) \(\Rightarrow\) -5.0
(let ([ls '(7 3 5 2 9 8)])
  (apply min ls)) \(\Rightarrow\) 2
\end{alltt}

\begin{description}

\label{objects_s109}\label{objects_page_gcd}
\item[procedure] \texttt{(gcd \textit{int} ...)}



\item[returns] the greatest common divisor of its arguments \texttt{\textit{int} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The result is always nonnegative, i.e., factors of -1 are ignored.
When called with no arguments, \texttt{gcd} returns 0.


\begin{alltt}
(gcd) \(\Rightarrow\) 0
(gcd 34) \(\Rightarrow\) 34
(gcd 33.0 15.0) \(\Rightarrow\) 3.0
(gcd 70 -42 28) \(\Rightarrow\) 14
\end{alltt}

\begin{description}

\label{objects_s110}\item[procedure] \texttt{(lcm \textit{int} ...)}



\item[returns] the least common multiple of its arguments \texttt{\textit{int} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The result is always nonnegative, i.e., common multiples of -1 are
ignored.
Although \texttt{lcm} should probably return \(\infty\) when called with no
arguments, it is defined to return 1.
If one or more of the arguments is 0, \texttt{lcm} returns 0.


\begin{alltt}
(lcm) \(\Rightarrow\) 1
(lcm 34) \(\Rightarrow\) 34
(lcm 33.0 15.0) \(\Rightarrow\) 165.0
(lcm 70 -42 28) \(\Rightarrow\) 420
(lcm 17.0 0) \(\Rightarrow\) 0.0
\end{alltt}

\begin{description}

\label{objects_s111}\item[procedure] \texttt{(expt \textit{num\textsubscript{1}} \textit{num\textsubscript{2}})}



\item[returns] \texttt{\textit{num\textsubscript{1}}} raised to the \texttt{\textit{num\textsubscript{2}}} power


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If both arguments are 0, \texttt{expt} returns 1.


\begin{alltt}
(expt 2 10) \(\Rightarrow\) 1024
(expt 2 -10) \(\Rightarrow\) 1/1024
(expt 2 -10.0) \(\Rightarrow\) 9.765625e-4
(expt -1/2 5) \(\Rightarrow\) -1/32
(expt 3.0 3) \(\Rightarrow\) 27.0
(expt +i 2) \(\Rightarrow\) -1
\end{alltt}

\begin{description}

\label{objects_s112}\item[procedure] \texttt{(inexact \textit{num})}



\item[returns] an inexact representation of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\label{objects_s113}If \texttt{\textit{num}} is already inexact, it is returned unchanged.
If no inexact representation for \texttt{\textit{num}} is supported by the
implementation, an exception with condition type \texttt{\&{}implementation-violation}
may be raised.
\texttt{inexact} may also return \texttt{+inf.0} or \texttt{-inf.0} for inputs
whose magnitude exceeds the range of the implementation's inexact number
representations.


\begin{alltt}
(inexact 3) \(\Rightarrow\) 3.0
(inexact 3.0) \(\Rightarrow\) 3.0
(inexact -1/4) \(\Rightarrow\) -.25
(inexact 3+4i) \(\Rightarrow\) 3.0+4.0i
(inexact (expt 10 20)) \(\Rightarrow\) 1e20
\end{alltt}

\begin{description}

\label{objects_s114}\item[procedure] \texttt{(exact \textit{num})}



\item[returns] an exact representation of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\label{objects_s115}If \texttt{\textit{num}} is already exact, it is returned unchanged.
If no exact representation for \texttt{\textit{num}} is supported by the
implementation, an exception with condition type \texttt{\&{}implementation-violation}
may be raised.


\begin{alltt}
(exact 3.0) \(\Rightarrow\) 3
(exact 3) \(\Rightarrow\) 3
(exact -.25) \(\Rightarrow\) -1/4
(exact 3.0+4.0i) \(\Rightarrow\) 3+4i
(exact 1e20) \(\Rightarrow\) 100000000000000000000
\end{alltt}

\begin{description}

\label{objects_s116}\item[procedure] \texttt{(exact-\textgreater{}inexact \textit{num})}



\item[returns] an inexact representation of \texttt{\textit{num}}


\item[procedure] \texttt{(inexact-\textgreater{}exact \textit{num})}



\item[returns] an exact representation of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs r5rs)}
\end{description}


These are alternative names for \texttt{inexact} and \texttt{exact},
supported for compatibility with the Revised\textsuperscript{5} Report.


\begin{description}

\label{objects_s117}\item[procedure] \texttt{(rationalize \textit{real\textsubscript{1}} \textit{real\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{rationalize}
returns the simplest rational number that differs from
\texttt{\textit{real\textsubscript{1}}} by no more than \texttt{\textit{real\textsubscript{2}}}.
A rational number \textit{q}\textsubscript{1} = \textit{n}\textsubscript{1}/\textit{m}\textsubscript{1} is simpler than another rational
number \textit{q}\textsubscript{2} = \textit{n}\textsubscript{2}/\textit{m}\textsubscript{2} if \textbar{}\textit{n}\textsubscript{1}\textbar{} ≤ \textbar{}\textit{n}\textsubscript{2}\textbar{} and \textbar{}\textit{m}\textsubscript{1}\textbar{} ≤ \textbar{}\textit{m}\textsubscript{2}\textbar{}
and either \textbar{}\textit{n}\textsubscript{1}\textbar{} \textless{} \textbar{}\textit{n}\textsubscript{2}\textbar{} or \textbar{}\textit{m}\textsubscript{1}\textbar{} \textless{} \textbar{}\textit{m}\textsubscript{2}\textbar{}.

\begin{alltt}
(rationalize 3/10 1/10) \(\Rightarrow\) 1/3
(rationalize .3 1/10) \(\Rightarrow\) 0.3333333333333333
(eqv? (rationalize .3 1/10) \#{}i1/3) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s118}\item[procedure] \texttt{(numerator \textit{rat})}



\item[returns] the numerator of \texttt{\textit{rat}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{rat}} is an integer, the numerator is \texttt{\textit{rat}}.


\begin{alltt}
(numerator 9) \(\Rightarrow\) 9
(numerator 9.0) \(\Rightarrow\) 9.0
(numerator 0.0) \(\Rightarrow\) 0.0
(numerator 2/3) \(\Rightarrow\) 2
(numerator -9/4) \(\Rightarrow\) -9
(numerator -2.25) \(\Rightarrow\) -9.0
\end{alltt}

\begin{description}

\label{objects_s119}\item[procedure] \texttt{(denominator \textit{rat})}



\item[returns] the denominator of \texttt{\textit{rat}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{rat}} is an integer, including zero, the denominator is one.


\begin{alltt}
(denominator 9) \(\Rightarrow\) 1
(denominator 9.0) \(\Rightarrow\) 1.0
(denominator 0) \(\Rightarrow\) 1
(denominator 0.0) \(\Rightarrow\) 1.0
(denominator 2/3) \(\Rightarrow\) 3
(denominator -9/4) \(\Rightarrow\) 4
(denominator -2.25) \(\Rightarrow\) 4.0
\end{alltt}

\begin{description}

\label{objects_s120}\item[procedure] \texttt{(real-part \textit{num})}



\item[returns] the real component of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{num}} is real, \texttt{real-part} returns \texttt{\textit{num}}.


\begin{alltt}
(real-part 3+4i) \(\Rightarrow\) 3
(real-part -2.3+0.7i) \(\Rightarrow\) -2.3
(real-part -i) \(\Rightarrow\) 0
(real-part 17.2) \(\Rightarrow\) 17.2
(real-part -17/100) \(\Rightarrow\) -17/100
\end{alltt}

\begin{description}

\label{objects_s121}\item[procedure] \texttt{(imag-part \textit{num})}



\item[returns] the imaginary component of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{num}} is real, \texttt{imag-part} returns exact zero.



\begin{alltt}
(imag-part 3+4i) \(\Rightarrow\) 4
(imag-part -2.3+0.7i) \(\Rightarrow\) 0.7
(imag-part -i) \(\Rightarrow\) -1
(imag-part -2.5) \(\Rightarrow\) 0
(imag-part -17/100) \(\Rightarrow\) 0
\end{alltt}

\begin{description}

\label{objects_s122}\item[procedure] \texttt{(make-rectangular \textit{real\textsubscript{1}} \textit{real\textsubscript{2}})}



\item[returns] a complex number with real component \texttt{\textit{real\textsubscript{1}}} and imaginary
  component \texttt{\textit{real\textsubscript{2}}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(make-rectangular -2 7) \(\Rightarrow\) -2+7i
(make-rectangular 2/3 -1/2) \(\Rightarrow\) 2/3-1/2i
(make-rectangular 3.2 5.3) \(\Rightarrow\) 3.2+5.3i
\end{alltt}

\begin{description}

\label{objects_s123}\item[procedure] \texttt{(make-polar \textit{real\textsubscript{1}} \textit{real\textsubscript{2}})}



\item[returns] a complex number with magnitude \texttt{\textit{real\textsubscript{1}}} and angle
    \texttt{\textit{real\textsubscript{2}}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(make-polar 2 0) \(\Rightarrow\) 2
(make-polar 2.0 0.0) \(\Rightarrow\) 2.0+0.0i
(make-polar 1.0 (asin -1.0)) \(\Rightarrow\) 0.0-1.0i
(eqv? (make-polar 7.2 -0.588) 7.2\@{}-0.588) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s124}\item[procedure] \texttt{(angle \textit{num})}



\item[returns] the angle part of the polar representation of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The range of the result is \(-\pi\) (exclusive) to \(+\pi\) (inclusive).


\begin{alltt}
(angle 7.3\@{}1.5708) \(\Rightarrow\) 1.5708
(angle 5.2) \(\Rightarrow\) 0.0
\end{alltt}

\begin{description}

\label{objects_s125}\label{objects_page_magnitude}
\item[procedure] \texttt{(magnitude \textit{num})}



\item[returns] the magnitude of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{magnitude} and \label{objects_s126}\texttt{abs}
(see page \pageref{objects_page_abs}) are identical for real arguments.
The magnitude of a complex number \textit{x} + \textit{yi} is
\(+\sqrt{x^2+y^2}\).

\begin{alltt}
(magnitude 1) \(\Rightarrow\) 1
(magnitude -3/4) \(\Rightarrow\) 3/4
(magnitude 1.83) \(\Rightarrow\) 1.83
(magnitude -0.093) \(\Rightarrow\) 0.093
(magnitude 3+4i) \(\Rightarrow\) 5
(magnitude 7.25\@{}1.5708) \(\Rightarrow\) 7.25
\end{alltt}

\begin{description}

\label{objects_s127}\item[procedure] \texttt{(sqrt \textit{num})}



\item[returns] the principal square root of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


Implementations are encouraged, but not required, to return exact
results for exact inputs to \texttt{sqrt} whenever feasible.


\begin{alltt}
(sqrt 16) \(\Rightarrow\) 4
(sqrt 1/4) \(\Rightarrow\) 1/2
(sqrt 4.84) \(\Rightarrow\) 2.2
(sqrt -4.84) \(\Rightarrow\) 0.0+2.2i
(sqrt 3+4i) \(\Rightarrow\) 2+1i
(sqrt -3.0-4.0i) \(\Rightarrow\) 1.0-2.0i
\end{alltt}

\begin{description}

\label{objects_s128}\item[procedure] \texttt{(exact-integer-sqrt \textit{n})}



\item[returns] see below


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


This procedure returns two nonnegative exact integers \textit{s} and \textit{r} where
\textit{n} = \textit{s}\textsuperscript{2} + \textit{r} and \textit{n} \textless{} (\textit{s} + 1)\textsuperscript{2}.


\begin{alltt}
(exact-integer-sqrt 0) \(\Rightarrow\) 0
                        0
(exact-integer-sqrt 9) \(\Rightarrow\) 3
                       \(\Rightarrow\) 0
(exact-integer-sqrt 19) \(\Rightarrow\) 4
                        \(\Rightarrow\) 3
\end{alltt}

\begin{description}

\label{objects_s129}\item[procedure] \texttt{(exp \textit{num})}



\item[returns] \textit{e} to the \texttt{\textit{num}} power


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(exp 0.0) \(\Rightarrow\) 1.0
(exp 1.0) \(\Rightarrow\) 2.7182818284590455
(exp -.5) \(\Rightarrow\) 0.6065306597126334
\end{alltt}

\begin{description}

\label{objects_s130}\item[procedure] \texttt{(log \textit{num})}



\item[returns] the natural logarithm of \texttt{\textit{num}}


\item[procedure] \texttt{(log \textit{num\textsubscript{1}} \textit{num\textsubscript{2}})}



\item[returns] the base-\texttt{\textit{num\textsubscript{2}}} logarithm of \texttt{\textit{num\textsubscript{1}}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(log 1.0) \(\Rightarrow\) 0.0
(log (exp 1.0)) \(\Rightarrow\) 1.0
(/ (log 100) (log 10)) \(\Rightarrow\) 2.0
(log (make-polar (exp 2.0) 1.0)) \(\Rightarrow\) 2.0+1.0i

(log 100.0 10.0) \(\Rightarrow\) 2.0
(log .125 2.0) \(\Rightarrow\) -3.0
\end{alltt}

\begin{description}

\label{objects_s131}\item[procedure] \texttt{(sin \textit{num})}



\item[procedure] \texttt{(cos \textit{num})}



\item[procedure] \texttt{(tan \textit{num})}



\item[returns] the sine, cosine, or tangent of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The argument is specified in radians.


\begin{alltt}
(sin 0.0) \(\Rightarrow\) 0.0
(cos 0.0) \(\Rightarrow\) 1.0
(tan 0.0) \(\Rightarrow\) 0.0
\end{alltt}

\begin{description}

\label{objects_s132}\item[procedure] \texttt{(asin \textit{num})}



\item[procedure] \texttt{(acos \textit{num})}



\item[returns] the arc sine or the arc cosine of \texttt{\textit{num}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The result is in radians.
The arc sine and arc cosine of a complex number \textit{z} are defined as follows.


\(\sin^{-1}(x)=-i\log(ix+\sqrt{1-x^2})\)
\(\cos^{-1}(x)=\pi{}/2-\sin^{-1}(x)\)


\begin{alltt}
(define pi (* (asin 1) 2))
(= (* (acos 0) 2) pi) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s133}\item[procedure] \texttt{(atan \textit{num})}



\item[procedure] \texttt{(atan \textit{real\textsubscript{1}} \textit{real\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


When passed a single complex argument \texttt{\textit{num}} (the first form), \texttt{atan}
returns the arc tangent of \texttt{\textit{num}}.
The arc tangent of a complex number \textit{z} is defined as follows.


\(\tan^{-1}(x)=(\log(1+ix)-\log(1-ix))/(2i)\)


When passed two real arguments (the second form), \texttt{atan} is equivalent
to \texttt{(lambda (y x) (angle (make-rectangular x y)))}.


\begin{alltt}
(define pi (* (atan 1) 4))
(= (* (atan 1.0 0.0) 2) pi) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s134}\item[procedure] \texttt{(bitwise-not \textit{exint})}



\item[returns] the bitwise not of \texttt{\textit{exint}}


\item[procedure] \texttt{(bitwise-and \textit{exint} ...)}



\item[returns] the bitwise and of \texttt{\textit{exint} ...}


\item[procedure] \texttt{(bitwise-ior \textit{exint} ...)}



\item[returns] the bitwise inclusive or of \texttt{\textit{exint} ...}


\item[procedure] \texttt{(bitwise-xor \textit{exint} ...)}



\item[returns] the bitwise exclusive or of \texttt{\textit{exint} ...}


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}


The inputs are treated as if represented in two's complement, even
if they are not represented that way internally.


\begin{alltt}
(bitwise-not 0) \(\Rightarrow\) -1
(bitwise-not 3) \(\Rightarrow\) -4

(bitwise-and \#{}b01101 \#{}b00111) \(\Rightarrow\) \#{}b00101
(bitwise-ior \#{}b01101 \#{}b00111) \(\Rightarrow\) \#{}b01111
(bitwise-xor \#{}b01101 \#{}b00111) \(\Rightarrow\) \#{}b01010
\end{alltt}

\begin{description}

\label{objects_s135}\item[procedure] \texttt{(bitwise-if \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}} \textit{exint\textsubscript{3}})}



\item[returns] the bitwise ``if'' of its arguments


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}


The inputs are treated as if represented in two's complement, even
if they are not represented that way internally.


For each bit set in \texttt{\textit{exint\textsubscript{1}}}, the corresponding bit of the result
is taken from \texttt{\textit{exint\textsubscript{2}}}, and for each bit not set in \texttt{\textit{exint\textsubscript{1}}},
the corresponding bit of the result is taken from \texttt{\textit{x\textsubscript{3}}}.


\texttt{(bitwise-if \#{}b101010 \#{}b111000 \#{}b001100) \(\Rightarrow\) \#{}b101100}
\texttt{bitwise-if} might be defined as follows:

\begin{alltt}
(define bitwise-if
  (lambda (exint1 exint2 exint3)
    (bitwise-ior
      (bitwise-and exint1 exint2)
      (bitwise-and (bitwise-not exint1) exint3))))
\end{alltt}

\begin{description}

\label{objects_s136}\item[procedure] \texttt{(bitwise-bit-count \textit{exint})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}


For nonnegative inputs, \texttt{bitwise-bit-count} returns the number of bits
set in the two's complement representation of \texttt{\textit{exint}}.
For negative inputs, it returns a negative number whose magnitude is one
greater than the number of bits not set in the two's complement
representation of \texttt{\textit{exint}}, which is equivalent to
\texttt{(bitwise-not (bitwise-bit-count (bitwise-not \textit{exint})))}.


\begin{alltt}
(bitwise-bit-count \#{}b00000) \(\Rightarrow\) 0
(bitwise-bit-count \#{}b00001) \(\Rightarrow\) 1
(bitwise-bit-count \#{}b00100) \(\Rightarrow\) 1
(bitwise-bit-count \#{}b10101) \(\Rightarrow\) 3

(bitwise-bit-count -1) \(\Rightarrow\) -1
(bitwise-bit-count -2) \(\Rightarrow\) -2
(bitwise-bit-count -4) \(\Rightarrow\) -3
\end{alltt}

\begin{description}

\label{objects_s137}\item[procedure] \texttt{(bitwise-length \textit{exint})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}


This procedure returns the number of bits of the smallest two's
complement representation of \texttt{\textit{exint}}, not including the sign
bit for negative numbers.
For 0 \texttt{bitwise-length} returns 0.


\begin{alltt}
(bitwise-length \#{}b00000) \(\Rightarrow\) 0
(bitwise-length \#{}b00001) \(\Rightarrow\) 1
(bitwise-length \#{}b00100) \(\Rightarrow\) 3
(bitwise-length \#{}b00110) \(\Rightarrow\) 3

(bitwise-length -1) \(\Rightarrow\) 0
(bitwise-length -6) \(\Rightarrow\) 3
(bitwise-length -9) \(\Rightarrow\) 4
\end{alltt}

\begin{description}

\label{objects_s138}\item[procedure] \texttt{(bitwise-first-bit-set \textit{exint})}



\item[returns] the index of the least significant bit set in \texttt{\textit{exint}}


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}


The input is treated as if represented in two's complement, even
if it is not represented that way internally.


If \texttt{\textit{exint}} is 0, \texttt{bitwise-first-bit-set} returns -1.


\begin{alltt}
(bitwise-first-bit-set \#{}b00000) \(\Rightarrow\) -1
(bitwise-first-bit-set \#{}b00001) \(\Rightarrow\) 0
(bitwise-first-bit-set \#{}b01100) \(\Rightarrow\) 2

(bitwise-first-bit-set -1) \(\Rightarrow\) 0
(bitwise-first-bit-set -2) \(\Rightarrow\) 1
(bitwise-first-bit-set -3) \(\Rightarrow\) 0
\end{alltt}

\begin{description}

\label{objects_s139}\item[procedure] \texttt{(bitwise-bit-set? \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if bit \texttt{\textit{exint\textsubscript{2}}} of \texttt{\textit{exint\textsubscript{1}}} is set, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{exint\textsubscript{2}}} is taken as a zero-based index for the bits
in the two's complement representation of \texttt{\textit{exint\textsubscript{1}}}.
The two's complement representation of a nonnegative number conceptually extends
to the left (toward more significant bits) with an infinite number of zero bits, and
the two's complement representation of a negative number conceptually extends
to the left with an infinite number of one bits.
Thus, exact integers can be used to represent arbitrarily large sets, where 0 is the
empty set, -1 is the universe, and \texttt{bitwise-bit-set?} is used to test for
membership.

\begin{alltt}
(bitwise-bit-set? \#{}b01011 0) \(\Rightarrow\) \#{}t
(bitwise-bit-set? \#{}b01011 2) \(\Rightarrow\) \#{}f

(bitwise-bit-set? -1 0) \(\Rightarrow\) \#{}t
(bitwise-bit-set? -1 20) \(\Rightarrow\) \#{}t
(bitwise-bit-set? -3 1) \(\Rightarrow\) \#{}f

(bitwise-bit-set? 0 5000) \(\Rightarrow\) \#{}f
(bitwise-bit-set? -1 5000) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s140}\item[procedure] \texttt{(bitwise-copy-bit \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}} \textit{exint\textsubscript{3}})}



\item[returns] \texttt{\textit{exint\textsubscript{1}}} with bit \texttt{\textit{exint\textsubscript{2}}} replaced by \texttt{\textit{exint\textsubscript{3}}}


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{exint\textsubscript{2}}} is taken as a zero-based index for the bits
in the two's complement representation of \texttt{\textit{exint\textsubscript{1}}}.
\texttt{\textit{exint\textsubscript{3}}} must be 0 or 1.
This procedure effectively clears or sets the specified bit depending
on the value of \texttt{\textit{exint\textsubscript{3}}}.
\texttt{\textit{exint\textsubscript{1}}} is treated as if represented in two's complement, even
if it is not represented that way internally.

\begin{alltt}
(bitwise-copy-bit \#{}b01110 0 1) \(\Rightarrow\) \#{}b01111
(bitwise-copy-bit \#{}b01110 2 0) \(\Rightarrow\) \#{}b01010
\end{alltt}

\begin{description}

\label{objects_s141}\item[procedure] \texttt{(bitwise-bit-field \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}} \textit{exint\textsubscript{3}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{exint\textsubscript{2}}} and \texttt{\textit{exint\textsubscript{3}}} must be nonnegative,
and \texttt{\textit{exint\textsubscript{2}}} must not be greater than \texttt{\textit{exint\textsubscript{3}}}.
This procedure returns the number represented by extracting from \texttt{\textit{exint\textsubscript{1}}}
the sequence of bits from \texttt{\textit{exint\textsubscript{2}}} (inclusive) to \texttt{\textit{exint\textsubscript{3}}} (exclusive).
\texttt{\textit{exint\textsubscript{1}}} is treated as if represented in two's complement, even
if it is not represented that way internally.

\begin{alltt}
(bitwise-bit-field \#{}b10110 0 3) \(\Rightarrow\) \#{}b00110
(bitwise-bit-field \#{}b10110 1 3) \(\Rightarrow\) \#{}b00011
(bitwise-bit-field \#{}b10110 2 3) \(\Rightarrow\) \#{}b00001
(bitwise-bit-field \#{}b10110 3 3) \(\Rightarrow\) \#{}b00000
\end{alltt}

\begin{description}

\label{objects_s142}\item[procedure] \texttt{(bitwise-copy-bit-field \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}} \textit{exint\textsubscript{3}} \textit{exint\textsubscript{4}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{exint\textsubscript{2}}} and \texttt{\textit{exint\textsubscript{3}}} must be nonnegative, and \texttt{\textit{exint\textsubscript{2}}}
must not be greater than \texttt{\textit{exint\textsubscript{3}}}.
This procedure returns \texttt{\textit{exint\textsubscript{1}}} with the \texttt{\textit{n}} bits from \texttt{\textit{exint\textsubscript{2}}} (inclusive) to
\texttt{\textit{exint\textsubscript{3}}} (exclusive) replaced by the low-order \texttt{\textit{n}} bits of \texttt{\textit{exint\textsubscript{4}}}.
\texttt{\textit{exint\textsubscript{1}}} and \texttt{\textit{exint\textsubscript{4}}} are treated as if represented in two's complement, even
if they are not represented that way internally.

\begin{alltt}
(bitwise-copy-bit-field \#{}b10000 0 3 \#{}b10101) \(\Rightarrow\) \#{}b10101
(bitwise-copy-bit-field \#{}b10000 1 3 \#{}b10101) \(\Rightarrow\) \#{}b10010
(bitwise-copy-bit-field \#{}b10000 2 3 \#{}b10101) \(\Rightarrow\) \#{}b10100
(bitwise-copy-bit-field \#{}b10000 3 3 \#{}b10101) \(\Rightarrow\) \#{}b10000
\end{alltt}

\begin{description}

\label{objects_s143}\item[procedure] \texttt{(bitwise-arithmetic-shift-right \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}})}



\item[returns] \texttt{\textit{exint\textsubscript{1}}} arithmetically shifted right by \texttt{\textit{exint\textsubscript{2}}} bits


\item[procedure] \texttt{(bitwise-arithmetic-shift-left \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}})}



\item[returns] \texttt{\textit{exint\textsubscript{1}}} shifted left by \texttt{\textit{exint\textsubscript{2}}} bits


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{exint\textsubscript{2}}} must be nonnegative.
\texttt{\textit{exint\textsubscript{1}}} is treated as if represented in two's complement, even
if it is not represented that way internally.

\begin{alltt}
(bitwise-arithmetic-shift-right \#{}b10000 3) \(\Rightarrow\) \#{}b00010
(bitwise-arithmetic-shift-right -1 1) \(\Rightarrow\) -1
(bitwise-arithmetic-shift-right -64 3) \(\Rightarrow\) -8

(bitwise-arithmetic-shift-left \#{}b00010 2) \(\Rightarrow\) \#{}b01000
(bitwise-arithmetic-shift-left -1 2) \(\Rightarrow\) -4
\end{alltt}

\begin{description}

\label{objects_s144}\item[procedure] \texttt{(bitwise-arithmetic-shift \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{exint\textsubscript{2}}} is negative, \texttt{bitwise-arithmetic-shift} returns the
result of arithmetically shifting \texttt{\textit{exint\textsubscript{1}}} right by \texttt{\textit{exint\textsubscript{2}}} bits.
Otherwise, \texttt{bitwise-arithmetic-shift} returns the
result of shifting \texttt{\textit{exint\textsubscript{1}}} left by \texttt{\textit{exint\textsubscript{2}}} bits.
\texttt{\textit{exint\textsubscript{1}}} is treated as if represented in two's complement, even
if it is not represented that way internally.


\begin{alltt}
(bitwise-arithmetic-shift \#{}b10000 -3) \(\Rightarrow\) \#{}b00010
(bitwise-arithmetic-shift -1 -1) \(\Rightarrow\) -1
(bitwise-arithmetic-shift -64 -3) \(\Rightarrow\) -8
(bitwise-arithmetic-shift \#{}b00010 2) \(\Rightarrow\) \#{}b01000
(bitwise-arithmetic-shift -1 2) \(\Rightarrow\) -4
\end{alltt}


Thus, \texttt{bitwise-arithmetic-shift} behaves as if defined as follows.


\begin{alltt}
(define bitwise-arithmetic-shift
  (lambda (exint1 exint2)
    (if (\textless{} exint2 0)
        (bitwise-arithmetic-shift-right exint1 (- exint2))
        (bitwise-arithmetic-shift-left exint1 exint2))))
\end{alltt}

\begin{description}

\label{objects_s145}\item[procedure] \texttt{(bitwise-rotate-bit-field \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}} \textit{exint\textsubscript{3}} \textit{exint\textsubscript{4}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{exint\textsubscript{2}}}, \texttt{\textit{exint\textsubscript{3}}}, and \texttt{\textit{exint\textsubscript{4}}} must be nonnegative,
and \texttt{\textit{exint\textsubscript{2}}} must not be greater than \texttt{\textit{exint\textsubscript{3}}}.
This procedure returns the result of shifting the bits of
\texttt{\textit{exint\textsubscript{1}}} from bit \texttt{\textit{exint\textsubscript{2}}} (inclusive) through bit \texttt{\textit{exint\textsubscript{3}}} (exclusive)
left by \texttt{(mod \textit{exint\textsubscript{4}} (- \textit{exint\textsubscript{3}} \textit{exint\textsubscript{2}}))} bits,
with the bits shifted out of the range inserted
at the bottom end of the range.
\texttt{\textit{exint\textsubscript{1}}} is treated as if represented in two's complement, even
if it is not represented that way internally.

\begin{alltt}
(bitwise-rotate-bit-field \#{}b00011010 0 5 3) \(\Rightarrow\) \#{}b00010110
(bitwise-rotate-bit-field \#{}b01101011 2 7 3) \(\Rightarrow\) \#{}b01011011
\end{alltt}

\begin{description}

\label{objects_s146}\item[procedure] \texttt{(bitwise-reverse-bit-field \textit{exint\textsubscript{1}} \textit{exint\textsubscript{2}} \textit{exint\textsubscript{3}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic bitwise)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{exint\textsubscript{2}}} and \texttt{\textit{exint\textsubscript{3}}} must be nonnegative, and \texttt{\textit{exint\textsubscript{2}}}
must not be greater than \texttt{\textit{exint\textsubscript{3}}}.
This procedure returns the result of reversing the bits of
\texttt{\textit{exint\textsubscript{1}}} from bit \texttt{\textit{exint\textsubscript{2}}} (inclusive) through bit \texttt{\textit{exint\textsubscript{3}}} (exclusive).
\texttt{\textit{exint\textsubscript{1}}} is treated as if represented in two's complement, even
if it is not represented that way internally.

\begin{alltt}
(bitwise-reverse-bit-field \#{}b00011010 0 5) \(\Rightarrow\) \#{}b00001011
(bitwise-reverse-bit-field \#{}b01101011 2 7) \(\Rightarrow\) \#{}b00101111
\end{alltt}

\begin{description}

\label{objects_s147}\item[procedure] \texttt{(string-\textgreater{}number \textit{string})}



\item[procedure] \texttt{(string-\textgreater{}number \textit{string} \textit{radix})}



\item[returns] the number represented by \texttt{\textit{string}}, or \texttt{\#{}f}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{string}} is a valid representation of a number, that
number is returned, otherwise \texttt{\#{}f} is returned.
The number is interpreted in radix \texttt{\textit{radix}}, which must be an
exact integer in the set \{2,8,10,16\}.
If not specified, \texttt{\textit{radix}} defaults to 10.
Any radix specifier within \texttt{\textit{string}}, e.g., \texttt{\#{}x}, overrides the
\texttt{\textit{radix}} argument.


\begin{alltt}
(string-\textgreater{}number "0") \(\Rightarrow\) 0
(string-\textgreater{}number "3.4e3") \(\Rightarrow\) 3400.0
(string-\textgreater{}number "\#{}x\#{}e-2e2") \(\Rightarrow\) -738
(string-\textgreater{}number "\#{}e-2e2" 16) \(\Rightarrow\) -738
(string-\textgreater{}number "\#{}i15/16") \(\Rightarrow\) 0.9375
(string-\textgreater{}number "10" 16) \(\Rightarrow\) 16
\end{alltt}

\begin{description}

\label{objects_s148}\item[procedure] \texttt{(number-\textgreater{}string \textit{num})}



\item[procedure] \texttt{(number-\textgreater{}string \textit{num} \textit{radix})}



\item[procedure] \texttt{(number-\textgreater{}string \textit{num} \textit{radix} \textit{precision})}



\item[returns] an external representation of \texttt{\textit{num}} as a string


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The num is expressed in radix \texttt{\textit{radix}}, which must be an
exact integer in the set \{2,8,10,16\}.
If not specified, \texttt{\textit{radix}} defaults to 10.
In any case, no radix specifier appears in the resulting string.


The external representation is such that, when converted back into
a number using \texttt{string-\textgreater{}number}, the resulting numeric value is equivalent
to \texttt{\textit{num}}.
That is, for all inputs:


\begin{alltt}
(eqv? (string-\textgreater{}number
        (number-\textgreater{}string \textit{num} \textit{radix})
        \textit{radix})
      \textit{num})
\end{alltt}


returns \texttt{\#{}t}.
An exception with condition type
\texttt{\&{}implementation-restriction} is raised if this
is not possible.


If \texttt{\textit{precision}} is provided, it must be an exact positive integer,
\texttt{\textit{num}} must be inexact, and \texttt{\textit{radix}} must be 10.
In this case, the real part and, if present, the imaginary part of
the number are each printed with an explicit mantissa width \texttt{\textit{m}}, where
\texttt{\textit{m}} is the least possible value greater than or equal to
\texttt{\textit{precision}} that makes the expression above true.


If \texttt{\textit{radix}} is 10, inexact values of \texttt{\textit{num}} are expressed using the
fewest number of significant digits possible [\hyperref[bibliography_g223]{5}]
without violating the above restriction.


\begin{alltt}
(number-\textgreater{}string 3.4) \(\Rightarrow\) "3.4"
(number-\textgreater{}string 1e2) \(\Rightarrow\) "100.0"
(number-\textgreater{}string 1e-23) \(\Rightarrow\) "1e-23"
(number-\textgreater{}string -7/2) \(\Rightarrow\) "-7/2"
(number-\textgreater{}string 220/9 16) \(\Rightarrow\) "DC/9"
\end{alltt}

\section{\label{objects_g111}\label{objects_h5}Fixnums\label{objects_SECTFIXNUMS}}



\label{objects_s149}\textit{Fixnums} represent exact integers in the fixnum range, which is
required to be a closed range [-2\textsuperscript{\textit{w}-1},2\textsuperscript{\textit{w}-2} - 1], where \textit{w} (the
\textit{fixnum width}) is at least 24.
The implementation-specific value of \textit{w} may be determined via the
procedure \texttt{fixnum-width}, and the endpoints of the range may
be determined via the procedures \texttt{least-fixnum} and
\texttt{greatest-fixnum}.


The names of arithmetic procedures that operate only on fixnums
begin with the prefix "\texttt{fx}" to set them apart from their generic
counterparts.


Procedure arguments required to be fixnums are named \texttt{\textit{fx}}, possibly
with a suffix, e.g., \texttt{\textit{fx\textsubscript{2}}}.


Unless otherwise specified, the numeric values of fixnum-specific
procedures are fixnums.
If the value of a fixnum operation should be a fixnum, but the
mathematical result would be outside the fixnum range, an exception
with condition type \texttt{\&{}implementation-restriction} is raised.


Bit and shift operations on fixnums assume that fixnums are represented in
two's complement, even if they are not represented that way internally.

\begin{description}

\label{objects_s150}\item[procedure] \texttt{(fixnum? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a fixnum, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(fixnum? 0) \(\Rightarrow\) \#{}t
(fixnum? -1) \(\Rightarrow\) \#{}t
(fixnum? (- (expt 2 23))) \(\Rightarrow\) \#{}t
(fixnum? (- (expt 2 23) 1)) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s151}\item[procedure] \texttt{(least-fixnum)}



\item[returns] the least (most negative) fixnum supported by the implementation


\item[procedure] \texttt{(greatest-fixnum)}



\item[returns] the greatest (most positive) fixnum supported by the implementation


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(fixnum? (- (least-fixnum) 1)) \(\Rightarrow\) \#{}f
(fixnum? (least-fixnum)) \(\Rightarrow\) \#{}t
(fixnum? (greatest-fixnum)) \(\Rightarrow\) \#{}t
(fixnum? (+ (greatest-fixnum) 1)) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s152}\item[procedure] \texttt{(fixnum-width)}



\item[returns] the implementation-dependent \textit{fixnum width}


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


As described in the lead-in to this section, the fixnum width determines
the size of the fixnum range and must be at least 24.


\begin{alltt}
(define w (fixnum-width))
(= (least-fixnum) (- (expt 2 (- w 1)))) \(\Rightarrow\) \#{}t
(= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) \(\Rightarrow\) \#{}t
(\textgreater{}= w 24) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s153}\item[procedure] \texttt{(fx=? \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}} ...)}



\item[procedure] \texttt{(fx\textless{}? \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}} ...)}



\item[procedure] \texttt{(fx\textgreater{}? \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}} ...)}



\item[procedure] \texttt{(fx\textless{}=? \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}} ...)}



\item[procedure] \texttt{(fx\textgreater{}=? \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}} ...)}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


The predicate \texttt{fx=?} returns \texttt{\#{}t} if its arguments are equal.
The predicate \texttt{fx\textless{}?} returns \texttt{\#{}t} if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while \texttt{fx\textgreater{}?} returns \texttt{\#{}t} if its arguments are monotonically decreasing.
The predicate \texttt{fx\textless{}=?} returns \texttt{\#{}t} if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while \texttt{fx\textgreater{}=?} returns \texttt{\#{}t} if its arguments are monotonically nonincreasing.


\begin{alltt}
(fx=? 0 0) \(\Rightarrow\) \#{}t
(fx=? -1 1) \(\Rightarrow\) \#{}f
(fx\textless{}? (least-fixnum) 0 (greatest-fixnum)) \(\Rightarrow\) \#{}t
(let ([x 3]) (fx\textless{}=? 0 x 9)) \(\Rightarrow\) \#{}t
(fx\textgreater{}? 5 4 3 2 1) \(\Rightarrow\) \#{}t
(fx\textless{}=? 1 3 2) \(\Rightarrow\) \#{}f
(fx\textgreater{}=? 0 0 (least-fixnum)) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s154}\item[procedure] \texttt{(fxzero? \textit{fx})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fx}} is zero, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(fxpositive? \textit{fx})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fx}} is greater than zero, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(fxnegative? \textit{fx})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fx}} is less than zero, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{fxzero?} is equivalent to \texttt{(lambda (x) (fx=? x 0))},
\texttt{fxpositive?} is equivalent to \texttt{(lambda (x) (fx\textgreater{}? x 0))}, and
\texttt{fxnegative?} to \texttt{(lambda (x) (fx\textless{}? x 0))}.


\begin{alltt}
(fxzero? 0) \(\Rightarrow\) \#{}t
(fxzero? 1) \(\Rightarrow\) \#{}f

(fxpositive? 128) \(\Rightarrow\) \#{}t
(fxpositive? 0) \(\Rightarrow\) \#{}f
(fxpositive? -1) \(\Rightarrow\) \#{}f

(fxnegative? -65) \(\Rightarrow\) \#{}t
(fxnegative? 0) \(\Rightarrow\) \#{}f
(fxnegative? 1) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s155}\item[procedure] \texttt{(fxeven? \textit{fx})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fx}} is even, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(fxodd? \textit{fx})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fx}} is odd, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(fxeven? 0) \(\Rightarrow\) \#{}t
(fxeven? 1) \(\Rightarrow\) \#{}f
(fxeven? -1) \(\Rightarrow\) \#{}f
(fxeven? -10) \(\Rightarrow\) \#{}t

(fxodd? 0) \(\Rightarrow\) \#{}f
(fxodd? 1) \(\Rightarrow\) \#{}t
(fxodd? -1) \(\Rightarrow\) \#{}t
(fxodd? -10) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s156}\item[procedure] \texttt{(fxmin \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} ...)}



\item[returns] the minimum of \texttt{\textit{fx\textsubscript{1}}} \texttt{\textit{fx\textsubscript{2}}} ... 

\item[procedure] \texttt{(fxmax \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} ...)}



\item[returns] the maximum of \texttt{\textit{fx\textsubscript{1}}} \texttt{\textit{fx\textsubscript{2}}} ...

\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(fxmin 4 -7 2 0 -6) \(\Rightarrow\) -7

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmin ls)) \(\Rightarrow\) 2

(fxmax 4 -7 2 0 -6) \(\Rightarrow\) 4

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmax ls)) \(\Rightarrow\) 9
\end{alltt}

\begin{description}

\label{objects_s157}\item[procedure] \texttt{(fx+ \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] the sum of \texttt{\textit{fx\textsubscript{1}}} and \texttt{\textit{fx\textsubscript{2}}}


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\texttt{
(fx+ -3 4) \(\Rightarrow\) 1}
\begin{description}
\label{objects_s158}\item[procedure] \texttt{(fx- \textit{fx})}



\item[returns] the additive inverse of \texttt{\textit{fx}}


\item[procedure] \texttt{(fx- \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] the difference between \texttt{\textit{fx\textsubscript{1}}} and \texttt{\textit{fx\textsubscript{2}}}


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(fx- 3) \(\Rightarrow\) -3
(fx- -3 4) \(\Rightarrow\) -7
\end{alltt}

\begin{description}

\label{objects_s159}\item[procedure] \texttt{(fx* \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] the product of \texttt{\textit{fx\textsubscript{1}}} and \texttt{\textit{fx\textsubscript{2}}}


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\texttt{
(fx* -3 4) \(\Rightarrow\) -12}
\begin{description}
\label{objects_s160}\item[procedure] \texttt{(fxdiv \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[procedure] \texttt{(fxmod \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[procedure] \texttt{(fxdiv-and-mod \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} must not be zero.
These are fixnum-specific versions of the generic \texttt{div},
\texttt{mod}, and \texttt{div-and-mod}.

\begin{alltt}
(fxdiv 17 3) \(\Rightarrow\) 5
(fxmod 17 3) \(\Rightarrow\) 2
(fxdiv -17 3) \(\Rightarrow\) -6
(fxmod -17 3) \(\Rightarrow\) 1
(fxdiv 17 -3) \(\Rightarrow\) -5
(fxmod 17 -3) \(\Rightarrow\) 2
(fxdiv -17 -3) \(\Rightarrow\) 6
(fxmod -17 -3) \(\Rightarrow\) 1

(fxdiv-and-mod 17 3) \(\Rightarrow\) 5
                      2
\end{alltt}

\begin{description}

\label{objects_s161}\item[procedure] \texttt{(fxdiv0 \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[procedure] \texttt{(fxmod0 \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[procedure] \texttt{(fxdiv0-and-mod0 \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} must not be zero.
These are fixnum-specific versions of the generic \texttt{div0},
\texttt{mod0}, and \texttt{div0-and-mod0}.

\begin{alltt}
(fxdiv0 17 3) \(\Rightarrow\) 6
(fxmod0 17 3) \(\Rightarrow\) -1
(fxdiv0 -17 3) \(\Rightarrow\) -6
(fxmod0 -17 3) \(\Rightarrow\) 1
(fxdiv0 17 -3) \(\Rightarrow\) -6
(fxmod0 17 -3) \(\Rightarrow\) -1
(fxdiv0 -17 -3) \(\Rightarrow\) 6
(fxmod0 -17 -3) \(\Rightarrow\) 1

(fxdiv0-and-mod0 17 3) \(\Rightarrow\) 6
                        -1
\end{alltt}

\begin{description}

\label{objects_s162}\item[procedure] \texttt{(fx+/carry \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})}



\item[procedure] \texttt{(fx-/carry \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})}



\item[procedure] \texttt{(fx*/carry \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


When an ordinary fixnum addition, subtraction, or multiplication operation
overflows, an exception is raised.
These alternative procedures instead return a carry and also allow the
carry to be propagated to the next operation.
They can be used to implement portable
code for multiple-precision arithmetic.


These procedures return the two
fixnum values of the following computations.
For \texttt{fx+/carry}:


\begin{alltt}
(let* ([s (+ \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))
\end{alltt}


for \texttt{fx-/carry}:


\begin{alltt}
(let* ([d (- \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})]
       [d0 (mod0 d (expt 2 (fixnum-width)))]
       [d1 (div0 d (expt 2 (fixnum-width)))])
  (values d0 d1))
\end{alltt}


and for \texttt{fx*/carry}:


\begin{alltt}
(let* ([s (+ (* \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}}) \textit{fx\textsubscript{3}})]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))
\end{alltt}

\begin{description}

\label{objects_s163}\item[procedure] \texttt{(fxnot \textit{fx})}



\item[returns] the bitwise not of \texttt{\textit{fx}}


\item[procedure] \texttt{(fxand \textit{fx} ...)}



\item[returns] the bitwise and of \texttt{\textit{fx} ...}


\item[procedure] \texttt{(fxior \textit{fx} ...)}



\item[returns] the bitwise inclusive or of \texttt{\textit{fx} ...}


\item[procedure] \texttt{(fxxor \textit{fx} ...)}



\item[returns] the bitwise exclusive or of \texttt{\textit{fx} ...}


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(fxnot 0) \(\Rightarrow\) -1
(fxnot 3) \(\Rightarrow\) -4

(fxand \#{}b01101 \#{}b00111) \(\Rightarrow\) \#{}b00101
(fxior \#{}b01101 \#{}b00111) \(\Rightarrow\) \#{}b01111
(fxxor \#{}b01101 \#{}b00111) \(\Rightarrow\) \#{}b01010
\end{alltt}

\begin{description}

\label{objects_s164}\item[procedure] \texttt{(fxif \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})}



\item[returns] the bitwise ``if'' of its arguments


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


For each bit set in \texttt{\textit{fx\textsubscript{1}}}, the corresponding bit of the result
is taken from \texttt{\textit{fx\textsubscript{2}}}, and for each bit not set in \texttt{\textit{fx\textsubscript{1}}},
the corresponding bit of the result is taken from \texttt{\textit{x\textsubscript{3}}}.


\texttt{(fxif \#{}b101010 \#{}b111000 \#{}b001100) \(\Rightarrow\) \#{}b101100}
\texttt{fxif} might be defined as follows:

\begin{alltt}
(define fxif
  (lambda (fx1 fx2 fx3)
    (fxior (fxand fx1 fx2)
           (fxand (fxnot fx1) fx3))))
\end{alltt}

\begin{description}

\label{objects_s165}\item[procedure] \texttt{(fxbit-count \textit{fx})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


For nonnegative inputs, \texttt{fxbit-count} returns the number of bits
set in the two's complement representation of \texttt{\textit{fx}}.
For negative inputs, it returns a negative number whose magnitude is one
greater than the number of bits not set in \texttt{\textit{fx}}, which is equivalent to
\texttt{(fxnot (fxbit-count (fxnot \textit{fx})))}.


\begin{alltt}
(fxbit-count \#{}b00000) \(\Rightarrow\) 0
(fxbit-count \#{}b00001) \(\Rightarrow\) 1
(fxbit-count \#{}b00100) \(\Rightarrow\) 1
(fxbit-count \#{}b10101) \(\Rightarrow\) 3

(fxbit-count -1) \(\Rightarrow\) -1
(fxbit-count -2) \(\Rightarrow\) -2
(fxbit-count -4) \(\Rightarrow\) -3
\end{alltt}

\begin{description}

\label{objects_s166}\item[procedure] \texttt{(fxlength \textit{fx})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


This procedure returns the number of bits of the smallest two's
complement representation of \texttt{\textit{fx}}, not including the sign
bit for negative numbers.
For 0 \texttt{fxlength} returns 0.


\begin{alltt}
(fxlength \#{}b00000) \(\Rightarrow\) 0
(fxlength \#{}b00001) \(\Rightarrow\) 1
(fxlength \#{}b00100) \(\Rightarrow\) 3
(fxlength \#{}b00110) \(\Rightarrow\) 3

(fxlength -1) \(\Rightarrow\) 0
(fxlength -6) \(\Rightarrow\) 3
(fxlength -9) \(\Rightarrow\) 4
\end{alltt}

\begin{description}

\label{objects_s167}\item[procedure] \texttt{(fxfirst-bit-set \textit{fx})}



\item[returns] the index of the least significant bit set in \texttt{\textit{fx}}


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{fx}} is 0, \texttt{fxfirst-bit-set} returns -1.


\begin{alltt}
(fxfirst-bit-set \#{}b00000) \(\Rightarrow\) -1
(fxfirst-bit-set \#{}b00001) \(\Rightarrow\) 0
(fxfirst-bit-set \#{}b01100) \(\Rightarrow\) 2

(fxfirst-bit-set -1) \(\Rightarrow\) 0
(fxfirst-bit-set -2) \(\Rightarrow\) 1
(fxfirst-bit-set -3) \(\Rightarrow\) 0
\end{alltt}

\begin{description}

\label{objects_s168}\item[procedure] \texttt{(fxbit-set? \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if bit \texttt{\textit{fx\textsubscript{2}}} of \texttt{\textit{fx\textsubscript{1}}} is set, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} must be nonnegative.
It is taken as a zero-based index for the bits
in the two's complement representation of \texttt{\textit{fx\textsubscript{1}}}, with the sign
bit virtually replicated an infinite number of positions to the left.

\begin{alltt}
(fxbit-set? \#{}b01011 0) \(\Rightarrow\) \#{}t
(fxbit-set? \#{}b01011 2) \(\Rightarrow\) \#{}f

(fxbit-set? -1 0) \(\Rightarrow\) \#{}t
(fxbit-set? -1 20) \(\Rightarrow\) \#{}t
(fxbit-set? -3 1) \(\Rightarrow\) \#{}f
(fxbit-set? 0 (- (fixnum-width) 1)) \(\Rightarrow\) \#{}f
(fxbit-set? -1 (- (fixnum-width) 1)) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s169}\item[procedure] \texttt{(fxcopy-bit \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})}



\item[returns] \texttt{\textit{fx\textsubscript{1}}} with bit \texttt{\textit{fx\textsubscript{2}}} replaced by \texttt{\textit{fx\textsubscript{3}}}


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} must be nonnegative and less than the value of
\texttt{(- (fixnum-width) 1)}.
\texttt{\textit{fx\textsubscript{3}}} must be 0 or 1.
This procedure effectively clears or sets the specified bit depending
on the value of \texttt{\textit{fx\textsubscript{3}}}.

\begin{alltt}
(fxcopy-bit \#{}b01110 0 1) \(\Rightarrow\) \#{}b01111
(fxcopy-bit \#{}b01110 2 0) \(\Rightarrow\) \#{}b01010
\end{alltt}

\begin{description}

\label{objects_s170}\item[procedure] \texttt{(fxbit-field \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} and \texttt{\textit{fx\textsubscript{3}}} must be nonnegative and less than the value of
\texttt{(fixnum-width)}, and \texttt{\textit{fx\textsubscript{2}}} must not be greater than \texttt{\textit{fx\textsubscript{3}}}.
This procedure returns the number represented by extracting from \texttt{\textit{fx\textsubscript{1}}}
the sequence of bits from \texttt{\textit{fx\textsubscript{2}}} (inclusive) to \texttt{\textit{fx\textsubscript{3}}} (exclusive).

\begin{alltt}
(fxbit-field \#{}b10110 0 3) \(\Rightarrow\) \#{}b00110
(fxbit-field \#{}b10110 1 3) \(\Rightarrow\) \#{}b00011
(fxbit-field \#{}b10110 2 3) \(\Rightarrow\) \#{}b00001
(fxbit-field \#{}b10110 3 3) \(\Rightarrow\) \#{}b00000
\end{alltt}

\begin{description}

\label{objects_s171}\item[procedure] \texttt{(fxcopy-bit-field \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}} \textit{fx\textsubscript{4}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} and \texttt{\textit{fx\textsubscript{3}}} must be nonnegative and less than the value of
\texttt{(fixnum-width)}, and \texttt{\textit{fx\textsubscript{2}}} must not be greater than \texttt{\textit{fx\textsubscript{3}}}.
This procedure returns \texttt{\textit{fx\textsubscript{1}}} with \texttt{\textit{n}} bits from \texttt{\textit{fx\textsubscript{2}}} (inclusive) to
\texttt{\textit{fx\textsubscript{3}}} (exclusive) replaced by the low-order \texttt{\textit{n}} bits of \texttt{\textit{x\textsubscript{4}}}.

\begin{alltt}
(fxcopy-bit-field \#{}b10000 0 3 \#{}b10101) \(\Rightarrow\) \#{}b10101
(fxcopy-bit-field \#{}b10000 1 3 \#{}b10101) \(\Rightarrow\) \#{}b10010
(fxcopy-bit-field \#{}b10000 2 3 \#{}b10101) \(\Rightarrow\) \#{}b10100
(fxcopy-bit-field \#{}b10000 3 3 \#{}b10101) \(\Rightarrow\) \#{}b10000
\end{alltt}

\begin{description}

\label{objects_s172}\item[procedure] \texttt{(fxarithmetic-shift-right \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] \texttt{\textit{fx\textsubscript{1}}} arithmetically shifted right by \texttt{\textit{fx\textsubscript{2}}} bits


\item[procedure] \texttt{(fxarithmetic-shift-left \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] \texttt{\textit{fx\textsubscript{1}}} shifted left by \texttt{\textit{fx\textsubscript{2}}} bits


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} must be nonnegative and less than the value of
\texttt{(fixnum-width)}.

\begin{alltt}
(fxarithmetic-shift-right \#{}b10000 3) \(\Rightarrow\) \#{}b00010
(fxarithmetic-shift-right -1 1) \(\Rightarrow\) -1
(fxarithmetic-shift-right -64 3) \(\Rightarrow\) -8

(fxarithmetic-shift-left \#{}b00010 2) \(\Rightarrow\) \#{}b01000
(fxarithmetic-shift-left -1 2) \(\Rightarrow\) -4
\end{alltt}

\begin{description}

\label{objects_s173}\item[procedure] \texttt{(fxarithmetic-shift \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}


The absolute value of \texttt{\textit{fx\textsubscript{2}}} must be less than the value of
\texttt{(fixnum-width)}.
If \texttt{\textit{fx\textsubscript{2}}} is negative, \texttt{fxarithmetic-shift} returns the
result of arithmetically shifting \texttt{\textit{fx\textsubscript{1}}} right by \texttt{\textit{fx\textsubscript{2}}} bits.
Otherwise, \texttt{fxarithmetic-shift} returns the
result of shifting \texttt{\textit{fx\textsubscript{1}}} left by \texttt{\textit{fx\textsubscript{2}}} bits.


\begin{alltt}
(fxarithmetic-shift \#{}b10000 -3) \(\Rightarrow\) \#{}b00010
(fxarithmetic-shift -1 -1) \(\Rightarrow\) -1
(fxarithmetic-shift -64 -3) \(\Rightarrow\) -8
(fxarithmetic-shift \#{}b00010 2) \(\Rightarrow\) \#{}b01000
(fxarithmetic-shift -1 2) \(\Rightarrow\) -4
\end{alltt}


Thus, \texttt{fxarithmetic-shift} behaves as if defined as follows.


\begin{alltt}
(define fxarithmetic-shift
  (lambda (fx1 fx2)
    (if (fx\textless{}? fx2 0)
        (fxarithmetic-shift-right fx1 (fx- fx2))
        (fxarithmetic-shift-left fx1 fx2))))
\end{alltt}

\begin{description}

\label{objects_s174}\item[procedure] \texttt{(fxrotate-bit-field \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}} \textit{fx\textsubscript{4}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}}, \texttt{\textit{fx\textsubscript{3}}}, and \texttt{\textit{fx\textsubscript{4}}} must be nonnegative and less than
the value of \texttt{(fixnum-width)}, \texttt{\textit{fx\textsubscript{2}}} must not be greater
than \texttt{\textit{fx\textsubscript{3}}}, and \texttt{\textit{fx\textsubscript{4}}} must not be greater than the difference between
\texttt{\textit{fx\textsubscript{3}}} and \texttt{\textit{fx\textsubscript{2}}}.

This procedure returns the result of shifting the bits of
\texttt{\textit{fx\textsubscript{1}}} from bit \texttt{\textit{fx\textsubscript{2}}} (inclusive) through bit \texttt{\textit{fx\textsubscript{3}}} (exclusive)
left by \texttt{\textit{fx\textsubscript{4}}} bits, with the bits shifted out of the range inserted
at the bottom end of the range.


\begin{alltt}
(fxrotate-bit-field \#{}b00011010 0 5 3) \(\Rightarrow\) \#{}b00010110
(fxrotate-bit-field \#{}b01101011 2 7 3) \(\Rightarrow\) \#{}b01011011
\end{alltt}

\begin{description}

\label{objects_s175}\item[procedure] \texttt{(fxreverse-bit-field \textit{fx\textsubscript{1}} \textit{fx\textsubscript{2}} \textit{fx\textsubscript{3}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic fixnums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fx\textsubscript{2}}} and \texttt{\textit{fx\textsubscript{3}}} must be nonnegative and less than
the value of \texttt{(fixnum-width)}, and \texttt{\textit{fx\textsubscript{2}}} must not be greater
than \texttt{\textit{fx\textsubscript{3}}}.
This procedure returns the result of reversing the bits of
\texttt{\textit{fx\textsubscript{1}}} from bit \texttt{\textit{fx\textsubscript{2}}} (inclusive) through bit \texttt{\textit{fx\textsubscript{3}}} (exclusive).

\begin{alltt}
(fxreverse-bit-field \#{}b00011010 0 5) \(\Rightarrow\) \#{}b00001011
(fxreverse-bit-field \#{}b01101011 2 7) \(\Rightarrow\) \#{}b00101111
\end{alltt}

\section{\label{objects_g112}\label{objects_h6}Flonums\label{objects_SECTFLONUMS}}



\label{objects_s176}\textit{Flonums} represent inexact real numbers.
Implementations are required to represent as a flonum any inexact
real number whose lexical syntax contains no vertical bar and
no exponent marker other than \texttt{e}, but are not required
to represent any other inexact real number as a flonum.


Implementations typically use the IEEE double-precision
floating-point representation for flonums, but implementations are not
required to do so or even to use a floating-point representation
of any sort, despite the name ``flonum.''


This section describes operations on flonums.
Flonum-specific procedure names begin with the prefix "\texttt{fl}" to
set them apart from their generic counterparts.


Procedure arguments required to be flonums are named \texttt{\textit{fl}}, possibly
with suffix, e.g., \texttt{\textit{fl\textsubscript{2}}}.
Unless otherwise specified, the numeric values of flonum-specific
procedures are flonums.

\begin{description}

\label{objects_s177}\item[procedure] \texttt{(flonum? \textit{obj})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{obj}} is a flonum, otherwise \texttt{\#{}f}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(flonum? 0) \(\Rightarrow\) \#{}f
(flonum? 3/4) \(\Rightarrow\) \#{}f
(flonum? 3.5) \(\Rightarrow\) \#{}t
(flonum? .02) \(\Rightarrow\) \#{}t
(flonum? 1e10) \(\Rightarrow\) \#{}t
(flonum? 3.0+0.0i) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s178}\item[procedure] \texttt{(fl=? \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...)}



\item[procedure] \texttt{(fl\textless{}? \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...)}



\item[procedure] \texttt{(fl\textgreater{}? \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...)}



\item[procedure] \texttt{(fl\textless{}=? \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...)}



\item[procedure] \texttt{(fl\textgreater{}=? \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...)}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


The predicate \texttt{fl=?} returns \texttt{\#{}t} if its arguments are equal.
The predicate \texttt{fl\textless{}?} returns \texttt{\#{}t} if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while \texttt{fl\textgreater{}?} returns \texttt{\#{}t} if its arguments are monotonically decreasing.
The predicate \texttt{fl\textless{}=?} returns \texttt{\#{}t} if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while \texttt{fl\textgreater{}=?} returns \texttt{\#{}t} if its arguments are monotonically nonincreasing.
When passed only one argument, each of these predicates returns \texttt{\#{}t}.


Comparisons involving NaNs always return \texttt{\#{}f}.


\begin{alltt}
(fl=? 0.0 0.0) \(\Rightarrow\) \#{}t
(fl\textless{}? -1.0 0.0 1.0) \(\Rightarrow\) \#{}t
(fl\textgreater{}? -1.0 0.0 1.0) \(\Rightarrow\) \#{}f
(fl\textless{}=? 0.0 3.0 3.0) \(\Rightarrow\) \#{}t
(fl\textgreater{}=? 4.0 3.0 3.0) \(\Rightarrow\) \#{}t
(fl\textless{}? 7.0 +inf.0) \(\Rightarrow\) \#{}t
(fl=? +nan.0 0.0) \(\Rightarrow\) \#{}f
(fl=? +nan.0 +nan.0) \(\Rightarrow\) \#{}f
(fl\textless{}? +nan.0 +nan.0) \(\Rightarrow\) \#{}f
(fl\textless{}=? +nan.0 +inf.0) \(\Rightarrow\) \#{}f
(fl\textgreater{}=? +nan.0 +inf.0) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s179}\item[procedure] \texttt{(flzero? \textit{fl})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl}} is zero, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(flpositive? \textit{fl})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl}} is greater than zero, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(flnegative? \textit{fl})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl}} is less than zero, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}

\texttt{flzero?} is equivalent to \texttt{(lambda (x) (fl=? x 0.0))},
\texttt{flpositive?} is equivalent to \texttt{(lambda (x) (fl\textgreater{}? x 0.0))}, and
\texttt{flnegative?} to \texttt{(lambda (x) (fl\textless{}? x 0.0))}.

Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is
considered both zero and nonnegative.


\begin{alltt}
(flzero? 0.0) \(\Rightarrow\) \#{}t
(flzero? 1.0) \(\Rightarrow\) \#{}f

(flpositive? 128.0) \(\Rightarrow\) \#{}t
(flpositive? 0.0) \(\Rightarrow\) \#{}f
(flpositive? -1.0) \(\Rightarrow\) \#{}f

(flnegative? -65.0) \(\Rightarrow\) \#{}t
(flnegative? 0.0) \(\Rightarrow\) \#{}f
(flnegative? 1.0) \(\Rightarrow\) \#{}f

(flzero? -0.0) \(\Rightarrow\) \#{}t
(flnegative? -0.0) \(\Rightarrow\) \#{}f

(flnegative? +nan.0) \(\Rightarrow\) \#{}f
(flzero? +nan.0) \(\Rightarrow\) \#{}f
(flpositive? +nan.0) \(\Rightarrow\) \#{}f

(flnegative? +inf.0) \(\Rightarrow\) \#{}f
(flnegative? -inf.0) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s180}\item[procedure] \texttt{(flinteger? \textit{fl})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl}} is integer, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(flinteger? 0.0) \(\Rightarrow\) \#{}t
(flinteger? -17.0) \(\Rightarrow\) \#{}t
(flinteger? +nan.0) \(\Rightarrow\) \#{}f
(flinteger? +inf.0) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s181}\item[procedure] \texttt{(flfinite? \textit{fl})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl}} is finite, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(flinfinite? \textit{fl})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl}} is infinite, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(flnan? \textit{fl})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl}} is a NaN, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(flfinite? 3.1415) \(\Rightarrow\) \#{}t
(flinfinite? 3.1415) \(\Rightarrow\) \#{}f
(flnan? 3.1415) \(\Rightarrow\) \#{}f

(flfinite? +inf.0) \(\Rightarrow\) \#{}f
(flinfinite? -inf.0) \(\Rightarrow\) \#{}t
(flnan? -inf.0) \(\Rightarrow\) \#{}f

(flfinite? +nan.0) \(\Rightarrow\) \#{}f
(flinfinite? +nan.0) \(\Rightarrow\) \#{}f
(flnan? +nan.0) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s182}\item[procedure] \texttt{(fleven? \textit{fl-int})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl-int}} is even, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(flodd? \textit{fl-int})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{fl-int}} is odd, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{fl-int}} must be an integer-valued flonum.

\begin{alltt}
(fleven? 0.0) \(\Rightarrow\) \#{}t
(fleven? 1.0) \(\Rightarrow\) \#{}f
(fleven? -1.0) \(\Rightarrow\) \#{}f
(fleven? -10.0) \(\Rightarrow\) \#{}t

(flodd? 0.0) \(\Rightarrow\) \#{}f
(flodd? 1.0) \(\Rightarrow\) \#{}t
(flodd? -1.0) \(\Rightarrow\) \#{}t
(flodd? -10.0) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s183}\item[procedure] \texttt{(flmin \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} ...)}



\item[returns] the minimum of \texttt{\textit{fl\textsubscript{1}}} \texttt{\textit{fl\textsubscript{2}}} ... 

\item[procedure] \texttt{(flmax \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} ...)}



\item[returns] the maximum of \texttt{\textit{fl\textsubscript{1}}} \texttt{\textit{fl\textsubscript{2}}} ...

\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(flmin 4.2 -7.5 2.0 0.0 -6.4) \(\Rightarrow\) -7.5

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmin ls)) \(\Rightarrow\) 2.6

(flmax 4.2 -7.5 2.0 0.0 -6.4) \(\Rightarrow\) 4.2

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmax ls)) \(\Rightarrow\) 8.0
\end{alltt}

\begin{description}

\label{objects_s184}\item[procedure] \texttt{(fl+ \textit{fl} ...)}



\item[returns] the sum of the arguments \texttt{\textit{fl} ...}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


When called with no arguments, \texttt{fl+} returns \texttt{0.0}.


\begin{alltt}
(fl+) \(\Rightarrow\) 0.0
(fl+ 1.0 2.5) \(\Rightarrow\) 3.25
(fl+ 3.0 4.25 5.0) \(\Rightarrow\) 12.25
(apply fl+ '(1.0 2.0 3.0 4.0 5.0)) \(\Rightarrow\) 15.0
\end{alltt}

\begin{description}

\label{objects_s185}\item[procedure] \texttt{(fl- \textit{fl})}



\item[returns] the additive inverse of \texttt{\textit{fl}}


\item[procedure] \texttt{(fl- \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...)}



\item[returns] the difference between \texttt{\textit{fl\textsubscript{1}}} and the sum of \texttt{\textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


With an IEEE floating-point representation of flonums,
the single-argument \texttt{fl-} is equivalent to


\texttt{(lambda (x) (fl* -1.0 x))}

or


\texttt{(lambda (x) (fl- -0.0 x))}

but not


\texttt{(lambda (x) (fl- 0.0 x))}

since the latter returns \texttt{0.0} rather than \texttt{-0.0} for \texttt{0.0}.


\begin{alltt}
(fl- 0.0) \(\Rightarrow\) -0.0
(fl- 3.0) \(\Rightarrow\) -3.0
(fl- 4.0 3.0) \(\Rightarrow\) 1.0
(fl- 4.0 3.0 2.0 1.0) \(\Rightarrow\) -2.0
\end{alltt}

\begin{description}

\label{objects_s186}\item[procedure] \texttt{(fl* \textit{fl} ...)}



\item[returns] the product of the arguments \texttt{\textit{fl} ...}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


When called with no arguments, \texttt{fl*} returns \texttt{1.0}.


\begin{alltt}
(fl*) \(\Rightarrow\) 1.0
(fl* 1.5 2.5) \(\Rightarrow\) 3.75
(fl* 3.0 -4.0 5.0) \(\Rightarrow\) -60.0
(apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) \(\Rightarrow\) 120.0
\end{alltt}

\begin{description}

\label{objects_s187}\item[procedure] \texttt{(fl/ \textit{fl})}



\item[returns] the multiplicative inverse of \texttt{\textit{fl}}


\item[procedure] \texttt{(fl/ \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...)}



\item[returns] the result of dividing \texttt{\textit{fl\textsubscript{1}}} by the product of \texttt{\textit{fl\textsubscript{2}} \textit{fl\textsubscript{3}} ...}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(fl/ -4.0) \(\Rightarrow\) -0.25
(fl/ 8.0 -2.0) \(\Rightarrow\) -4.0
(fl/ -9.0 2.0) \(\Rightarrow\) -4.5
(fl/ 60.0 5.0 3.0 2.0) \(\Rightarrow\) 2.0
\end{alltt}

\begin{description}

\label{objects_s188}\item[procedure] \texttt{(fldiv \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[procedure] \texttt{(flmod \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[procedure] \texttt{(fldiv-and-mod \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


These are flonum-specific versions of the generic \texttt{div},
\texttt{mod}, and \texttt{div-and-mod}.


\begin{alltt}
(fldiv 17.0 3.0) \(\Rightarrow\) 5.0
(flmod 17.0 3.0) \(\Rightarrow\) 2.0
(fldiv -17.0 3.0) \(\Rightarrow\) -6.0
(flmod -17.0 3.0) \(\Rightarrow\) 1.0
(fldiv 17.0 -3.0) \(\Rightarrow\) -5.0
(flmod 17.0 -3.0) \(\Rightarrow\) 2.0
(fldiv -17.0 -3.0) \(\Rightarrow\) 6.0
(flmod -17.0 -3.0) \(\Rightarrow\) 1.0

(fldiv-and-mod 17.5 3.75) \(\Rightarrow\) 4.0
                           2.5
\end{alltt}

\begin{description}

\label{objects_s189}\item[procedure] \texttt{(fldiv0 \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[procedure] \texttt{(flmod0 \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[procedure] \texttt{(fldiv0-and-mod0 \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[returns] see below


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


These are flonum-specific versions of the generic \texttt{div0},
\texttt{mod0}, and \texttt{div0-and-mod0}.


\begin{alltt}
(fldiv0 17.0 3.0) \(\Rightarrow\) 6.0
(flmod0 17.0 3.0) \(\Rightarrow\) -1.0
(fldiv0 -17.0 3.0) \(\Rightarrow\) -6.0
(flmod0 -17.0 3.0) \(\Rightarrow\) 1.0
(fldiv0 17.0 -3.0) \(\Rightarrow\) -6.0
(flmod0 17.0 -3.0) \(\Rightarrow\) -1.0
(fldiv0 -17.0 -3.0) \(\Rightarrow\) 6.0
(flmod0 -17.0 -3.0) \(\Rightarrow\) 1.0

(fldiv0-and-mod0 17.5 3.75) \(\Rightarrow\) 5.0
                             -1.25
\end{alltt}

\begin{description}

\label{objects_s190}\item[procedure] \texttt{(flround \textit{fl})}



\item[returns] the integer closest to \texttt{\textit{fl}}


\item[procedure] \texttt{(fltruncate \textit{fl})}



\item[returns] the integer closest to \texttt{\textit{fl}} toward zero


\item[procedure] \texttt{(flfloor \textit{fl})}



\item[returns] the integer closest to \texttt{\textit{fl}} toward \(-\infty\)


\item[procedure] \texttt{(flceiling \textit{fl})}



\item[returns] the integer closest to \texttt{\textit{fl}} toward \(+\infty\)


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{fl}} is an integer, NaN, or infinity, each of these procedures returns \texttt{\textit{fl}}.
If \texttt{\textit{fl}} is exactly between two integers, \texttt{flround} returns the closest
even integer.


\begin{alltt}
(flround 17.3) \(\Rightarrow\) 17.0
(flround -17.3) \(\Rightarrow\) -17.0
(flround 2.5) \(\Rightarrow\) 2.0
(flround 3.5) \(\Rightarrow\) 4.0

(fltruncate 17.3) \(\Rightarrow\) 17.0
(fltruncate -17.3) \(\Rightarrow\) -17.0

(flfloor 17.3) \(\Rightarrow\) 17.0
(flfloor -17.3) \(\Rightarrow\) -18.0

(flceiling 17.3) \(\Rightarrow\) 18.0
(flceiling -17.3) \(\Rightarrow\) -17.0
\end{alltt}

\begin{description}

\label{objects_s191}\item[procedure] \texttt{(flnumerator \textit{fl})}



\item[returns] the numerator of \texttt{\textit{fl}}


\item[procedure] \texttt{(fldenominator \textit{fl})}



\item[returns] the denominator of \texttt{\textit{fl}}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{fl}} is an integer, including 0.0, or infinity, the numerator is \texttt{\textit{fl}}
and the denominator is 1.0.


\begin{alltt}
(flnumerator -9.0) \(\Rightarrow\) -9.0
(fldenominator -9.0) \(\Rightarrow\) 1.0
(flnumerator 0.0) \(\Rightarrow\) 0.0
(fldenominator 0.0) \(\Rightarrow\) 1.0
(flnumerator -inf.0) \(\Rightarrow\) -inf.0
(fldenominator -inf.0) \(\Rightarrow\) 1.0
\end{alltt}


The following hold for IEEE floats, but not necessarily other
flonum representations.


\begin{alltt}
(flnumerator 3.5) \(\Rightarrow\) 7.0
(fldenominator 3.5) \(\Rightarrow\) 2.0
\end{alltt}

\begin{description}

\label{objects_s192}\item[procedure] \texttt{(flabs \textit{fl})}



\item[returns] absolute value of \texttt{\textit{fl}}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(flabs 3.2) \(\Rightarrow\) 3.2
(flabs -2e-20) \(\Rightarrow\) 2e-20
\end{alltt}

\begin{description}

\label{objects_s193}\item[procedure] \texttt{(flexp \textit{fl})}



\item[returns] \textit{e} to the \texttt{\textit{fl}} power


\item[procedure] \texttt{(fllog \textit{fl})}



\item[returns] the natural logarithm of \texttt{\textit{fl}}


\item[procedure] \texttt{(fllog \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[returns] the base-\texttt{\textit{fl\textsubscript{2}}} logarithm of \texttt{\textit{fl\textsubscript{1}}}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(flexp 0.0) \(\Rightarrow\) 1.0
(flexp 1.0) \(\Rightarrow\) 2.7182818284590455

(fllog 1.0) \(\Rightarrow\) 0.0
(fllog (exp 1.0)) \(\Rightarrow\) 1.0
(fl/ (fllog 100.0) (fllog 10.0)) \(\Rightarrow\) 2.0

(fllog 100.0 10.0) \(\Rightarrow\) 2.0
(fllog .125 2.0) \(\Rightarrow\) -3.0
\end{alltt}

\begin{description}

\label{objects_s194}\item[procedure] \texttt{(flsin \textit{fl})}



\item[returns] the sine of \texttt{\textit{fl}}


\item[procedure] \texttt{(flcos \textit{fl})}



\item[returns] the cosine of \texttt{\textit{fl}}


\item[procedure] \texttt{(fltan \textit{fl})}



\item[returns] the tangent of \texttt{\textit{fl}}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}

\begin{description}

\label{objects_s195}\item[procedure] \texttt{(flasin \textit{fl})}



\item[returns] the arc sine of \texttt{\textit{fl}}


\item[procedure] \texttt{(flacos \textit{fl})}



\item[returns] the arc cosine of \texttt{\textit{fl}}


\item[procedure] \texttt{(flatan \textit{fl})}



\item[returns] the arc tangent of \texttt{\textit{fl}}


\item[procedure] \texttt{(flatan \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[returns] the arc tangent of \texttt{\textit{fl\textsubscript{1}}}/\texttt{\textit{fl\textsubscript{2}}}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}

\begin{description}

\label{objects_s196}\item[procedure] \texttt{(flsqrt \textit{fl})}



\item[returns] the principal square root of \texttt{\textit{fl}}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


Returns the principal square root of \texttt{\textit{fl}}.
The square root of -0.0 should be -0.0.
The result for other negative numbers may be a NaN or some
other unspecified flonum.


\begin{alltt}
(flsqrt 4.0) \(\Rightarrow\) 2.0
(flsqrt 0.0) \(\Rightarrow\) 0.0
(flsqrt -0.0) \(\Rightarrow\) -0.0
\end{alltt}

\begin{description}

\label{objects_s197}\item[procedure] \texttt{(flexpt \textit{fl\textsubscript{1}} \textit{fl\textsubscript{2}})}



\item[returns] \texttt{\textit{fl\textsubscript{1}}} raised to the \texttt{\textit{fl\textsubscript{2}}} power


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{fl\textsubscript{1}}} is negative and \texttt{\textit{fl\textsubscript{2}}} is not an integer,
the result may be a NaN or some other unspecified flonum.
If \texttt{\textit{fl\textsubscript{1}}} and \texttt{\textit{fl\textsubscript{2}}} are both zero, the result
is 1.0.  If \texttt{\textit{fl\textsubscript{1}}} is zero and \texttt{\textit{fl\textsubscript{2}}} is positive,
the result is zero.  In other cases where \texttt{\textit{fl\textsubscript{1}}} is
zero, the result may be a NaN or some other unspecified
flonum.


\begin{alltt}
(flexpt 3.0 2.0) \(\Rightarrow\) 9.0
(flexpt 0.0 +inf.0) \(\Rightarrow\) 0.0
\end{alltt}

\begin{description}

\label{objects_s198}\item[procedure] \texttt{(fixnum-\textgreater{}flonum \textit{fx})}



\item[returns] the flonum representation closest to \texttt{\textit{fx}}


\item[procedure] \texttt{(real-\textgreater{}flonum \textit{real})}



\item[returns] the flonum representation closest to \texttt{\textit{real}}


\item[libraries] \texttt{(rnrs arithmetic flonums)}, \texttt{(rnrs)}
\end{description}

\texttt{fixnum-\textgreater{}flonum} is a restricted variant of \texttt{inexact}.
\texttt{real-\textgreater{}flonum} is a restricted variant of \texttt{inexact} when
the input is an exact real; when it is an inexact non-flonum real,
it coverts the inexact non-flonum real into the closest flonum.


\begin{alltt}
(fixnum-\textgreater{}flonum 0) \(\Rightarrow\) 0.0
(fixnum-\textgreater{}flonum 13) \(\Rightarrow\) 13.0

(real-\textgreater{}flonum -1/2) \(\Rightarrow\) -0.5
(real-\textgreater{}flonum 1s3) \(\Rightarrow\) 1000.0
\end{alltt}

\section{\label{objects_g113}\label{objects_h7}Characters\label{objects_SECTCHARACTERS}}



\label{objects_s199}Characters are atomic objects representing letters, digits,
special symbols such as \texttt{\${}} or \texttt{-}, and certain nongraphic
control characters such as space and newline.
Characters are written with a \label{objects_s200}\texttt{\#{}\textbackslash{}} prefix.
For most characters, the prefix is followed by the character itself.
The written character representation of the letter \texttt{A}, for example, is
\texttt{\#{}\textbackslash{}A}.
The characters newline, space, and tab
may be written in this manner as well, but they can be written
more clearly as \texttt{\#{}\textbackslash{}newline}, \texttt{\#{}\textbackslash{}space}, and \texttt{\#{}\textbackslash{}tab}.
Other character names are supported as well, as defined by the
grammar for character objects on page \pageref{grammar_grammar_characters}.
Any Unicode character may be written with the syntax \texttt{\#{}\textbackslash{}x\textit{n}},
where \texttt{\textit{n}} consists of one or more hexadecimal digits and represents
a valid Unicode scalar value.


This section describes the operations that deal primarily with characters.
See also the following section on strings and Chapter \ref{io_g121} on input and
output for other operations relating to characters.

\begin{description}

\label{objects_s201}\item[procedure] \texttt{(char=? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char\textless{}? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char\textgreater{}? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char\textless{}=? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char\textgreater{}=? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


These predicates behave in a similar manner to the numeric predicates
\texttt{=}, \texttt{\textless{}}, \texttt{\textgreater{}}, \texttt{\textless{}=}, and \texttt{\textgreater{}=}.
For example, \texttt{char=?} returns \texttt{\#{}t} when its arguments are
equivalent characters, and \texttt{char\textless{}?} returns \texttt{\#{}t} when its
arguments are monotonically increasing character (Unicode scalar) values.


\begin{alltt}
(char\textgreater{}? \#{}\textbackslash{}a \#{}\textbackslash{}b) \(\Rightarrow\) \#{}f
(char\textless{}? \#{}\textbackslash{}a \#{}\textbackslash{}b) \(\Rightarrow\) \#{}t
(char\textless{}? \#{}\textbackslash{}a \#{}\textbackslash{}b \#{}\textbackslash{}c) \(\Rightarrow\) \#{}t
(let ([c \#{}\textbackslash{}r])
  (char\textless{}=? \#{}\textbackslash{}a c \#{}\textbackslash{}z)) \(\Rightarrow\) \#{}t
(char\textless{}=? \#{}\textbackslash{}Z \#{}\textbackslash{}W) \(\Rightarrow\) \#{}f
(char=? \#{}\textbackslash{}+ \#{}\textbackslash{}+) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s202}\item[procedure] \texttt{(char-ci=? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char-ci\textless{}? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char-ci\textgreater{}? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char-ci\textless{}=? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[procedure] \texttt{(char-ci\textgreater{}=? \textit{char\textsubscript{1}} \textit{char\textsubscript{2}} \textit{char\textsubscript{3}} ...)}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


These predicates are identical to the predicates \texttt{char=?}, \texttt{char\textless{}?},
\texttt{char\textgreater{}?}, \texttt{char\textless{}=?}, and \texttt{char\textgreater{}=?} except that they are
case-insensitive, i.e., compare the case-folded versions of their arguments.
For example, \texttt{char=?} considers \texttt{\#{}\textbackslash{}a} and \texttt{\#{}\textbackslash{}A} to be
distinct values; \texttt{char-ci=?} does not.


\begin{alltt}
(char-ci\textless{}? \#{}\textbackslash{}a \#{}\textbackslash{}B) \(\Rightarrow\) \#{}t
(char-ci=? \#{}\textbackslash{}W \#{}\textbackslash{}w) \(\Rightarrow\) \#{}t
(char-ci=? \#{}\textbackslash{}= \#{}\textbackslash{}+) \(\Rightarrow\) \#{}f
(let ([c \#{}\textbackslash{}R])
  (list (char\textless{}=? \#{}\textbackslash{}a c \#{}\textbackslash{}z)
        (char-ci\textless{}=? \#{}\textbackslash{}a c \#{}\textbackslash{}z))) \(\Rightarrow\) (\#{}f \#{}t)
\end{alltt}

\begin{description}

\label{objects_s203}\item[procedure] \texttt{(char-alphabetic? \textit{char})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{char}} is a letter, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(char-numeric? \textit{char})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{char}} is a digit, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(char-whitespace? \textit{char})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{char}} is whitespace, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


A character is alphabetic if it has the Unicode ``Alphabetic'' property,
numeric if it has the Unicode ``Numeric'' property, and whitespace if has
the Unicode ``White\_{}Space'' property.


\begin{alltt}
(char-alphabetic? \#{}\textbackslash{}a) \(\Rightarrow\) \#{}t
(char-alphabetic? \#{}\textbackslash{}T) \(\Rightarrow\) \#{}t
(char-alphabetic? \#{}\textbackslash{}8) \(\Rightarrow\) \#{}f
(char-alphabetic? \#{}\textbackslash{}\${}) \(\Rightarrow\) \#{}f

(char-numeric? \#{}\textbackslash{}7) \(\Rightarrow\) \#{}t
(char-numeric? \#{}\textbackslash{}2) \(\Rightarrow\) \#{}t
(char-numeric? \#{}\textbackslash{}X) \(\Rightarrow\) \#{}f
(char-numeric? \#{}\textbackslash{}space) \(\Rightarrow\) \#{}f

(char-whitespace? \#{}\textbackslash{}space) \(\Rightarrow\) \#{}t
(char-whitespace? \#{}\textbackslash{}newline) \(\Rightarrow\) \#{}t
(char-whitespace? \#{}\textbackslash{}Z) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s204}\item[procedure] \texttt{(char-lower-case? \textit{char})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{char}} is lower case, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(char-upper-case? \textit{char})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{char}} is upper case, \texttt{\#{}f} otherwise


\item[procedure] \texttt{(char-title-case? \textit{char})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{char}} is title case, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


A character is upper-case if it has the Unicode ``Uppercase'' property,
lower-case if it has the ``Lowercase'' property, and title-case if it is
in the Lt general category.


\begin{alltt}
(char-lower-case? \#{}\textbackslash{}r) \(\Rightarrow\) \#{}t
(char-lower-case? \#{}\textbackslash{}R) \(\Rightarrow\) \#{}f

(char-upper-case? \#{}\textbackslash{}r) \(\Rightarrow\) \#{}f
(char-upper-case? \#{}\textbackslash{}R) \(\Rightarrow\) \#{}t

(char-title-case? \#{}\textbackslash{}I) \(\Rightarrow\) \#{}f
(char-title-case? \#{}\textbackslash{}x01C5) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s205}\item[procedure] \texttt{(char-general-category \textit{char})}



\item[returns] a symbol representing the Unicode general category of \texttt{\textit{char}}


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


The return value is one of the symbols \texttt{Lu}, \texttt{Ll},
\texttt{Lt}, \texttt{Lm}, \texttt{Lo}, \texttt{Mn}, \texttt{Mc},
\texttt{Me}, \texttt{Nd}, \texttt{Nl}, \texttt{No}, \texttt{Ps},
\texttt{Pe}, \texttt{Pi}, \texttt{Pf}, \texttt{Pd}, \texttt{Pc},
\texttt{Po}, \texttt{Sc}, \texttt{Sm}, \texttt{Sk}, \texttt{So},
\texttt{Zs}, \texttt{Zp}, \texttt{Zl}, \texttt{Cc}, \texttt{Cf},
\texttt{Cs}, \texttt{Co}, or \texttt{Cn}.


\begin{alltt}
(char-general-category \#{}\textbackslash{}a) \(\Rightarrow\) Ll
(char-general-category \#{}\textbackslash{}space) \(\Rightarrow\) Zs
(char-general-category \#{}\textbackslash{}x10FFFF) \(\Rightarrow\) Cn  
\end{alltt}

\begin{description}

\label{objects_s206}\item[procedure] \texttt{(char-upcase \textit{char})}



\item[returns] the upper-case character counterpart of \texttt{\textit{char}}


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{char}} is a lower- or title-case character and has a single
upper-case counterpart, \texttt{char-upcase} returns the upper-case
counterpart.
Otherwise \texttt{char-upcase} returns \texttt{\textit{char}}.


\begin{alltt}
(char-upcase \#{}\textbackslash{}g) \(\Rightarrow\) \#{}\textbackslash{}G
(char-upcase \#{}\textbackslash{}G) \(\Rightarrow\) \#{}\textbackslash{}G
(char-upcase \#{}\textbackslash{}7) \(\Rightarrow\) \#{}\textbackslash{}7
(char-upcase \#{}\textbackslash{}\(\varsigma\)) \(\Rightarrow\) \#{}\textbackslash{}\(\Sigma\)
\end{alltt}

\begin{description}

\label{objects_s207}\item[procedure] \texttt{(char-downcase \textit{char})}



\item[returns] the lower-case character equivalent of \texttt{\textit{char}}


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{char}} is an upper- or title-case character and has a single
lower-case counterpart, \texttt{char-downcase} returns the lower-case
counterpart.
Otherwise \texttt{char-downcase} returns \texttt{\textit{char}}.


\begin{alltt}
(char-downcase \#{}\textbackslash{}g) \(\Rightarrow\) \#{}\textbackslash{}g
(char-downcase \#{}\textbackslash{}G) \(\Rightarrow\) \#{}\textbackslash{}g
(char-downcase \#{}\textbackslash{}7) \(\Rightarrow\) \#{}\textbackslash{}7
(char-downcase \#{}\textbackslash{}\(\varsigma\)) \(\Rightarrow\) \#{}\textbackslash{}\(\varsigma\)
\end{alltt}

\begin{description}

\label{objects_s208}\item[procedure] \texttt{(char-titlecase \textit{char})}



\item[returns] the title-case character equivalent of \texttt{\textit{char}}


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{char}} is an upper- or lower-case character and has a single
title-case counterpart, \texttt{char-titlecase} returns the title-case
counterpart.
Otherwise, if it is not a title-case character, has no single title-case
counterpart, but does have a single upper-case counterpart,
\texttt{char-titlecase} returns the upper-case counterpart.
Otherwise \texttt{char-titlecase} returns \texttt{\textit{char}}.


\begin{alltt}
(char-titlecase \#{}\textbackslash{}g) \(\Rightarrow\) \#{}\textbackslash{}G
(char-titlecase \#{}\textbackslash{}G) \(\Rightarrow\) \#{}\textbackslash{}G
(char-titlecase \#{}\textbackslash{}7) \(\Rightarrow\) \#{}\textbackslash{}7
(char-titlecase \#{}\textbackslash{}\(\varsigma\)) \(\Rightarrow\) \#{}\textbackslash{}\(\Sigma\)
\end{alltt}

\begin{description}

\label{objects_s209}\item[procedure] \texttt{(char-foldcase \textit{char})}



\item[returns] the case-folded character equivalent of \texttt{\textit{char}}


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{char}} has a case-folded counterpart, \texttt{char-foldcase}
returns the case-folded counterpart.
Otherwise, \texttt{char-foldcase} returns \texttt{\textit{char}}.
For most characters, \texttt{(char-foldcase \textit{char})} is
equivalent to \texttt{(char-downcase (char-upcase \textit{char}))},
but for Turkic İ and ı,
\texttt{char-foldcase} acts as the identity.


\begin{alltt}
(char-foldcase \#{}\textbackslash{}g) \(\Rightarrow\) \#{}\textbackslash{}g
(char-foldcase \#{}\textbackslash{}G) \(\Rightarrow\) \#{}\textbackslash{}g
(char-foldcase \#{}\textbackslash{}7) \(\Rightarrow\) \#{}\textbackslash{}7
(char-foldcase \#{}\textbackslash{}\(\varsigma\)) \(\Rightarrow\) \#{}\textbackslash{}\(\sigma\)
\end{alltt}

\begin{description}

\label{objects_s210}\item[procedure] \texttt{(char-\textgreater{}integer \textit{char})}



\item[returns] the Unicode scalar value of \texttt{\textit{char}} as an exact integer


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(char-\textgreater{}integer \#{}\textbackslash{}newline) \(\Rightarrow\) 10
(char-\textgreater{}integer \#{}\textbackslash{}space) \(\Rightarrow\) 32
(- (char-\textgreater{}integer \#{}\textbackslash{}Z) (char-\textgreater{}integer \#{}\textbackslash{}A)) \(\Rightarrow\) 25
\end{alltt}

\begin{description}

\label{objects_s211}\item[procedure] \texttt{(integer-\textgreater{}char \textit{n})}



\item[returns] the character corresponding to the Unicode scalar value \texttt{\textit{n}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact integer and a valid Unicode
scalar value, i.e., \(0 \leq n \leq \mathrm{\#xD7FF}\) or
\(\mathrm{\#xE000} \leq n \leq \mathrm{10FFFF}\).

\begin{alltt}
(integer-\textgreater{}char 48) \(\Rightarrow\) \#{}\textbackslash{}0
(integer-\textgreater{}char \#{}x3BB) \(\Rightarrow\) \#{}\textbackslash{}\(\lambda\)
\end{alltt}

\section{\label{objects_g114}\label{objects_h8}Strings\label{objects_SECTSTRINGS}}



\label{objects_s212}Strings are sequences of characters and are often used as messages,
character buffers, or containers for blocks of text.
Scheme provides operations for creating strings, extracting characters from
strings, obtaining substrings, concatenating strings, and altering the contents
of strings.


A string is written as a sequence of characters enclosed in
\label{objects_s213}\label{objects_s214}double quotes, e.g., \texttt{"hi there"}.
A double quote may be introduced into a string by preceding it by a backward
slash, e.g., \texttt{"two \textbackslash{}"quotes\textbackslash{}" within"}.
A backward slash may also be included by preceding it with a backward slash,
e.g., \texttt{"a \textbackslash{}\textbackslash{}slash"}.
Various special characters can be inserted
with other two-character sequences, e.g., \texttt{\textbackslash{}n} for newline, \texttt{\textbackslash{}r}
for carriage return, and \texttt{\textbackslash{}t} for tab.
Any Unicode character may be inserted with the syntax \texttt{\#{}\textbackslash{}x\textit{n};},
where \texttt{\textit{n}} consists of one or more hexadecimal digits and represents
a valid Unicode scalar value.
A grammar defining the precise syntax of strings is given on
page \pageref{grammar_grammar_strings}.


Strings are indexed by exact nonnegative integers, and the index of
the first element of any string is 0.
The highest valid index for a given string is one less than its length.


\begin{description}

\label{objects_s215}\item[procedure] \texttt{(string=? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string\textless{}? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string\textgreater{}? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string\textless{}=? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string\textgreater{}=? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


As with \texttt{=}, \texttt{\textless{}}, \texttt{\textgreater{}}, \texttt{\textless{}=}, and \texttt{\textgreater{}=}, these predicates
express relationships among all of the arguments.
For example, \texttt{string\textgreater{}?} determines if the lexicographic ordering
of its arguments is monotonically decreasing.


The comparisons are based on the character predicates \texttt{char=?}
and \texttt{char\textless{}?}.
Two strings are lexicographically equivalent if they are the same length
and consist of the same sequence of characters according to \texttt{char=?}.
If two strings differ only in length, the shorter string is considered to
be lexicographically less than the longer string.
Otherwise, the first character position at which the strings differ (by \texttt{char=?})
determines which string is lexicographically less than the other, according
to \texttt{char\textless{}?}.


Two-argument \texttt{string=?} may be defined without error checks as follows.


\begin{alltt}
(define string=?
  (lambda (s1 s2)
    (let ([n (string-length s1)])
      (and (= (string-length s2) n)
           (let loop ([i 0])
             (or (= i n)
                 (and (char=? (string-ref s1 i) (string-ref s2 i))
                      (loop (+ i 1)))))))))
\end{alltt}


Two-argument \texttt{string\textless{}?} may be defined without error checks as follows.


\begin{alltt}
(define string\textless{}?
  (lambda (s1 s2)
    (let ([n1 (string-length s1)] [n2 (string-length s2)])
      (let loop ([i 0])
        (and (not (= i n2))
             (or (= i n1)
                 (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])
                   (or (char\textless{}? c1 c2)
                       (and (char=? c1 c2)
                            (loop (+ i 1)))))))))))
\end{alltt}


These definitions may be extended straightforwardly to support
three or more arguments.
\texttt{string\textless{}=?}, \texttt{string\textgreater{}?}, and \texttt{string\textgreater{}=?}
may be defined similarly.


\begin{alltt}
(string=? "mom" "mom") \(\Rightarrow\) \#{}t
(string\textless{}? "mom" "mommy") \(\Rightarrow\) \#{}t
(string\textgreater{}? "Dad" "Dad") \(\Rightarrow\) \#{}f
(string=? "Mom and Dad" "mom and dad") \(\Rightarrow\) \#{}f
(string\textless{}? "a" "b" "c") \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s216}\item[procedure] \texttt{(string-ci=? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string-ci\textless{}? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string-ci\textgreater{}? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string-ci\textless{}=? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[procedure] \texttt{(string-ci\textgreater{}=? \textit{string\textsubscript{1}} \textit{string\textsubscript{2}} \textit{string\textsubscript{3}} ...)}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


These predicates are identical to
\texttt{string=?}, \texttt{string\textless{}?}, \texttt{string\textgreater{}?}, \texttt{string\textless{}=?}, and
\texttt{string\textgreater{}=?} except that they are case-sensitive,
i.e., compare the case-folded versions of their arguments.


\begin{alltt}
(string-ci=? "Mom and Dad" "mom and dad") \(\Rightarrow\) \#{}t
(string-ci\textless{}=? "say what" "Say What!?") \(\Rightarrow\) \#{}t
(string-ci\textgreater{}? "N" "m" "L" "k") \(\Rightarrow\) \#{}t
(string-ci=? "Stra\textbackslash{}sse" "Strasse") \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s217}\item[procedure] \texttt{(string \textit{char} ...)}



\item[returns] a string containing the characters \texttt{\textit{char} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(string) \(\Rightarrow\) ""
(string \#{}\textbackslash{}a \#{}\textbackslash{}b \#{}\textbackslash{}c) \(\Rightarrow\) "abc"
(string \#{}\textbackslash{}H \#{}\textbackslash{}E \#{}\textbackslash{}Y \#{}\textbackslash{}!) \(\Rightarrow\) "HEY!"
\end{alltt}

\begin{description}

\label{objects_s218}\item[procedure] \texttt{(make-string \textit{n})}



\item[procedure] \texttt{(make-string \textit{n} \textit{char})}



\item[returns] a string of length \texttt{\textit{n}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer.
If \texttt{\textit{char}} is supplied, the string is filled with \texttt{\textit{n}}
occurrences of \texttt{\textit{char}},
otherwise the characters contained in the string are unspecified.

\begin{alltt}
(make-string 0) \(\Rightarrow\) ""
(make-string 0 \#{}\textbackslash{}x) \(\Rightarrow\) ""
(make-string 5 \#{}\textbackslash{}x) \(\Rightarrow\) "xxxxx"
\end{alltt}

\begin{description}

\label{objects_s219}\item[procedure] \texttt{(string-length \textit{string})}



\item[returns] the number of characters in \texttt{\textit{string}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The length of a string is always an exact nonnegative integer.


\begin{alltt}
(string-length "abc") \(\Rightarrow\) 3
(string-length "") \(\Rightarrow\) 0
(string-length "hi there") \(\Rightarrow\) 8
(string-length (make-string 1000000)) \(\Rightarrow\) 1000000
\end{alltt}

\begin{description}

\label{objects_s220}\item[procedure] \texttt{(string-ref \textit{string} \textit{n})}



\item[returns] the \texttt{\textit{n}}th character (zero-based) of \texttt{\textit{string}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{string}}.

\begin{alltt}
(string-ref "hi there" 0) \(\Rightarrow\) \#{}\textbackslash{}h
(string-ref "hi there" 5) \(\Rightarrow\) \#{}\textbackslash{}e
\end{alltt}

\begin{description}

\label{objects_s221}\item[procedure] \texttt{(string-set! \textit{string} \textit{n} \textit{char})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs mutable-strings)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{string}}.
\texttt{string-set!} changes the \texttt{\textit{n}}th element of \texttt{\textit{string}} to \texttt{\textit{char}}.

\begin{alltt}
(let ([str (string-copy "hi three")])
  (string-set! str 5 \#{}\textbackslash{}e)
  (string-set! str 6 \#{}\textbackslash{}r)
  str) \(\Rightarrow\) "hi there"
\end{alltt}

\begin{description}

\label{objects_s222}\item[procedure] \texttt{(string-copy \textit{string})}



\item[returns] a new copy of \texttt{\textit{string}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


This procedure creates a new string with the same length and
contents as \texttt{\textit{string}}.


\begin{alltt}
(string-copy "abc") \(\Rightarrow\) "abc"

(let ([str "abc"])
  (eq? str (string-copy str))) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s223}\item[procedure] \texttt{(string-append \textit{string} ...)}



\item[returns] a new string formed by concatenating the strings \texttt{\textit{string} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(string-append) \(\Rightarrow\) ""
(string-append "abc" "def") \(\Rightarrow\) "abcdef"
(string-append "Hey " "you " "there!") \(\Rightarrow\) "Hey you there!"
\end{alltt}


The following implementation of \texttt{string-append} recurs down the
list of strings to compute the total length, then allocates the new
string, then fills it up as it unwinds the recursion.


\begin{alltt}
(define string-append
  (lambda args
    (let f ([ls args] [n 0])
      (if (null? ls)
          (make-string n)
          (let* ([s1 (car ls)]
                 [m (string-length s1)]
                 [s2 (f (cdr ls) (+ n m))])
            (do ([i 0 (+ i 1)] [j n (+ j 1)])
                ((= i m) s2)
              (string-set! s2 j (string-ref s1 i))))))))
\end{alltt}

\begin{description}

\label{objects_s224}\item[procedure] \texttt{(substring \textit{string} \textit{start} \textit{end})}



\item[returns] a copy of \texttt{\textit{string}} from \texttt{\textit{start}} (inclusive) to \texttt{\textit{end}}
  (exclusive)


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{start}} and \texttt{\textit{end}} must be exact nonnegative integers;
\texttt{\textit{start}} must be less than the length of \texttt{\textit{string}},
while \texttt{\textit{end}} may be less than or equal to the length of
\texttt{\textit{string}}.
If \texttt{\textit{end}} ≤ \texttt{\textit{start}}, a string of length zero is returned.
\texttt{substring} may be defined without error checks as follows.

\begin{alltt}
(define substring
  (lambda (s1 m n)
    (let ([s2 (make-string (- n m))])
      (do ([j 0 (+ j 1)] [i m (+ i 1)])
          ((= i n) s2)
        (string-set! s2 j (string-ref s1 i))))))

(substring "hi there" 0 1) \(\Rightarrow\) "h"
(substring "hi there" 3 6) \(\Rightarrow\) "the"
(substring "hi there" 5 5) \(\Rightarrow\) ""

(let ([str "hi there"])
  (let ([end (string-length str)])
    (substring str 0 end))) \(\Rightarrow\) "hi there"
\end{alltt}

\begin{description}

\label{objects_s225}\item[procedure] \texttt{(string-fill! \textit{string} \textit{char})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs mutable-strings)}
\end{description}

\texttt{string-fill!} sets every character in \texttt{\textit{string}} to \texttt{\textit{char}}.

\begin{alltt}
(let ([str (string-copy "sleepy")])
  (string-fill! str \#{}\textbackslash{}Z)
  str) \(\Rightarrow\) "ZZZZZZ"
\end{alltt}

\texttt{string-fill!} might be defined as follows:

\begin{alltt}
(define string-fill!
  (lambda (s c)
    (let ([n (string-length s)])
      (do ([i 0 (+ i 1)])
          ((= i n))
          (string-set! s i c)))))
\end{alltt}


An alternative definition is given on page \pageref{io_backdoor_string_fill}.


\begin{description}

\label{objects_s226}\item[procedure] \texttt{(string-upcase \textit{string})}



\item[returns] the upper-case equivalent of \texttt{\textit{string}}


\item[procedure] \texttt{(string-downcase \textit{string})}



\item[returns] the lower-case equivalent of \texttt{\textit{string}}


\item[procedure] \texttt{(string-foldcase \textit{string})}



\item[returns] the case-folded equivalent of \texttt{\textit{string}}


\item[procedure] \texttt{(string-titlecase \textit{string})}



\item[returns] the title-case equivalent of \texttt{\textit{string}}


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


These procedures implement Unicode's locale-independent case mappings from
scalar-value sequences to scalar-value sequences.
These mappings do not always map single characters to single characters, so
the length of the result string may differ from the length of \texttt{\textit{string}}.
If the result string is the same as \texttt{\textit{string}} (by \texttt{string=?}),
\texttt{\textit{string}} or a copy of \texttt{\textit{string}} may be returned.
Otherwise, the result string is newly allocated.
\texttt{string-foldcase} does not use the special mappings for Turkic
languages.

\texttt{string-titlecase} converts the first cased character of each word
in \texttt{\textit{string}} to its title-case counterpart and converts each other
character to its lower-case counterpart.
Word breaks are recognized as specified in Unicode Standard
Annex \#{}29 [\hyperref[bibliography_g226]{8}].

\begin{alltt}
(string-upcase "Hi") \(\Rightarrow\) "HI"
(string-downcase "Hi") \(\Rightarrow\) "hi"
(string-foldcase "Hi") \(\Rightarrow\) "hi"

(string-upcase "Straße") \(\Rightarrow\) "STRASSE"
(string-downcase "Straße") \(\Rightarrow\) "straße"
(string-foldcase "Straße") \(\Rightarrow\) "strasse"
(string-downcase "STRASSE")  \(\Rightarrow\) "strasse"

(string-downcase "\(\Sigma\)") \(\Rightarrow\) "\(\sigma\)"

(string-titlecase "kNock KNoCK") \(\Rightarrow\) "Knock Knock"
(string-titlecase "who's there?") \(\Rightarrow\) "Who's There?"
(string-titlecase "r6rs") \(\Rightarrow\) "R6rs"
(string-titlecase "R6RS") \(\Rightarrow\) "R6rs"
\end{alltt}

\begin{description}

\label{objects_s227}\item[procedure] \texttt{(string-normalize-nfd \textit{string})}



\item[returns] the Unicode normalized form D of \texttt{\textit{string}}


\item[procedure] \texttt{(string-normalize-nfkd \textit{string})}



\item[returns] the Unicode normalized form KD of \texttt{\textit{string}}


\item[procedure] \texttt{(string-normalize-nfc \textit{string})}



\item[returns] the Unicode normalized form C of \texttt{\textit{string}}


\item[procedure] \texttt{(string-normalize-nfkc \textit{string})}



\item[returns] the Unicode normalized form KC of \texttt{\textit{string}}


\item[libraries] \texttt{(rnrs unicode)}, \texttt{(rnrs)}
\end{description}


If the result string is the same as \texttt{\textit{string}} (by \texttt{string=?}),
\texttt{\textit{string}} or a copy of \texttt{\textit{string}} may be returned.
Otherwise, the result string is newly allocated.


\begin{alltt}
(string-normalize-nfd "\textbackslash{}xE9;") \(\Rightarrow\) "e\textbackslash{}x301;"
(string-normalize-nfc "\textbackslash{}xE9;") \(\Rightarrow\) "\textbackslash{}xE9;"
(string-normalize-nfd "\textbackslash{}x65;\textbackslash{}x301;") \(\Rightarrow\) "e\textbackslash{}x301;"
(string-normalize-nfc "\textbackslash{}x65;\textbackslash{}x301;") \(\Rightarrow\) "\textbackslash{}xE9;"
\end{alltt}

\begin{description}

\label{objects_s228}\item[procedure] \texttt{(string-\textgreater{}list \textit{string})}



\item[returns] a list of the characters in \texttt{\textit{string}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{string-\textgreater{}list} allows a string to be converted into a list, so that
Scheme's list-processing operations may be applied to the processing of
strings.
\texttt{string-\textgreater{}list} may be defined without error checks as follows.

\begin{alltt}
(define string-\textgreater{}list
  (lambda (s)
    (do ([i (- (string-length s) 1) (- i 1)]
         [ls '() (cons (string-ref s i) ls)])
        ((\textless{} i 0) ls))))

(string-\textgreater{}list "") \(\Rightarrow\) ()
(string-\textgreater{}list "abc") \(\Rightarrow\) (\#{}\textbackslash{}a \#{}\textbackslash{}b \#{}\textbackslash{}c)
(apply char\textless{}? (string-\textgreater{}list "abc")) \(\Rightarrow\) \#{}t
(map char-upcase (string-\textgreater{}list "abc")) \(\Rightarrow\) (\#{}\textbackslash{}A \#{}\textbackslash{}B \#{}\textbackslash{}C)
\end{alltt}

\begin{description}

\label{objects_s229}\item[procedure] \texttt{(list-\textgreater{}string \textit{list})}



\item[returns] a string of the characters in \texttt{\textit{list}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{list}} must consist entirely of characters.
\texttt{list-\textgreater{}string} is the functional inverse of \texttt{string-\textgreater{}list}.
A program might use both procedures together, first converting a string
into a list, then operating on this list to produce a new list, and
finally converting the new list back into a string.
\texttt{list-\textgreater{}string} may be defined without error checks as follows.

\begin{alltt}
(define list-\textgreater{}string
  (lambda (ls)
    (let ([s (make-string (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (string-set! s i (car ls))))))

(list-\textgreater{}string '()) \(\Rightarrow\) ""
(list-\textgreater{}string '(\#{}\textbackslash{}a \#{}\textbackslash{}b \#{}\textbackslash{}c)) \(\Rightarrow\) "abc"
(list-\textgreater{}string
  (map char-upcase
       (string-\textgreater{}list "abc"))) \(\Rightarrow\) "ABC"
\end{alltt}

\section{\label{objects_g115}\label{objects_h9}Vectors\label{objects_SECTVECTORS}}



\label{objects_s230}Vectors are more convenient and efficient than lists for
some applications.
Whereas accessing an arbitrary element in a list requires a linear
traversal of the list up to the selected element, arbitrary vector
elements are accessed in constant time.
The \textit{length} of a vector is the number of elements it
contains.
Vectors are indexed by exact nonnegative integers, and the index of the first
element of any vector is 0.
The highest valid index for a given vector is one less than its length.


As with lists, the elements of a vector can be of any type, and
a single vector can hold more than one type of object.


A vector is written as a sequence of objects separated by whitespace,
preceded by the prefix \texttt{\#{}(} and followed by \texttt{)}.
For example, a vector consisting of the elements \texttt{a}, \texttt{b}, and
\texttt{c} would be written \texttt{\#{}(a b c)}.

\begin{description}

\label{objects_s231}\item[procedure] \texttt{(vector \textit{obj} ...)}



\item[returns] a vector of the objects \texttt{\textit{obj} ...}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(vector) \(\Rightarrow\) \#{}()
(vector 'a 'b 'c) \(\Rightarrow\) \#{}(a b c)
\end{alltt}

\begin{description}

\label{objects_s232}\item[procedure] \texttt{(make-vector \textit{n})}



\item[procedure] \texttt{(make-vector \textit{n} \textit{obj})}



\item[returns] a vector of length \texttt{\textit{n}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer.
If \texttt{\textit{obj}} is supplied, each element of the vector is filled with
\texttt{\textit{obj}}; otherwise, the elements are unspecified.

\begin{alltt}
(make-vector 0) \(\Rightarrow\) \#{}()
(make-vector 0 '\#{}(a)) \(\Rightarrow\) \#{}()
(make-vector 5 '\#{}(a)) \(\Rightarrow\) \#{}(\#{}(a) \#{}(a) \#{}(a) \#{}(a) \#{}(a))
\end{alltt}

\begin{description}

\label{objects_s233}\item[procedure] \texttt{(vector-length \textit{vector})}



\item[returns] the number of elements in \texttt{\textit{vector}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The length of a vector is always an exact nonnegative integer.


\begin{alltt}
(vector-length '\#{}()) \(\Rightarrow\) 0
(vector-length '\#{}(a b c)) \(\Rightarrow\) 3
(vector-length (vector 1 '(2) 3 '\#{}(4 5))) \(\Rightarrow\) 4
(vector-length (make-vector 300)) \(\Rightarrow\) 300
\end{alltt}

\begin{description}

\label{objects_s234}\item[procedure] \texttt{(vector-ref \textit{vector} \textit{n})}



\item[returns] the \texttt{\textit{n}}th element (zero-based) of \texttt{\textit{vector}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{vector}}.

\begin{alltt}
(vector-ref '\#{}(a b c) 0) \(\Rightarrow\) a
(vector-ref '\#{}(a b c) 1) \(\Rightarrow\) b
(vector-ref '\#{}(x y z w) 3) \(\Rightarrow\) w
\end{alltt}

\begin{description}

\label{objects_s235}\item[procedure] \texttt{(vector-set! \textit{vector} \textit{n} \textit{obj})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{vector}}.
\texttt{vector-set!} changes the \texttt{\textit{n}}th element of \texttt{\textit{vector}} to \texttt{\textit{obj}}.

\begin{alltt}
(let ([v (vector 'a 'b 'c 'd 'e)])
  (vector-set! v 2 'x)
  v) \(\Rightarrow\) \#{}(a b x d e)
\end{alltt}

\begin{description}

\label{objects_s236}\item[procedure] \texttt{(vector-fill! \textit{vector} \textit{obj})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{vector-fill!} replaces each element of \texttt{\textit{vector}} with \texttt{\textit{obj}}.
It may be defined without error checks as follows.

\begin{alltt}
(define vector-fill!
  (lambda (v x)
    (let ([n (vector-length v)])
      (do ([i 0 (+ i 1)])
          ((= i n))
        (vector-set! v i x)))))

(let ([v (vector 1 2 3)])
  (vector-fill! v 0)
  v) \(\Rightarrow\) \#{}(0 0 0)
\end{alltt}

\begin{description}

\label{objects_s237}\item[procedure] \texttt{(vector-\textgreater{}list \textit{vector})}



\item[returns] a list of the elements of \texttt{\textit{vector}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{vector-\textgreater{}list} provides a convenient method for applying list-processing
operations to vectors.
It may be defined without error checks as follows.

\begin{alltt}
(define vector-\textgreater{}list
  (lambda (s)
    (do ([i (- (vector-length s) 1) (- i 1)]
         [ls '() (cons (vector-ref s i) ls)])
        ((\textless{} i 0) ls))))

(vector-\textgreater{}list (vector)) \(\Rightarrow\) ()
(vector-\textgreater{}list '\#{}(a b c)) \(\Rightarrow\) (a b c)

(let ((v '\#{}(1 2 3 4 5)))
  (apply * (vector-\textgreater{}list v))) \(\Rightarrow\) 120
\end{alltt}

\begin{description}

\label{objects_s238}\item[procedure] \texttt{(list-\textgreater{}vector \textit{list})}



\item[returns] a vector of the elements of \texttt{\textit{list}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{list-\textgreater{}vector} is the functional inverse of \texttt{vector-\textgreater{}list}.
The two procedures are often used in combination
to take advantage of a list-processing operation.
A vector may be converted to a list with \texttt{vector-\textgreater{}list}, this list
processed in some manner to produce a new list, and the new list
converted back into a vector with \texttt{list-\textgreater{}vector}.
\texttt{list-\textgreater{}vector} may be defined without error checks as follows.

\begin{alltt}
(define list-\textgreater{}vector
  (lambda (ls)
    (let ([s (make-vector (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (vector-set! s i (car ls))))))

(list-\textgreater{}vector '()) \(\Rightarrow\) \#{}()
(list-\textgreater{}vector '(a b c)) \(\Rightarrow\) \#{}(a b c)

(let ([v '\#{}(1 2 3 4 5)])
  (let ([ls (vector-\textgreater{}list v)])
    (list-\textgreater{}vector (map * ls ls)))) \(\Rightarrow\) \#{}(1 4 9 16 25)
\end{alltt}

\begin{description}

\label{objects_s239}\item[procedure] \texttt{(vector-sort \textit{predicate} \textit{vector})}



\item[returns] a vector containing the elements of \texttt{\textit{vector}}, sorted according to \texttt{\textit{predicate}}


\item[procedure] \texttt{(vector-sort! \textit{predicate} \textit{vector})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs sorting)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{predicate}} should be a procedure that expects two arguments and
returns \texttt{\#{}t} if its first argument must precede its second in
the sorted vector.
That is, if \texttt{\textit{predicate}} is applied to two elements \texttt{\textit{x}} and
\texttt{\textit{y}}, where \texttt{\textit{x}} appears after \texttt{\textit{y}} in the input vector,
the predicate should return true only if
\texttt{\textit{x}} should appear before \texttt{\textit{y}}
in the output vector.
If this constraint is met,
\texttt{vector-sort} performs a stable sort, i.e., two elements are
reordered only when necessary according to \texttt{\textit{predicate}}.
\texttt{vector-sort!} performs the sort destructively and
does not necessarily perform a stable sort.
Duplicate elements are not removed.
\texttt{\textit{predicate}} should not have any side effects.

\texttt{vector-sort} may call \texttt{\textit{predicate}} up to \textit{n}log\textit{n} times,
where \textit{n} is the length of \texttt{\textit{vector}}, while
\texttt{vector-sort!} may call the predicate up to \textit{n}\textsuperscript{2} times.
The looser bound for \texttt{vector-sort!} allows an implementation to
use a quicksort algorithm, which may be faster in some cases than
algorithms that have the tighter \textit{n}log\textit{n} bound.

\begin{alltt}
(vector-sort \textless{} '\#{}(3 4 2 1 2 5)) \(\Rightarrow\) \#{}(1 2 2 3 4 5)
(vector-sort \textgreater{} '\#{}(0.5 1/2)) \(\Rightarrow\) \#{}(0.5 1/2)
(vector-sort \textgreater{} '\#{}(1/2 0.5)) \(\Rightarrow\) \#{}(1/2 0.5)

(let ([v (vector 3 4 2 1 2 5)])
  (vector-sort! \textless{} v)
  v) \(\Rightarrow\) \#{}(1 2 2 3 4 5)
\end{alltt}

\section{\label{objects_g116}\label{objects_h10}Bytevectors\label{objects_SECTBYTEVECTORS}}



Bytevectors are vectors of raw binary data.
Although nominally organized as a sequence of exact unsigned 8-bit integers, a
bytevector can be interpreted as a sequence of exact signed 8-bit integers,
exact signed or unsigned 16-bit, 32-bit, 64-bit, or arbitrary-precision
integers, IEEE single or double floating-point numbers, or arbitrary
combinations of the above.


The length of a bytevector is the number of 8-bit bytes it stores,
and indices into a bytevector are always given as byte offsets.
Any data element may be aligned at any byte offset, regardless of the
underlying hardware's alignment requirements, and may be represented using
a specified endianness (see below) that differs from that prescribed
by the hardware.
Special, typically more efficient operators are provided for
16-, 32-, and 64-bit integers and single and double floats that are
in their \textit{native} format, i.e,. with the endianness of
the underlying hardware and stored at an index that is a multiple of
the size in bytes of the integer or float.


The endianness of a multi-byte data value determines how it is laid
out in memory.
In \textit{big-endian} format, the value is laid out with the more
significant bytes at lower indices, while in \textit{little-endian} format,
the value is laid out with the more significant bytes at higher
indices.
When a bytevector procedure accepts an endianness argument, the argument
may be the symbol \texttt{big}, representing the big-endian format, or the
symbol \texttt{little}, representing the little-endian format.
Implementations may extend these procedures to accept other endianness
symbols.
The native endianness of the implementation may be obtained via
the procedure \texttt{native-endianness}.


Bytevectors are written with the \texttt{\#{}vu8(} prefix in place of the
\texttt{\#{}(} prefix for vectors, e.g., \texttt{\#{}vu8(1 2 3)}.
The elements of a bytevector specified in this manner are always given as
8-bit unsigned exact integers, i.e., integers from 0 to 255 inclusive,
written using any valid syntax for such numbers.
Like strings, bytevectors are self-evaluating, so they need not be
quoted.


\begin{alltt}
'\#{}vu8(1 2 3) \(\Rightarrow\) \#{}vu8(1 2 3)
\#{}vu8(1 2 3) \(\Rightarrow\) \#{}vu8(1 2 3)
\#{}vu8(\#{}x3f \#{}x7f \#{}xbf \#{}xff) \(\Rightarrow\) \#{}vu8(63 127 191 255)
\end{alltt}

\begin{description}

\label{objects_s240}\item[syntax] \texttt{(endianness \textit{symbol})}



\item[returns] \texttt{\textit{symbol}}


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{symbol}} must be the symbol \texttt{little}, the symbol \texttt{big},
or some other symbol recognized by the implementation as an endianness
symbol.
It is a syntax violation if \texttt{\textit{symbol}} is not a symbol or if it is not
recognized by the implementation as an endianness symbol.

\begin{alltt}
(endianness little) \(\Rightarrow\) little
(endianness big) \(\Rightarrow\) big
(endianness "spam") \(\Rightarrow\) \textit{exception}
\end{alltt}

\begin{description}

\label{objects_s241}\item[procedure] \texttt{(native-endianness)}



\item[returns] a symbol naming the implementation's native endianness


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}


The return value is the symbol \texttt{little}, the symbol \texttt{big},
or some other endianness symbol recognized by the implementation.
It typically reflects the endianness of the underlying hardware.


\texttt{(symbol? (native-endianness)) \(\Rightarrow\) \#{}t}
\begin{description}

\label{objects_s242}\item[procedure] \texttt{(make-bytevector \textit{n})}



\item[procedure] \texttt{(make-bytevector \textit{n} \textit{fill})}



\item[returns] a new bytevector of length \texttt{\textit{n}}


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{fill}} is supplied, each element of the bytevector is initialized
to \texttt{\textit{fill}}; otherwise, the elements are unspecified.
The \texttt{\textit{fill}} value must be a signed or unsigned 8-bit value, i.e.,
a value in the range -128 to 255 inclusive.
A negative fill value is treated as its two's complement equivalent.


\begin{alltt}
(make-bytevector 0) \(\Rightarrow\) \#{}vu8()
(make-bytevector 0 7) \(\Rightarrow\) \#{}vu8()
(make-bytevector 5 7) \(\Rightarrow\) \#{}vu8(7 7 7 7 7)
(make-bytevector 5 -7) \(\Rightarrow\) \#{}vu8(249 249 249 249 249)
\end{alltt}

\begin{description}

\label{objects_s243}\item[procedure] \texttt{(bytevector-length \textit{bytevector})}



\item[returns] the length of \texttt{\textit{bytevector}} in 8-bit bytes


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(bytevector-length \#{}vu8()) \(\Rightarrow\) 0
(bytevector-length \#{}vu8(1 2 3)) \(\Rightarrow\) 3
(bytevector-length (make-bytevector 300)) \(\Rightarrow\) 300
\end{alltt}

\begin{description}

\label{objects_s244}\item[procedure] \texttt{(bytevector=? \textit{bytevector\textsubscript{1}} \textit{bytevector\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if the relation holds, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}


Two bytevectors are equal by \texttt{bytevector=?} if and only if they
have the same length and same contents.


\begin{alltt}
(bytevector=? \#{}vu8() \#{}vu8()) \(\Rightarrow\) \#{}t
(bytevector=? (make-bytevector 3 0) \#{}vu8(0 0 0)) \(\Rightarrow\) \#{}t
(bytevector=? (make-bytevector 5 0) \#{}vu8(0 0 0)) \(\Rightarrow\) \#{}f
(bytevector=? \#{}vu8(1 127 128 255) \#{}vu8(255 128 127 1)) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s245}\item[procedure] \texttt{(bytevector-fill! \textit{bytevector} \textit{fill})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}


The \texttt{\textit{fill}} value must be a signed or unsigned 8-bit value, i.e.,
a value in the range -128 to 255 inclusive.
A negative fill value is treated as its two's complement equivalent.

\texttt{bytevector-fill!} replaces each element of \texttt{\textit{bytevector}} with
\texttt{\textit{fill}}.

\begin{alltt}
(let ([v (make-bytevector 6)])
  (bytevector-fill! v 255)
  v) \(\Rightarrow\) \#{}vu8(255 255 255 255 255 255)

(let ([v (make-bytevector 6)])
  (bytevector-fill! v -128)
  v) \(\Rightarrow\) \#{}vu8(128 128 128 128 128 128)
\end{alltt}

\begin{description}

\label{objects_s246}\item[procedure] \texttt{(bytevector-copy \textit{bytevector})}



\item[returns] a new bytevector that is a copy of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{bytevector-copy} creates a new bytevector with the same length and
contents as \texttt{\textit{bytevector}}.

\begin{alltt}
(bytevector-copy \#{}vu8(1 127 128 255)) \(\Rightarrow\) \#{}vu8(1 127 128 255)

(let ([v \#{}vu8(1 127 128 255)])
  (eq? v (bytevector-copy v))) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s247}\item[procedure] \texttt{(bytevector-copy! \textit{src} \textit{src-start} \textit{dst} \textit{dst-start} \textit{n})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{src}} and \texttt{\textit{dst}} must be bytevectors.
\texttt{\textit{src-start}}, \texttt{\textit{dst-start}}, and \texttt{\textit{n}} must be exact nonnegative
integers.
The sum of \texttt{\textit{src-start}} and \texttt{\textit{n}} must not exceed the length of \texttt{\textit{src}},
and the sum of \texttt{\textit{dst-start}} and \texttt{\textit{n}} must not exceed the length of \texttt{\textit{dst}}.
\texttt{bytevector-copy!} overwrites the \texttt{\textit{n}} bytes of \texttt{\textit{dst}}
starting at \texttt{\textit{dst-start}} with the \texttt{\textit{n}} bytes of \texttt{\textit{dst}}
starting at \texttt{\textit{src-start}}.
This works even if \texttt{\textit{dst}} is the same bytevector as \texttt{\textit{src}} and the
source and destination locations overlap.
That is, the destination is filled with the bytes that appeared at the
source before the operation began.

\begin{alltt}
(define v1 \#{}vu8(31 63 95 127 159 191 223 255))
(define v2 (make-bytevector 10 0))

(bytevector-copy! v1 2 v2 1 4)
v2 \(\Rightarrow\) \#{}vu8(0 95 127 159 191 0 0 0 0 0)
 
(bytevector-copy! v1 5 v2 7 3)
v2 \(\Rightarrow\) \#{}vu8(0 95 127 159 191 0 0 191 223 255)
 
(bytevector-copy! v2 3 v2 0 6)
v2 \(\Rightarrow\) \#{}vu8(159 191 0 0 191 223 0 191 223 255)
 
(bytevector-copy! v2 0 v2 1 9)
v2 \(\Rightarrow\) \#{}vu8(159 159 191 0 0 191 223 0 191 223)
\end{alltt}

\begin{description}

\label{objects_s248}\item[procedure] \texttt{(bytevector-u8-ref \textit{bytevector} \textit{n})}



\item[returns] the 8-bit unsigned byte at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{bytevector}}.

The value is returned as an exact 8-bit unsigned integer, i.e., a value in
the range 0 to 255 inclusive.


\begin{alltt}
(bytevector-u8-ref \#{}vu8(1 127 128 255) 0) \(\Rightarrow\) 1
(bytevector-u8-ref \#{}vu8(1 127 128 255) 2) \(\Rightarrow\) 128
(bytevector-u8-ref \#{}vu8(1 127 128 255) 3) \(\Rightarrow\) 255
\end{alltt}

\begin{description}

\label{objects_s249}\item[procedure] \texttt{(bytevector-s8-ref \textit{bytevector} \textit{n})}



\item[returns] the 8-bit signed byte at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{bytevector}}.

The value returned is an exact 8-bit signed integer, i.e., a value in
the range -128 to 127 inclusive, and is the equivalent of the
stored value treated as a two's complement value.


\begin{alltt}
(bytevector-s8-ref \#{}vu8(1 127 128 255) 0) \(\Rightarrow\) 1
(bytevector-s8-ref \#{}vu8(1 127 128 255) 1) \(\Rightarrow\) 127
(bytevector-s8-ref \#{}vu8(1 127 128 255) 2) \(\Rightarrow\) -128
(bytevector-s8-ref \#{}vu8(1 127 128 255) 3) \(\Rightarrow\) -1
\end{alltt}

\begin{description}

\label{objects_s250}\item[procedure] \texttt{(bytevector-u8-set! \textit{bytevector} \textit{n} \textit{u8})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{bytevector}}.
\texttt{\textit{u8}} must be an 8-bit unsigned value, i.e., a value in the range
0 to 255 inclusive.
\texttt{bytevector-u8-set!} changes the 8-bit value at index \texttt{\textit{n}} (zero-based)
of \texttt{\textit{bytevector}} to \texttt{\textit{u8}}.

\begin{alltt}
(let ([v (make-bytevector 5 -1)])
  (bytevector-u8-set! v 2 128)
  v) \(\Rightarrow\) \#{}vu8(255 255 128 255 255)
\end{alltt}

\begin{description}

\label{objects_s251}\item[procedure] \texttt{(bytevector-s8-set! \textit{bytevector} \textit{n} \textit{s8})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer less than
the length of \texttt{\textit{bytevector}}.
\texttt{\textit{s8}} must be an 8-bit signed value, i.e., a value in the range
-128 to 127 inclusive.
\texttt{bytevector-s8-set!} changes the 8-bit value at index \texttt{\textit{n}}
(zero-based) of \texttt{\textit{bytevector}} to the two's complement equivalent
of \texttt{\textit{s8}}.

\begin{alltt}
(let ([v (make-bytevector 4 0)])
  (bytevector-s8-set! v 1 100)
  (bytevector-s8-set! v 2 -100)
  v) \(\Rightarrow\) \#{}vu8(0 100 156 0)
\end{alltt}

\begin{description}

\label{objects_s252}\item[procedure] \texttt{(bytevector-\textgreater{}u8-list \textit{bytevector})}



\item[returns] a list of the 8-bit unsigned elements of \texttt{\textit{bytevector}}


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(bytevector-\textgreater{}u8-list (make-bytevector 0)) \(\Rightarrow\) ()
(bytevector-\textgreater{}u8-list \#{}vu8(1 127 128 255)) \(\Rightarrow\) (1 127 128 255)

(let ([v \#{}vu8(1 2 3 255)])
  (apply * (bytevector-\textgreater{}u8-list v))) \(\Rightarrow\) 1530
\end{alltt}

\begin{description}

\label{objects_s253}\item[procedure] \texttt{(u8-list-\textgreater{}bytevector \textit{list})}



\item[returns] a new bytevector of the elements of \texttt{\textit{list}}


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{list}} must consist entirely of
exact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive.

\begin{alltt}
(u8-list-\textgreater{}bytevector '()) \(\Rightarrow\) \#{}vu8()
(u8-list-\textgreater{}bytevector '(1 127 128 255)) \(\Rightarrow\) \#{}vu8(1 127 128 255)

(let ([v \#{}vu8(1 2 3 4 5)])
  (let ([ls (bytevector-\textgreater{}u8-list v)])
    (u8-list-\textgreater{}bytevector (map * ls ls)))) \(\Rightarrow\) \#{}vu8(1 4 9 16 25)
\end{alltt}

\begin{description}

\label{objects_s254}\item[procedure] \texttt{(bytevector-u16-native-ref \textit{bytevector} \textit{n})}



\item[returns] the 16-bit unsigned integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-s16-native-ref \textit{bytevector} \textit{n})}



\item[returns] the 16-bit signed integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-u32-native-ref \textit{bytevector} \textit{n})}



\item[returns] the 32-bit unsigned integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-s32-native-ref \textit{bytevector} \textit{n})}



\item[returns] the 32-bit signed integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-u64-native-ref \textit{bytevector} \textit{n})}



\item[returns] the 64-bit unsigned integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-s64-native-ref \textit{bytevector} \textit{n})}



\item[returns] the 64-bit signed integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit
values, and 8 for 64-bit values.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value must
not exceed the length of \texttt{\textit{bytevector}}.
The native endianness is assumed.

The return value is an exact integer in the appropriate range for
the number of bytes occupied by the value.
Signed values are the equivalent of the stored value treated as a two's
complement value.


\texttt{(define v \#{}vu8(\#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}xdc \#{}xba \#{}x78 \#{}x98))}

If native endianness is big:


\begin{alltt}
(bytevector-u16-native-ref v 2) \(\Rightarrow\) \#{}xfe56
(bytevector-s16-native-ref v 2) \(\Rightarrow\) \#{}x-1aa
(bytevector-s16-native-ref v 6) \(\Rightarrow\) \#{}x7898

(bytevector-u32-native-ref v 0) \(\Rightarrow\) \#{}x1234fe56
(bytevector-s32-native-ref v 0) \(\Rightarrow\) \#{}x1234fe56
(bytevector-s32-native-ref v 4) \(\Rightarrow\) \#{}x-23458768

(bytevector-u64-native-ref v 0) \(\Rightarrow\) \#{}x1234fe56dcba7898
(bytevector-s64-native-ref v 0) \(\Rightarrow\) \#{}x1234fe56dcba7898
\end{alltt}


If native endianness is little:


\begin{alltt}
(bytevector-u16-native-ref v 2) \(\Rightarrow\) \#{}x56fe
(bytevector-s16-native-ref v 2) \(\Rightarrow\) \#{}x56fe
(bytevector-s16-native-ref v 6) \(\Rightarrow\) \#{}x-6788

(bytevector-u32-native-ref v 0) \(\Rightarrow\) \#{}x56fe3412
(bytevector-s32-native-ref v 0) \(\Rightarrow\) \#{}x56fe3412
(bytevector-s32-native-ref v 4) \(\Rightarrow\) \#{}x-67874524

(bytevector-u64-native-ref v 0) \(\Rightarrow\) \#{}x9878badc56fe3412
(bytevector-s64-native-ref v 0) \(\Rightarrow\) \#{}x-67874523a901cbee
\end{alltt}

\begin{description}

\label{objects_s255}\item[procedure] \texttt{(bytevector-u16-native-set! \textit{bytevector} \textit{n} \textit{u16})}



\item[procedure] \texttt{(bytevector-s16-native-set! \textit{bytevector} \textit{n} \textit{s16})}



\item[procedure] \texttt{(bytevector-u32-native-set! \textit{bytevector} \textit{n} \textit{u32})}



\item[procedure] \texttt{(bytevector-s32-native-set! \textit{bytevector} \textit{n} \textit{s32})}



\item[procedure] \texttt{(bytevector-u64-native-set! \textit{bytevector} \textit{n} \textit{u64})}



\item[procedure] \texttt{(bytevector-s64-native-set! \textit{bytevector} \textit{n} \textit{s64})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit
values, and 8 for 64-bit values.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value must
not exceed the length \texttt{\textit{bytevector}}.
\texttt{\textit{u16}} must be a 16-bit unsigned value, i.e., a value in the range
0 to 2\textsuperscript{16} - 1 inclusive;
\texttt{\textit{s16}} must be a 16-bit signed value, i.e., a value in the range
-2\textsuperscript{15} to 2\textsuperscript{15} - 1 inclusive;
\texttt{\textit{u32}} must be a 32-bit unsigned value, i.e., a value in the range
0 to 2\textsuperscript{32} - 1 inclusive;
\texttt{\textit{s32}} must be a 32-bit signed value, i.e., a value in the range
-2\textsuperscript{31} to 2\textsuperscript{31} - 1 inclusive;
\texttt{\textit{u64}} must be a 64-bit unsigned value, i.e., a value in the range
0 to 2\textsuperscript{64} - 1 inclusive; and
\texttt{\textit{s64}} must be a 64-bit signed value, i.e., a value in the range
-2\textsuperscript{63} to 2\textsuperscript{63} - 1 inclusive.
The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting
at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}}.
Negative values are stored as their two's complement equivalent.


\begin{alltt}
(define v (make-bytevector 8 0))
(bytevector-u16-native-set! v 0 \#{}xfe56)
(bytevector-s16-native-set! v 2 \#{}x-1aa)
(bytevector-s16-native-set! v 4 \#{}x7898)
\end{alltt}


If native endianness is big:


\texttt{v \(\Rightarrow\) \#{}vu8(\#{}xfe \#{}x56 \#{}xfe \#{}x56 \#{}x78 \#{}x98 \#{}x00 \#{}x00)}

If native endianness is little:


\texttt{v \(\Rightarrow\) \#{}vu8(\#{}x56 \#{}xfe \#{}x56 \#{}xfe \#{}x98 \#{}x78 \#{}x00 \#{}x00)}

\begin{alltt}
(define v (make-bytevector 16 0))
(bytevector-u32-native-set! v 0 \#{}x1234fe56)
(bytevector-s32-native-set! v 4 \#{}x1234fe56)
(bytevector-s32-native-set! v 8 \#{}x-23458768)
\end{alltt}


If native endianness is big:


\begin{alltt}
v \(\Rightarrow\) \#{}vu8(\#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}x12 \#{}x34 \#{}xfe \#{}x56
        \#{}xdc \#{}xba \#{}x78 \#{}x98 \#{}x00 \#{}x00 \#{}x00 \#{}x00)
\end{alltt}


If native endianness is little:


\begin{alltt}
v \(\Rightarrow\) \#{}vu8(\#{}x56 \#{}xfe \#{}x34 \#{}x12 \#{}x56 \#{}xfe \#{}x34 \#{}x12
        \#{}x98 \#{}x78 \#{}xba \#{}xdc \#{}x00 \#{}x00 \#{}x00 \#{}x00)
\end{alltt}


\begin{alltt}
(define v (make-bytevector 24 0))
(bytevector-u64-native-set! v 0 \#{}x1234fe56dcba7898)
(bytevector-s64-native-set! v 8 \#{}x1234fe56dcba7898)
(bytevector-s64-native-set! v 16 \#{}x-67874523a901cbee)
\end{alltt}


If native endianness is big:


\begin{alltt}
v \(\Rightarrow\) \#{}vu8(\#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}xdc \#{}xba \#{}x78 \#{}x98
        \#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}xdc \#{}xba \#{}x78 \#{}x98
        \#{}x98 \#{}x78 \#{}xba \#{}xdc \#{}x56 \#{}xfe \#{}x34 \#{}x12)
\end{alltt}


If native endianness is little:


\begin{alltt}
v \(\Rightarrow\) \#{}vu8(\#{}x98 \#{}x78 \#{}xba \#{}xdc \#{}x56 \#{}xfe \#{}x34 \#{}x12
        \#{}x98 \#{}x78 \#{}xba \#{}xdc \#{}x56 \#{}xfe \#{}x34 \#{}x12
        \#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}xdc \#{}xba \#{}x78 \#{}x98)
\end{alltt}

\begin{description}

\label{objects_s256}\item[procedure] \texttt{(bytevector-u16-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the 16-bit unsigned integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-s16-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the 16-bit signed integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-u32-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the 32-bit unsigned integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-s32-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the 32-bit signed integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-u64-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the 64-bit unsigned integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-s64-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the 64-bit signed integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value
(2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values)
must not exceed the length of \texttt{\textit{bytevector}}.
\texttt{\textit{n}} need \textit{not} be a multiple of the
number of bytes occupied by the value.
\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for
the number of bytes occupied by the value.
Signed values are the equivalent of the stored value treated as a two's
complement value.


\begin{alltt}
(define v \#{}vu8(\#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}xdc \#{}xba \#{}x78 \#{}x98 \#{}x9a \#{}x76))
(bytevector-u16-ref v 0 (endianness big)) \(\Rightarrow\) \#{}x1234
(bytevector-s16-ref v 1 (endianness big)) \(\Rightarrow\) \#{}x34fe
(bytevector-s16-ref v 5 (endianness big)) \(\Rightarrow\) \#{}x-4588

(bytevector-u32-ref v 2 'big) \(\Rightarrow\) \#{}xfe56dcba
(bytevector-s32-ref v 3 'big) \(\Rightarrow\) \#{}x56dcba78
(bytevector-s32-ref v 4 'big) \(\Rightarrow\) \#{}x-23458768

(bytevector-u64-ref v 0 'big) \(\Rightarrow\) \#{}x1234fe56dcba7898
(bytevector-s64-ref v 1 'big) \(\Rightarrow\) \#{}x34fe56dcba78989a

(bytevector-u16-ref v 0 (endianness little)) \(\Rightarrow\) \#{}x3412
(bytevector-s16-ref v 1 (endianness little)) \(\Rightarrow\) \#{}x-1cc
(bytevector-s16-ref v 5 (endianness little)) \(\Rightarrow\) \#{}x78ba

(bytevector-u32-ref v 2 'little) \(\Rightarrow\) \#{}xbadc56fe
(bytevector-s32-ref v 3 'little) \(\Rightarrow\) \#{}x78badc56
(bytevector-s32-ref v 4 'little) \(\Rightarrow\) \#{}x-67874524

(bytevector-u64-ref v 0 'little) \(\Rightarrow\) \#{}x9878badc56fe3412
(bytevector-s64-ref v 1 'little) \(\Rightarrow\) \#{}x-6567874523a901cc
\end{alltt}

\begin{description}

\label{objects_s257}\item[procedure] \texttt{(bytevector-u16-set! \textit{bytevector} \textit{n} \textit{u16} \textit{eness})}



\item[procedure] \texttt{(bytevector-s16-set! \textit{bytevector} \textit{n} \textit{s16} \textit{eness})}



\item[procedure] \texttt{(bytevector-u32-set! \textit{bytevector} \textit{n} \textit{u32} \textit{eness})}



\item[procedure] \texttt{(bytevector-s32-set! \textit{bytevector} \textit{n} \textit{s32} \textit{eness})}



\item[procedure] \texttt{(bytevector-u64-set! \textit{bytevector} \textit{n} \textit{u64} \textit{eness})}



\item[procedure] \texttt{(bytevector-s64-set! \textit{bytevector} \textit{n} \textit{s64} \textit{eness})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value must
not exceed the length of \texttt{\textit{bytevector}}.
\texttt{\textit{n}} need \textit{not} be a multiple of the
number of bytes occupied by the value.
\texttt{\textit{u16}} must be a 16-bit unsigned value, i.e., a value in the range
0 to 2\textsuperscript{16} - 1 inclusive;
\texttt{\textit{s16}} must be a 16-bit signed value, i.e., a value in the range
-2\textsuperscript{15} to 2\textsuperscript{15} - 1 inclusive;
\texttt{\textit{u32}} must be a 32-bit unsigned value, i.e., a value in the range
0 to 2\textsuperscript{32} - 1 inclusive;
\texttt{\textit{s32}} must be a 32-bit signed value, i.e., a value in the range
-2\textsuperscript{31} to 2\textsuperscript{31} - 1 inclusive;
\texttt{\textit{u64}} must be a 64-bit unsigned value, i.e., a value in the range
0 to 2\textsuperscript{64} - 1 inclusive; and
\texttt{\textit{s64}} must be a 64-bit signed value, i.e., a value in the range
-2\textsuperscript{63} to 2\textsuperscript{63} - 1 inclusive.
\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting
at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}}.
Negative values are stored as their two's complement equivalent.


\begin{alltt}
(define v (make-bytevector 8 0))
(bytevector-u16-set! v 0 \#{}xfe56 (endianness big))
(bytevector-s16-set! v 3 \#{}x-1aa (endianness little))
(bytevector-s16-set! v 5 \#{}x7898 (endianness big))
v \(\Rightarrow\) \#{}vu8(\#{}xfe \#{}x56 \#{}x0 \#{}x56 \#{}xfe \#{}x78 \#{}x98 \#{}x0)

(define v (make-bytevector 16 0))
(bytevector-u32-set! v 0 \#{}x1234fe56 'little)
(bytevector-s32-set! v 6 \#{}x1234fe56 'big)
(bytevector-s32-set! v 11 \#{}x-23458768 'little)
v \(\Rightarrow\) \#{}vu8(\#{}x56 \#{}xfe \#{}x34 \#{}x12 \#{}x0 \#{}x0
        \#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}x0
        \#{}x98 \#{}x78 \#{}xba \#{}xdc \#{}x0)

(define v (make-bytevector 28 0))
(bytevector-u64-set! v 0 \#{}x1234fe56dcba7898 'little)
(bytevector-s64-set! v 10 \#{}x1234fe56dcba7898 'big)
(bytevector-s64-set! v 19 \#{}x-67874523a901cbee 'big)
v \(\Rightarrow\) \#{}vu8(\#{}x98 \#{}x78 \#{}xba \#{}xdc \#{}x56 \#{}xfe \#{}x34 \#{}x12 \#{}x0 \#{}x0
        \#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}xdc \#{}xba \#{}x78 \#{}x98 \#{}x0
        \#{}x98 \#{}x78 \#{}xba \#{}xdc \#{}x56 \#{}xfe \#{}x34 \#{}x12 \#{}x0)
\end{alltt}

\begin{description}

\label{objects_s258}\item[procedure] \texttt{(bytevector-uint-ref \textit{bytevector} \textit{n} \textit{eness} \textit{size})}



\item[returns] the \texttt{\textit{size}}-byte unsigned integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-sint-ref \textit{bytevector} \textit{n} \textit{eness} \textit{size})}



\item[returns] the \texttt{\textit{size}}-byte signed integer at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer and
indexes the starting byte of the value.
\texttt{\textit{size}} must be an exact positive integer and specifies the number
of bytes occupied by the value.
The sum of \texttt{\textit{n}} and \texttt{\textit{size}} must not exceed the length
of \texttt{\textit{bytevector}}.
\texttt{\textit{n}} need \textit{not} be a multiple of the
number of bytes occupied by the value.
\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for
the number of bytes occupied by the value.
Signed values are the equivalent of the stored value treated as a two's
complement value.


\begin{alltt}
(define v \#{}vu8(\#{}x12 \#{}x34 \#{}xfe \#{}x56 \#{}xdc \#{}xba \#{}x78 \#{}x98 \#{}x9a \#{}x76))

(bytevector-uint-ref v 0 'big 1) \(\Rightarrow\) \#{}x12
(bytevector-uint-ref v 0 'little 1) \(\Rightarrow\) \#{}x12
(bytevector-uint-ref v 1 'big 3) \(\Rightarrow\) \#{}x34fe56
(bytevector-uint-ref v 2 'little 7) \(\Rightarrow\) \#{}x9a9878badc56fe

(bytevector-sint-ref v 2 'big 1) \(\Rightarrow\) \#{}x-02
(bytevector-sint-ref v 1 'little 6) \(\Rightarrow\) \#{}x78badc56fe34
(bytevector-sint-ref v 2 'little 7) \(\Rightarrow\) \#{}x-6567874523a902

(bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) \(\Rightarrow\) -1
\end{alltt}

\begin{description}

\label{objects_s259}\item[procedure] \texttt{(bytevector-uint-set! \textit{bytevector} \textit{n} \textit{uint} \textit{eness} \textit{size})}



\item[procedure] \texttt{(bytevector-sint-set! \textit{bytevector} \textit{n} \textit{sint} \textit{eness} \textit{size})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer and
indexes the starting byte of the value.
\texttt{\textit{size}} must be an exact positive integer and specifies the number
of bytes occupied by the value.
The sum of \texttt{\textit{n}} and \texttt{\textit{size}} must not exceed the length
of \texttt{\textit{bytevector}}.
\texttt{\textit{n}} need \textit{not} be a multiple of the
number of bytes occupied by the value.
\texttt{\textit{uint}} must be an exact integer in the range
0 to 2\textsuperscript{\textit{size}·8} - 1 inclusive.
\texttt{\textit{sint}} must be an exact integer in the range
-2\textsuperscript{\textit{size}·8-1} to 2\textsuperscript{\textit{size}·8-1} - 1 inclusive.
\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.

These procedures store the given value in the \texttt{\textit{size}} bytes starting
at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}}.
Negative values are stored as their two's complement equivalent.


\begin{alltt}
(define v (make-bytevector 5 0))
(bytevector-uint-set! v 1 \#{}x123456 (endianness big) 3)
v \(\Rightarrow\) \#{}vu8(0 \#{}x12 \#{}x34 \#{}x56 0)

(define v (make-bytevector 7 -1))
(bytevector-sint-set! v 1 \#{}x-8000000000 (endianness little) 5)
v \(\Rightarrow\) \#{}vu8(\#{}xff 0 0 0 0 \#{}x80 \#{}xff)
\end{alltt}

\begin{description}

\label{objects_s260}\item[procedure] \texttt{(bytevector-\textgreater{}uint-list \textit{bytevector} \textit{eness} \textit{size})}



\item[returns] a new list of the \texttt{\textit{size}}-bit unsigned elements of \texttt{\textit{bytevector}}


\item[procedure] \texttt{(bytevector-\textgreater{}sint-list \textit{bytevector} \textit{eness} \textit{size})}



\item[returns] a new list of the \texttt{\textit{size}}-bit signed elements of \texttt{\textit{bytevector}}


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.
\texttt{\textit{size}} must be an exact positive integer and specifies the number
of bytes occupied by the value.
It must be a value that evenly divides the length of \texttt{\textit{bytevector}}.

\begin{alltt}
(bytevector-\textgreater{}uint-list (make-bytevector 0) 'little 3) \(\Rightarrow\) ()

(let ([v \#{}vu8(1 2 3 4 5 6)])
  (bytevector-\textgreater{}uint-list v 'big 3)) \(\Rightarrow\) (\#{}x010203 \#{}x040506)

(let ([v (make-bytevector 80 -1)])
  (bytevector-\textgreater{}sint-list v 'big 20)) \(\Rightarrow\) (-1 -1 -1 -1)
\end{alltt}

\begin{description}

\label{objects_s261}\item[procedure] \texttt{(uint-list-\textgreater{}bytevector \textit{list} \textit{eness} \textit{size})}



\item[procedure] \texttt{(sint-list-\textgreater{}bytevector \textit{list} \textit{eness} \textit{size})}



\item[returns] a new bytevector of the elements of \texttt{\textit{list}}


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.
\texttt{\textit{size}} must be an exact positive integer and specifies the number
of bytes occupied by the value.
For \texttt{uint-list-\textgreater{}bytevector}, \texttt{\textit{list}} must consist entirely of
\texttt{\textit{size}}-byte exact unsigned integers, i.e., values in the range
0 to 2\textsuperscript{\textit{size}·8} - 1 inclusive.
For \texttt{sint-list-\textgreater{}bytevector}, \texttt{\textit{list}} must consist entirely of
\texttt{\textit{size}}-byte exact signed integers, i.e., values in the range
-2\textsuperscript{\textit{size}·8-1} to 2\textsuperscript{\textit{size}·8-1} - 1 inclusive.
Each value occupies \texttt{\textit{size}} bytes in the resulting bytevector, whose
length is thus \texttt{\textit{size}} times the length of \texttt{\textit{list}}.

\begin{alltt}
(uint-list-\textgreater{}bytevector '() 'big 25) \(\Rightarrow\) \#{}vu8()
(sint-list-\textgreater{}bytevector '(0 -1) 'big 3) \(\Rightarrow\) \#{}vu8(0 0 0 \#{}xff \#{}xff \#{}xff)

(define (f size)
  (let ([ls (list (- (expt 2 (- (* 8 size) 1)))
                  (- (expt 2 (- (* 8 size) 1)) 1))])
    (sint-list-\textgreater{}bytevector ls 'little size)))
(f 6) \(\Rightarrow\) \#{}vu8(\#{}x00 \#{}x00 \#{}x00 \#{}x00 \#{}x00 \#{}x80
            \#{}xff \#{}xff \#{}xff \#{}xff \#{}xff \#{}x7f)
\end{alltt}

\begin{description}

\label{objects_s262}\item[procedure] \texttt{(bytevector-ieee-single-native-ref \textit{bytevector} \textit{n})}



\item[returns] the single floating-point value at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-ieee-double-native-ref \textit{bytevector} \textit{n})}



\item[returns] the double floating-point value at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 4 for single floats, 8 for double.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value must
not exceed the length of \texttt{\textit{bytevector}}.
The native endianness is assumed.

The return value is an inexact real number.
Examples appear after the mutation operators below.

\begin{description}

\label{objects_s263}\item[procedure] \texttt{(bytevector-ieee-single-native-set! \textit{bytevector} \textit{n} \textit{x})}



\item[procedure] \texttt{(bytevector-ieee-double-native-set! \textit{bytevector} \textit{n} \textit{x})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 4 for single floats, 8 for double.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value must
not exceed the length of \texttt{\textit{bytevector}}.
The native endianness is assumed.

These procedures store the given value as an IEEE-754 single or
double floating-point value at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}}.


\begin{alltt}
(define v (make-bytevector 8 0))
(bytevector-ieee-single-native-set! v 0 .125)
(bytevector-ieee-single-native-set! v 4 -3/2)
(list
  (bytevector-ieee-single-native-ref v 0)
  (bytevector-ieee-single-native-ref v 4)) \(\Rightarrow\) (0.125 -1.5)

(bytevector-ieee-double-native-set! v 0 1e23)
(bytevector-ieee-double-native-ref v 0) \(\Rightarrow\) 1e23
\end{alltt}

\begin{description}

\label{objects_s264}\item[procedure] \texttt{(bytevector-ieee-single-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the single floating-point value at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[procedure] \texttt{(bytevector-ieee-double-ref \textit{bytevector} \textit{n} \textit{eness})}



\item[returns] the double floating-point value at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}} 


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value
(4 for a single float, 8 for a double)
must not exceed the length of \texttt{\textit{bytevector}}.
\texttt{\textit{n}} need \textit{not} be a multiple of the
number of bytes occupied by the value.
\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.

The return value is an inexact real number.
Examples appear after the mutation operators below.


\begin{description}

\label{objects_s265}\item[procedure] \texttt{(bytevector-ieee-single-set! \textit{bytevector} \textit{n} \textit{x} \textit{eness})}



\item[procedure] \texttt{(bytevector-ieee-double-set! \textit{bytevector} \textit{n} \textit{x} \textit{eness})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs bytevectors)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{n}} must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of \texttt{\textit{n}} and the number of bytes occupied by the value
(4 for a single float, 8 for a double)
must not exceed the length of \texttt{\textit{bytevector}}.
\texttt{\textit{n}} need \textit{not} be a multiple of the
number of bytes occupied by the value.
\texttt{\textit{eness}} must be a valid endianness symbol naming the endianness.

These procedures store the given value as an IEEE-754 single or double
floating-point value at index \texttt{\textit{n}} (zero-based) of \texttt{\textit{bytevector}}.


\begin{alltt}
(define v (make-bytevector 10 \#{}xc7))
(bytevector-ieee-single-set! v 1 .125 'little)
(bytevector-ieee-single-set! v 6 -3/2 'big)
(list
  (bytevector-ieee-single-ref v 1 'little)
  (bytevector-ieee-single-ref v 6 'big)) \(\Rightarrow\) (0.125 -1.5)
v \(\Rightarrow\) \#{}vu8(\#{}xc7 \#{}x0 \#{}x0 \#{}x0 \#{}x3e \#{}xc7 \#{}xbf \#{}xc0 \#{}x0 \#{}x0)

(bytevector-ieee-double-set! v 1 1e23 'big)
(bytevector-ieee-double-ref v 1 'big) \(\Rightarrow\) 1e23
\end{alltt}

\section{\label{objects_g117}\label{objects_h11}Symbols\label{objects_SECTSYMBOLS}}



\label{objects_s266}Symbols are used for a variety of purposes as symbolic names in
Scheme programs.
Strings could be used for most of the same purposes, but an
important characteristic of symbols makes comparisons between
symbols much more efficient.
This characteristic is that two symbols with the same name are
identical in the sense of \texttt{eq?}.
The reason is that the Scheme reader (invoked by \texttt{get-datum} and \texttt{read})
and the procedure \texttt{string-\textgreater{}symbol} catalog symbols in an internal
\label{objects_s267}symbol table and always return the same symbol whenever the same name is
encountered.
Thus, no character-by-character comparison is needed, as would be
needed to compare two strings.


The property that two symbols may be compared quickly for equivalence
makes them ideally suited for use as identifiers in the representation
of programs, allowing fast comparison of identifiers.
This property also makes symbols useful for a variety of other
purposes.
For example, symbols might be used as messages passed between
procedures, labels for list-structured records, or names for objects
stored in an association list (see \texttt{assq} in Section \ref{objects_g109}).


Symbols are written without double quotes or other bracketing
characters.
Parentheses, double quotes, spaces, and most other characters with a
special meaning to the Scheme reader are not allowed within the printed
representation of a symbol.
These and any other Unicode character may appear anywhere within the
printed representation of a symbol with the syntax \texttt{\#{}\textbackslash{}x\textit{n};},
where \texttt{\textit{n}} consists of one or more hexadecimal digits and represents
a valid Unicode scalar value.


The grammar for symbols on page \pageref{grammar_grammar_symbols} gives a
precise definition of the syntax of symbols.


\begin{description}

\label{objects_s268}\item[procedure] \texttt{(symbol=? \textit{symbol\textsubscript{1}} \textit{symbol\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if the two symbols are the same, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


Symbols can also be compared with \texttt{eq?}, which is typically more
efficient than \texttt{symbol=?}.


\begin{alltt}
(symbol=? 'a 'a) \(\Rightarrow\) \#{}t
(symbol=? 'a (string-\textgreater{}symbol "a")) \(\Rightarrow\) \#{}t
(symbol=? 'a 'b) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s269}\item[procedure] \texttt{(string-\textgreater{}symbol \textit{string})}



\item[returns] a symbol whose name is \texttt{\textit{string}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}

\texttt{string-\textgreater{}symbol} records all symbols it creates in an internal table
that it shares with the system reader.
If a symbol whose name is equivalent to string (according to the predicate
\texttt{string=?}) already exists in the table, this symbol is returned.
Otherwise, a new symbol is created with \texttt{\textit{string}} as its name; this
symbol is entered into the table and returned.

The effect of modifying a string after it is used as an argument to
\texttt{string-\textgreater{}symbol} is unspecified.


\begin{alltt}
(string-\textgreater{}symbol "x") \(\Rightarrow\) x

(eq? (string-\textgreater{}symbol "x") 'x) \(\Rightarrow\) \#{}t
(eq? (string-\textgreater{}symbol "X") 'x) \(\Rightarrow\) \#{}f

(eq? (string-\textgreater{}symbol "x")
     (string-\textgreater{}symbol "x")) \(\Rightarrow\) \#{}t

(string-\textgreater{}symbol "()") \(\Rightarrow\) \textbackslash{}x28;\textbackslash{}x29;
\end{alltt}

\begin{description}

\label{objects_s270}\item[procedure] \texttt{(symbol-\textgreater{}string \textit{symbol})}



\item[returns] a string, the name of \texttt{\textit{symbol}}


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The string returned by \texttt{symbol-\textgreater{}string} should be treated as
immutable.
Unpredictable behavior can result if a string passed to
\texttt{string-\textgreater{}symbol} is altered with
\texttt{string-set!} or by any other means.


\begin{alltt}
(symbol-\textgreater{}string 'xyz) \(\Rightarrow\) "xyz"
(symbol-\textgreater{}string 'Hi) \(\Rightarrow\) "Hi"
(symbol-\textgreater{}string (string-\textgreater{}symbol "()")) \(\Rightarrow\) "()"
\end{alltt}

\section{\label{objects_g118}\label{objects_h12}Booleans\label{objects_SECTMISCBOOLEANS}}



While every Scheme object has a truth value when used in a conditional
context, with every object but \texttt{\#{}f} counting as true,
Scheme provides the dedicated true value \texttt{\#{}t} for use when
a value of an expression should convey nothing more than that it is true.

\begin{description}

\label{objects_s271}\item[procedure] \texttt{(boolean=? \textit{boolean\textsubscript{1}} \textit{boolean\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if the two booleans are the same, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs base)}, \texttt{(rnrs)}
\end{description}


The boolean values \texttt{\#{}t} and \texttt{\#{}f} may also be compared with
\texttt{eq?}, which is typically more efficient than \texttt{boolean=?}.


\begin{alltt}
(boolean=? \#{}t \#{}t) \(\Rightarrow\) \#{}t
(boolean=? \#{}t \#{}f) \(\Rightarrow\) \#{}f
(boolean=? \#{}t (\textless{} 3 4)) \(\Rightarrow\) \#{}t
\end{alltt}

\section{\label{objects_g119}\label{objects_h13}Hashtables\label{objects_SECTHASHTABLES}}



\label{objects_s272}\label{objects_s273}Hashtables represent sets of associations between
arbitrary Scheme values.
They serve essentially the same purpose as association lists (see page
 \pageref{objects_page_assq}) but are typically much faster when large numbers
of associations are involved.

\begin{description}

\label{objects_s274}\item[procedure] \texttt{(make-eq-hashtable)}



\item[procedure] \texttt{(make-eq-hashtable \textit{size})}



\item[returns] a new mutable eq hashtable


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{size}} is provided, it must be a nonnegative exact integer
indicating approximately how many elements the hashtable should
initially hold.
Hashtables grow as needed, but when the hashtable grows it generally must
rehash all of the existing elements.
Providing a nonzero \texttt{\textit{size}} can help limit the amount of rehashing
that must be done as the table is initially populated.


An eq hashtable compares keys using the \texttt{eq?} (pointer equality)
procedure and typically employs a hash function based on object addresses.
Its hash and equivalence functions are suitable for any Scheme object.


\begin{alltt}
(define ht1 (make-eq-hashtable))
(define ht2 (make-eq-hashtable 32))
\end{alltt}

\begin{description}

\label{objects_s275}\item[procedure] \texttt{(make-eqv-hashtable)}



\item[procedure] \texttt{(make-eqv-hashtable \textit{size})}



\item[returns] a new mutable eqv hashtable


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{size}} is provided, it must be a nonnegative exact integer
indicating approximately how many elements the hashtable should
initially hold.
Hashtables grow as needed, but when the hashtable grows it generally must
rehash all of the existing elements.
Providing a nonzero \texttt{\textit{size}} can help limit the amount of rehashing
that must be done as the table is initially populated.


An eqv hashtable compares keys using the \texttt{eqv?}
procedure and typically employs a hash function based on object addresses
for objects that are identifiable with \texttt{eq?}.
Its hash and equivalence functions are suitable for any Scheme object.


\begin{description}

\label{objects_s276}\item[procedure] \texttt{(make-hashtable \textit{hash} \textit{equiv?})}



\item[procedure] \texttt{(make-hashtable \textit{hash} \textit{equiv?} \textit{size})}



\item[returns] a new mutable hashtable


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{hash}} and \texttt{\textit{equiv?}} must be procedures.
If \texttt{\textit{size}} is provided, it must be a nonnegative exact integer
indicating approximately how many elements the hashtable should
initially hold.
Hashtables grow as needed, but when the hashtable grows it generally must
rehash all of the existing elements.
Providing a nonzero \texttt{\textit{size}} can help limit the amount of rehashing
that must be done as the table is initially populated.

The new hashtable computes hash values using \texttt{\textit{hash}} and
compares keys using \texttt{\textit{equiv?}}, neither of which should modify the
hashtable.
\texttt{\textit{equiv?}} should compare two keys and return false only if the two keys
should be distinguished.
\texttt{\textit{hash}} should accept a key as an argument and return a nonnegative
exact integer value that is the same each time it is called with arguments
that \texttt{\textit{equiv?}} does not distinguish.
The \texttt{\textit{hash}} and \texttt{\textit{equiv?}} procedures need not accept arbitrary inputs
as long as the hashtable is used only for keys that they do accept,
and both procedures may assume that the keys are immutable as long
as the keys are not modified while they have associations stored in the table.
The hashtable operation may call \texttt{\textit{hash}} and \texttt{\textit{equiv?}} once,
not at all, or multiple times for each hashtable operation.


\texttt{(define ht (make-hashtable string-hash string=?))}
\begin{description}

\label{objects_s277}\item[procedure] \texttt{(hashtable-mutable? \textit{hashtable})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{hashtable}} is mutable, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


Hashtables returned by one of the hashtable creation procedures above are
mutable, but those created by \texttt{hashtable-copy} may be immutable.
Immutable hashtables cannot be altered by any of the procedures
\texttt{hashtable-set!}, \texttt{hashtable-update!},
\texttt{hashtable-delete!}, or \texttt{hashtable-clear!}.


\begin{alltt}
(hashtable-mutable? (make-eq-hashtable)) \(\Rightarrow\) \#{}t
(hashtable-mutable? (hashtable-copy (make-eq-hashtable))) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s278}\item[procedure] \texttt{(hashtable-hash-function \textit{hashtable})}



\item[returns] the hash function associated with \texttt{\textit{hashtable}}


\item[procedure] \texttt{(hashtable-equivalence-function \textit{hashtable})}



\item[returns] the equivalence function associated with \texttt{\textit{hashtable}}


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{hashtable-hash-function} returns \texttt{\#{}f} for eq and eqv hashtables.

\begin{alltt}
(define ht (make-eq-hashtable))
(hashtable-hash-function ht) \(\Rightarrow\) \#{}f
(eq? (hashtable-equivalence-function ht) eq?) \(\Rightarrow\) \#{}t

(define ht (make-hashtable string-hash string=?))
(eq? (hashtable-hash-function ht) string-hash) \(\Rightarrow\) \#{}t
(eq? (hashtable-equivalence-function ht) string=?) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s279}\item[procedure] \texttt{(equal-hash \textit{obj})}



\item[procedure] \texttt{(string-hash \textit{string})}



\item[procedure] \texttt{(string-ci-hash \textit{string})}



\item[procedure] \texttt{(symbol-hash \textit{symbol})}



\item[returns] an exact nonnegative integer hash value


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


These procedures are hash functions suitable for use with the appropriate
Scheme predicate: \texttt{equal?} for \texttt{equal-hash}, \texttt{string=?}
for \texttt{string-hash}, \texttt{string-ci=?} for \texttt{string-ci-hash},
and \texttt{symbol=?} (or eq?) for \texttt{symbol-hash}.
The hash values returned by \texttt{equal-hash}, \texttt{string-hash},
and \texttt{string-ci-hash} are typically dependent on the current structure
and contents of the input values and are thus unsuitable if keys
are modified while they have associations in a hashtable.


\begin{description}

\label{objects_s280}\item[procedure] \texttt{(hashtable-set! \textit{hashtable} \textit{key} \textit{obj})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{hashtable}} must be a mutable hashtable.
\texttt{\textit{key}} should be an appropriate key for the hashtable's
hash and equivalence functions.
\texttt{\textit{obj}} may be any Scheme object.
\texttt{hashtable-set!} associates \texttt{\textit{key}}
with \texttt{\textit{obj}} in \texttt{\textit{hashtable}}, replacing the
existing association, if any.

\begin{alltt}
(define ht (make-eq-hashtable))
(hashtable-set! ht 'a 73)
\end{alltt}

\begin{description}

\label{objects_s281}\item[procedure] \texttt{(hashtable-ref \textit{hashtable} \textit{key} \textit{default})}



\item[returns] see below


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{key}} should be an appropriate key for the hashtable's
hash and equivalence functions.
\texttt{\textit{default}} may be any Scheme object.
\texttt{hashtable-ref} returns the value
associated with \texttt{\textit{key}} in \texttt{\textit{hashtable}}.
If no value is associated with \texttt{\textit{key}} in \texttt{\textit{hashtable}},
\texttt{hashtable-ref} returns \texttt{\textit{default}}.

\begin{alltt}
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))

(define eqht (make-eq-hashtable))
(hashtable-set! eqht p1 73)
(hashtable-ref eqht p1 55) \(\Rightarrow\) 73
(hashtable-ref eqht p2 55) \(\Rightarrow\) 55

(define equalht (make-hashtable equal-hash equal?))
(hashtable-set! equalht p1 73)
(hashtable-ref equalht p1 55) \(\Rightarrow\) 73
(hashtable-ref equalht p2 55) \(\Rightarrow\) 73
\end{alltt}

\begin{description}

\label{objects_s282}\item[procedure] \texttt{(hashtable-contains? \textit{hashtable} \textit{key})}



\item[returns] \texttt{\#{}t} if an association for \texttt{\textit{key}} exists in \texttt{\textit{hashtable}}, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{key}} should be an appropriate key for the hashtable's
hash and equivalence functions.

\begin{alltt}
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) \(\Rightarrow\) \#{}t
(hashtable-contains? ht p2) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s283}\item[procedure] \texttt{(hashtable-update! \textit{hashtable} \textit{key} \textit{procedure} \textit{default})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{hashtable}} must be a mutable hashtable.
\texttt{\textit{key}} should be an appropriate key for the hashtable's
hash and equivalence functions.
\texttt{\textit{default}} may be any Scheme object.
\texttt{\textit{procedure}} should accept one argument, should return one value, and should
not modify \texttt{\textit{hashtable}}.
\texttt{hashtable-update!} applies \texttt{\textit{procedure}} to the value associated with
\texttt{\textit{key}} in \texttt{\textit{hashtable}}, or to \texttt{\textit{default}} if no value is associated with
\texttt{\textit{key}} in \texttt{\textit{hashtable}}.
If \texttt{\textit{procedure}} returns, \texttt{hashtable-update!} associates \texttt{\textit{key}}
with the value returned by \texttt{\textit{procedure}}, replacing the old association,
if any.

A version of \texttt{hashtable-update!} that does not verify that it receives
arguments of the proper type might be defined as follows.


\begin{alltt}
(define hashtable-update!
  (lambda (ht key proc value)
    (hashtable-set! ht key
      (proc (hashtable-ref ht key value)))))
\end{alltt}


An implementation may, however, be able to implement
\texttt{hashtable-update!} more efficiently by avoiding multiple
hash computations and hashtable lookups.


\begin{alltt}
(define ht (make-eq-hashtable))
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  55)
(hashtable-ref ht 'a 0) \(\Rightarrow\) 110
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  0)
(hashtable-ref ht 'a 0) \(\Rightarrow\) 220
\end{alltt}

\begin{description}

\label{objects_s284}\item[procedure] \texttt{(hashtable-delete! \textit{hashtable} \textit{key})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{hashtable}} must be a mutable hashtable.
\texttt{\textit{key}} should be an appropriate key for the hashtable's
hash and equivalence functions.
\texttt{hashtable-delete!} drops any association
for \texttt{\textit{key}} from \texttt{\textit{hashtable}}.

\begin{alltt}
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) \(\Rightarrow\) \#{}t
(hashtable-delete! ht p1)
(hashtable-contains? ht p1) \(\Rightarrow\) \#{}f
(hashtable-contains? ht p2) \(\Rightarrow\) \#{}f
(hashtable-delete! ht p2)
\end{alltt}

\begin{description}

\label{objects_s285}\item[procedure] \texttt{(hashtable-size \textit{hashtable})}



\item[returns] number of entries in \texttt{\textit{hashtable}}


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-size ht) \(\Rightarrow\) 0
(hashtable-set! ht p1 73)
(hashtable-size ht) \(\Rightarrow\) 1
(hashtable-delete! ht p1)
(hashtable-size ht) \(\Rightarrow\) 0
\end{alltt}

\begin{description}

\label{objects_s286}\item[procedure] \texttt{(hashtable-copy \textit{hashtable})}



\item[procedure] \texttt{(hashtable-copy \textit{hashtable} \textit{mutable?})}



\item[returns] a new hashtable containing the same entries as \texttt{\textit{hashtable}}


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


If \texttt{\textit{mutable?}} is present and not false, the copy is mutable;
otherwise, the copy is immutable.


\begin{alltt}
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(hashtable-set! ht p1 "c")
(define ht-copy (hashtable-copy ht))
(hashtable-mutable? ht-copy) \(\Rightarrow\) \#{}f
(hashtable-delete! ht p1)
(hashtable-ref ht p1 \#{}f) \(\Rightarrow\) \#{}f
(hashtable-delete! ht-copy p1) \(\Rightarrow\) \textit{exception: not mutable}
(hashtable-ref ht-copy p1 \#{}f) \(\Rightarrow\) "c"
\end{alltt}

\begin{description}

\label{objects_s287}\item[procedure] \texttt{(hashtable-clear! \textit{hashtable})}



\item[procedure] \texttt{(hashtable-clear! \textit{hashtable} \textit{size})}



\item[returns] unspecified


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{hashtable}} must be a mutable hashtable.
If \texttt{\textit{size}} is provided, it must be a nonnegative exact integer.
\texttt{hashtable-clear!} removes all entries from \texttt{\textit{hashtable}}.
If size is provided, the hashtable is reset to the given size,
as if newly created by one of the hashtable creation operations
with size argument \texttt{\textit{size}}.

\begin{alltt}
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "first")
(hashtable-set! ht p2 "second")
(hashtable-size ht) \(\Rightarrow\) 2
(hashtable-clear! ht)
(hashtable-size ht) \(\Rightarrow\) 0
(hashtable-ref ht p1 \#{}f) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s288}\item[procedure] \texttt{(hashtable-keys \textit{hashtable})}



\item[returns] a vector containing the keys in \texttt{\textit{hashtable}}


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}


The keys may appear in any order in the returned vector.


\begin{alltt}
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-keys ht) \(\Rightarrow\) \#{}((a . b) q (a . b))
\end{alltt}

\begin{description}

\label{objects_s289}\item[procedure] \texttt{(hashtable-entries \textit{hashtable})}



\item[returns] two vectors: one of keys and a second of values


\item[libraries] \texttt{(rnrs hashtables)}, \texttt{(rnrs)}
\end{description}

\texttt{hashtable-entries} returns two values.
The first is a vector containing the keys in \texttt{\textit{hashtable}}, and the second
is a vector containing the corresponding values.
The keys and values may appear in any order, but the order is the same
for the keys and for the corresponding values.

\begin{alltt}
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-entries ht) \(\Rightarrow\) \#{}((a . b) q (a . b))
                        \#{}("two" "three" "one")
\end{alltt}

\section{\label{objects_g120}\label{objects_h14}Enumerations\label{objects_SECTENUMERATIONS}}



Enumerations are ordered sets of symbols, typically used to name and manipulate
options, as with the buffer modes and file options that may be specified when
files are created.

\begin{description}

\label{objects_s290}\item[syntax] \texttt{(define-enumeration \textit{name} (\textit{symbol} ...) \textit{constructor})}



\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


A \texttt{define-enumeration} form is a definition and can appear
anywhere any other definition can appear.


The \texttt{define-enumeration} syntax creates a new enumeration set with
the specified symbols in the specified order forming the enumeration's universe.
It defines a new syntactic form named by \texttt{\textit{name}} that may be used to verify
that a symbol is in the universe.
If \texttt{\textit{x}} is in the universe, \texttt{(\textit{name \textit{x}})} evaluates to
\texttt{\textit{x}}.
It is a syntax violation if \texttt{\textit{x}} is not in the universe.

\texttt{define-enumeration} also defines
a new syntactic form named by \texttt{\textit{constructor}} that may be used to create
subsets of the enumeration type.
If \texttt{\textit{x} ...} are each in the universe,
\texttt{\textit{(constructor \textit{x}} ...)} evaluates to an enumeration set
containing \texttt{\textit{x} ...}.
Otherwise, it is a syntax violation.
The same symbol may appear more than once in \texttt{\textit{x} ...},
but the resulting set contains only one occurrence of the symbol.

\begin{alltt}
(define-enumeration weather-element
  (hot warm cold sunny rainy snowy windy)
  weather)

(weather-element hot) \(\Rightarrow\) hot
(weather-element fun) \(\Rightarrow\) \textit{syntax violation}
(weather hot sunny windy) \(\Rightarrow\) \#{}\textless{}enum-set\textgreater{}
(enum-set-\textgreater{}list (weather rainy cold rainy)) \(\Rightarrow\) (cold rainy)
\end{alltt}

\begin{description}

\label{objects_s291}\item[procedure] \texttt{(make-enumeration \textit{symbol-list})}



\item[returns] an enumeration set


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


This procedure creates a new enumeration type whose universe comprises
the elements of \texttt{\textit{symbol-list}}, which must be
a list of symbols, in the order of their first appearance in the list.
It returns the universe of the new enumeration type as an enumeration
set.


\begin{alltt}
(define positions (make-enumeration '(top bottom above top beside)))
(enum-set-\textgreater{}list positions) \(\Rightarrow\) (top bottom above beside)
\end{alltt}

\begin{description}

\label{objects_s292}\item[procedure] \texttt{(enum-set-constructor \textit{enum-set})}



\item[returns] an enumeration-set construction procedure


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


This procedure returns a procedure \texttt{\textit{p}} that may be used to create
subsets of the universe of \texttt{\textit{enum-set}}.
\texttt{\textit{p}} must be passed a list of symbols, and each element of the list
must be an element of the universe of \texttt{\textit{enum-set}}.
The enumeration set returned by \texttt{\textit{p}} contains all and only the
symbols in the list it is passed.
The value returned by \texttt{\textit{p}} may contain elements not in \texttt{\textit{enum-set}}
if the universe of \texttt{\textit{enum-set}} contains those elements.


\begin{alltt}
(define e1 (make-enumeration '(one two three four)))
(define p1 (enum-set-constructor e1))
(define e2 (p1 '(one three)))
(enum-set-\textgreater{}list e2) \(\Rightarrow\) (one three)
(define p2 (enum-set-constructor e2))
(define e3 (p2 '(one two four)))
(enum-set-\textgreater{}list e3) \(\Rightarrow\) (one two four)
\end{alltt}

\begin{description}

\label{objects_s293}\item[procedure] \texttt{(enum-set-universe \textit{enum-set})}



\item[returns] the universe of \texttt{\textit{enum-set}}, as an enumeration set


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(define e1 (make-enumeration '(a b c a b c d)))
(enum-set-\textgreater{}list (enum-set-universe e1)) \(\Rightarrow\) (a b c d)
(define e2 ((enum-set-constructor e1) '(c)))
(enum-set-\textgreater{}list (enum-set-universe e2)) \(\Rightarrow\) (a b c d)
\end{alltt}

\begin{description}

\label{objects_s294}\item[procedure] \texttt{(enum-set-\textgreater{}list \textit{enum-set})}



\item[returns] a list of the elements of \texttt{\textit{enum-set}}


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


The symbols in the resulting list appear in the order given to
them when the enumeration type of \texttt{enum-set} was created.


\begin{alltt}
(define e1 (make-enumeration '(a b c a b c d)))
(enum-set-\textgreater{}list e1) \(\Rightarrow\) (a b c d)
(define e2 ((enum-set-constructor e1) '(d c a b)))
(enum-set-\textgreater{}list e2) \(\Rightarrow\) (a b c d)
\end{alltt}

\begin{description}

\label{objects_s295}\item[procedure] \texttt{(enum-set-subset? \textit{enum-set\textsubscript{1}} \textit{enum-set\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{enum-set\textsubscript{1}}} is a subset of \texttt{\textit{enum-set\textsubscript{2}}}, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


An enumeration set \texttt{\textit{enum-set\textsubscript{1}}} is a subset of an enumeration set \texttt{\textit{enum-set\textsubscript{2}}}
if and only if the universe of \texttt{\textit{enum-set\textsubscript{1}}} is a subset of the universe of \texttt{\textit{enum-set\textsubscript{2}}}
and each element of \texttt{\textit{enum-set\textsubscript{1}}} is an element of \texttt{\textit{enum-set\textsubscript{2}}}.


\begin{alltt}
(define e1 (make-enumeration '(a b c)))
(define e2 (make-enumeration '(a b c d e)))
(enum-set-subset? e1 e2) \(\Rightarrow\) \#{}t
(enum-set-subset? e2 e1) \(\Rightarrow\) \#{}f
(define e3 ((enum-set-constructor e2) '(a c)))
(enum-set-subset? e3 e1) \(\Rightarrow\) \#{}f
(enum-set-subset? e3 e2) \(\Rightarrow\) \#{}t
\end{alltt}

\begin{description}

\label{objects_s296}\item[procedure] \texttt{(enum-set=? \textit{enum-set\textsubscript{1}} \textit{enum-set\textsubscript{2}})}



\item[returns] \texttt{\#{}t} if \texttt{\textit{enum-set\textsubscript{1}}} and \texttt{\textit{enum-set\textsubscript{2}}} are equivalent, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


Two enumeration sets \texttt{\textit{enum-set\textsubscript{1}}} and \texttt{\textit{enum-set\textsubscript{2}}} are equivalent if each is
a subset of the other.


\begin{alltt}
(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(b d c a)))
(enum-set=? e1 e2) \(\Rightarrow\) \#{}t
(define e3 ((enum-set-constructor e1) '(a c)))
(define e4 ((enum-set-constructor e2) '(a c)))
(enum-set=? e3 e4) \(\Rightarrow\) \#{}t
(enum-set=? e3 e2) \(\Rightarrow\) \#{}f
\end{alltt}

\texttt{enum-set=?} could be defined in terms of \texttt{enum-set-subset?} as follows.

\begin{alltt}
(define enum-set=?
  (lambda (e1 e2)
    (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))
\end{alltt}

\begin{description}

\label{objects_s297}\item[procedure] \texttt{(enum-set-member? \textit{symbol} \textit{enum-set})}



\item[returns] \texttt{\#{}t} if symbol is an element of \texttt{\textit{enum-set}}, \texttt{\#{}f} otherwise


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(define e1 (make-enumeration '(a b c d e)))
(define e2 ((enum-set-constructor e1) '(d b)))
(enum-set-member? 'c e1) \(\Rightarrow\) \#{}t
(enum-set-member? 'c e2) \(\Rightarrow\) \#{}f
\end{alltt}

\begin{description}

\label{objects_s298}\item[procedure] \texttt{(enum-set-union \textit{enum-set\textsubscript{1}} \textit{enum-set\textsubscript{2}})}



\item[returns] the union of \texttt{\textit{enum-set\textsubscript{1}}} and \texttt{\textit{enum-set\textsubscript{2}}}


\item[procedure] \texttt{(enum-set-intersection \textit{enum-set\textsubscript{1}} \textit{enum-set\textsubscript{2}})}



\item[returns] the intersection of \texttt{\textit{enum-set\textsubscript{1}}} and \texttt{\textit{enum-set\textsubscript{2}}}


\item[procedure] \texttt{(enum-set-difference \textit{enum-set\textsubscript{1}} \textit{enum-set\textsubscript{2}})}



\item[returns] the difference of \texttt{\textit{enum-set\textsubscript{1}}} and \texttt{\textit{enum-set\textsubscript{2}}}


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}

\texttt{\textit{enum-set\textsubscript{1}}} and \texttt{\textit{enum-set\textsubscript{2}}} must have the same enumeration type.
Each procedure returns a new enumeration set representing the union, intersection,
or difference of the two sets.

\begin{alltt}
(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a c)))
(define e3 ((enum-set-constructor e1) '(b c)))
(enum-set-\textgreater{}list (enum-set-union e2 e3)) \(\Rightarrow\) (a b c)
(enum-set-\textgreater{}list (enum-set-intersection e2 e3)) \(\Rightarrow\) (c)
(enum-set-\textgreater{}list (enum-set-difference e2 e3)) \(\Rightarrow\) (a)
(enum-set-\textgreater{}list (enum-set-difference e3 e2)) \(\Rightarrow\) (b)
(define e4 (make-enumeration '(b d c a)))
(enum-set-union e1 e4) \(\Rightarrow\) \textit{exception: different enumeration types}
\end{alltt}

\begin{description}

\label{objects_s299}\item[procedure] \texttt{(enum-set-complement \textit{enum-set})}



\item[returns] the complement of \texttt{\textit{enum-set}} relative to its universe


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


\begin{alltt}
(define e1 (make-enumeration '(a b c d)))
(enum-set-\textgreater{}list (enum-set-complement e1)) \(\Rightarrow\) ()
(define e2 ((enum-set-constructor e1) '(a c)))
(enum-set-\textgreater{}list (enum-set-complement e2)) \(\Rightarrow\) (b d)
\end{alltt}

\begin{description}

\label{objects_s300}\item[procedure] \texttt{(enum-set-projection \textit{enum-set\textsubscript{1}} \textit{enum-set\textsubscript{2}})}



\item[returns] the projection of \texttt{\textit{enum-set\textsubscript{1}}} into the universe of \texttt{\textit{enum-set\textsubscript{2}}}


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}


Any elements of \texttt{\textit{enum-set\textsubscript{1}}} not in the universe of \texttt{\textit{enum-set\textsubscript{2}}} are dropped.
The result is of the same enumeration type as \texttt{\textit{enum-set\textsubscript{2}}}.


\begin{alltt}
(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(a b c d e f g)))
(define e3 ((enum-set-constructor e1) '(a d)))
(define e4 ((enum-set-constructor e2) '(a c e g)))
(enum-set-\textgreater{}list (enum-set-projection e4 e3)) \(\Rightarrow\) (a c)
(enum-set-\textgreater{}list
  (enum-set-union e3
    (enum-set-projection e4 e3))) \(\Rightarrow\) (a c d)
\end{alltt}

\begin{description}

\label{objects_s301}\item[procedure] \texttt{(enum-set-indexer \textit{enum-set})}



\item[returns] a procedure that returns the index of a symbol in the universe of \texttt{\textit{enum-set}}


\item[libraries] \texttt{(rnrs enums)}, \texttt{(rnrs)}
\end{description}

\texttt{enum-set-indexer} returns a procedure \texttt{\textit{p}} that, when applied to a symbol
in the universe of \texttt{\textit{enum-set}}, returns the index of the symbol (zero-based) in
the ordered set of symbols that form the universe.
If applied to a symbol not in the universe, \texttt{\textit{p}} returns \texttt{\#{}f}.

\begin{alltt}
(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a d)))
(define p (enum-set-indexer e2))
(list (p 'a) (p 'c) (p 'e)) \(\Rightarrow\) (0 2 \#{}f)
\end{alltt}



